
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Coin
 * 
 */
export type Coin = $Result.DefaultSelection<Prisma.$CoinPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Hashtag
 * 
 */
export type Hashtag = $Result.DefaultSelection<Prisma.$HashtagPayload>
/**
 * Model BondingCurve
 * 
 */
export type BondingCurve = $Result.DefaultSelection<Prisma.$BondingCurvePayload>
/**
 * Model FeeStructure
 * 
 */
export type FeeStructure = $Result.DefaultSelection<Prisma.$FeeStructurePayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Comments
 * 
 */
export type Comments = $Result.DefaultSelection<Prisma.$CommentsPayload>
/**
 * Model Reputation
 * 
 */
export type Reputation = $Result.DefaultSelection<Prisma.$ReputationPayload>
/**
 * Model WalletAddress
 * 
 */
export type WalletAddress = $Result.DefaultSelection<Prisma.$WalletAddressPayload>
/**
 * Model SocialAccount
 * 
 */
export type SocialAccount = $Result.DefaultSelection<Prisma.$SocialAccountPayload>
/**
 * Model TokenHolding
 * 
 */
export type TokenHolding = $Result.DefaultSelection<Prisma.$TokenHoldingPayload>
/**
 * Model PriceHistory
 * 
 */
export type PriceHistory = $Result.DefaultSelection<Prisma.$PriceHistoryPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Proposal
 * 
 */
export type Proposal = $Result.DefaultSelection<Prisma.$ProposalPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Blockchain: {
  sol: 'sol',
  bnb: 'bnb',
  eth: 'eth',
  avax: 'avax',
  blast: 'blast',
  optimism: 'optimism',
  opbnb: 'opbnb',
  aptos: 'aptos',
  hbar: 'hbar',
  linear: 'linear'
};

export type Blockchain = (typeof Blockchain)[keyof typeof Blockchain]


export const CoinStatus: {
  voting: 'voting',
  bondingCurve: 'bondingCurve',
  manualLaunch: 'manualLaunch',
  completed: 'completed'
};

export type CoinStatus = (typeof CoinStatus)[keyof typeof CoinStatus]

}

export type Blockchain = $Enums.Blockchain

export const Blockchain: typeof $Enums.Blockchain

export type CoinStatus = $Enums.CoinStatus

export const CoinStatus: typeof $Enums.CoinStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coin`: Exposes CRUD operations for the **Coin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coins
    * const coins = await prisma.coin.findMany()
    * ```
    */
  get coin(): Prisma.CoinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hashtag`: Exposes CRUD operations for the **Hashtag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hashtags
    * const hashtags = await prisma.hashtag.findMany()
    * ```
    */
  get hashtag(): Prisma.HashtagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bondingCurve`: Exposes CRUD operations for the **BondingCurve** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BondingCurves
    * const bondingCurves = await prisma.bondingCurve.findMany()
    * ```
    */
  get bondingCurve(): Prisma.BondingCurveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feeStructure`: Exposes CRUD operations for the **FeeStructure** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeStructures
    * const feeStructures = await prisma.feeStructure.findMany()
    * ```
    */
  get feeStructure(): Prisma.FeeStructureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **Comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.CommentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reputation`: Exposes CRUD operations for the **Reputation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reputations
    * const reputations = await prisma.reputation.findMany()
    * ```
    */
  get reputation(): Prisma.ReputationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.walletAddress`: Exposes CRUD operations for the **WalletAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletAddresses
    * const walletAddresses = await prisma.walletAddress.findMany()
    * ```
    */
  get walletAddress(): Prisma.WalletAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialAccount`: Exposes CRUD operations for the **SocialAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialAccounts
    * const socialAccounts = await prisma.socialAccount.findMany()
    * ```
    */
  get socialAccount(): Prisma.SocialAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokenHolding`: Exposes CRUD operations for the **TokenHolding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenHoldings
    * const tokenHoldings = await prisma.tokenHolding.findMany()
    * ```
    */
  get tokenHolding(): Prisma.TokenHoldingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceHistory`: Exposes CRUD operations for the **PriceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceHistories
    * const priceHistories = await prisma.priceHistory.findMany()
    * ```
    */
  get priceHistory(): Prisma.PriceHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposal`: Exposes CRUD operations for the **Proposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proposals
    * const proposals = await prisma.proposal.findMany()
    * ```
    */
  get proposal(): Prisma.ProposalDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Coin: 'Coin',
    Milestone: 'Milestone',
    Hashtag: 'Hashtag',
    BondingCurve: 'BondingCurve',
    FeeStructure: 'FeeStructure',
    Vote: 'Vote',
    ChatMessage: 'ChatMessage',
    Comments: 'Comments',
    Reputation: 'Reputation',
    WalletAddress: 'WalletAddress',
    SocialAccount: 'SocialAccount',
    TokenHolding: 'TokenHolding',
    PriceHistory: 'PriceHistory',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    Transaction: 'Transaction',
    Proposal: 'Proposal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "coin" | "milestone" | "hashtag" | "bondingCurve" | "feeStructure" | "vote" | "chatMessage" | "comments" | "reputation" | "walletAddress" | "socialAccount" | "tokenHolding" | "priceHistory" | "account" | "session" | "verificationToken" | "transaction" | "proposal"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Coin: {
        payload: Prisma.$CoinPayload<ExtArgs>
        fields: Prisma.CoinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>
          }
          findFirst: {
            args: Prisma.CoinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>
          }
          findMany: {
            args: Prisma.CoinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>[]
          }
          create: {
            args: Prisma.CoinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>
          }
          createMany: {
            args: Prisma.CoinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>[]
          }
          delete: {
            args: Prisma.CoinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>
          }
          update: {
            args: Prisma.CoinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>
          }
          deleteMany: {
            args: Prisma.CoinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoinUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>[]
          }
          upsert: {
            args: Prisma.CoinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinPayload>
          }
          aggregate: {
            args: Prisma.CoinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoin>
          }
          groupBy: {
            args: Prisma.CoinGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoinGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoinCountArgs<ExtArgs>
            result: $Utils.Optional<CoinCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Hashtag: {
        payload: Prisma.$HashtagPayload<ExtArgs>
        fields: Prisma.HashtagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HashtagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HashtagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>
          }
          findFirst: {
            args: Prisma.HashtagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HashtagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>
          }
          findMany: {
            args: Prisma.HashtagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>[]
          }
          create: {
            args: Prisma.HashtagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>
          }
          createMany: {
            args: Prisma.HashtagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HashtagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>[]
          }
          delete: {
            args: Prisma.HashtagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>
          }
          update: {
            args: Prisma.HashtagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>
          }
          deleteMany: {
            args: Prisma.HashtagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HashtagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HashtagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>[]
          }
          upsert: {
            args: Prisma.HashtagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HashtagPayload>
          }
          aggregate: {
            args: Prisma.HashtagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHashtag>
          }
          groupBy: {
            args: Prisma.HashtagGroupByArgs<ExtArgs>
            result: $Utils.Optional<HashtagGroupByOutputType>[]
          }
          count: {
            args: Prisma.HashtagCountArgs<ExtArgs>
            result: $Utils.Optional<HashtagCountAggregateOutputType> | number
          }
        }
      }
      BondingCurve: {
        payload: Prisma.$BondingCurvePayload<ExtArgs>
        fields: Prisma.BondingCurveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BondingCurveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BondingCurveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>
          }
          findFirst: {
            args: Prisma.BondingCurveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BondingCurveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>
          }
          findMany: {
            args: Prisma.BondingCurveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>[]
          }
          create: {
            args: Prisma.BondingCurveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>
          }
          createMany: {
            args: Prisma.BondingCurveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BondingCurveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>[]
          }
          delete: {
            args: Prisma.BondingCurveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>
          }
          update: {
            args: Prisma.BondingCurveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>
          }
          deleteMany: {
            args: Prisma.BondingCurveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BondingCurveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BondingCurveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>[]
          }
          upsert: {
            args: Prisma.BondingCurveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BondingCurvePayload>
          }
          aggregate: {
            args: Prisma.BondingCurveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBondingCurve>
          }
          groupBy: {
            args: Prisma.BondingCurveGroupByArgs<ExtArgs>
            result: $Utils.Optional<BondingCurveGroupByOutputType>[]
          }
          count: {
            args: Prisma.BondingCurveCountArgs<ExtArgs>
            result: $Utils.Optional<BondingCurveCountAggregateOutputType> | number
          }
        }
      }
      FeeStructure: {
        payload: Prisma.$FeeStructurePayload<ExtArgs>
        fields: Prisma.FeeStructureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeStructureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeStructureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findFirst: {
            args: Prisma.FeeStructureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeStructureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          findMany: {
            args: Prisma.FeeStructureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          create: {
            args: Prisma.FeeStructureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          createMany: {
            args: Prisma.FeeStructureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeStructureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          delete: {
            args: Prisma.FeeStructureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          update: {
            args: Prisma.FeeStructureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          deleteMany: {
            args: Prisma.FeeStructureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeStructureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeeStructureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>[]
          }
          upsert: {
            args: Prisma.FeeStructureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeStructurePayload>
          }
          aggregate: {
            args: Prisma.FeeStructureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeStructure>
          }
          groupBy: {
            args: Prisma.FeeStructureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeStructureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeStructureCountArgs<ExtArgs>
            result: $Utils.Optional<FeeStructureCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Comments: {
        payload: Prisma.$CommentsPayload<ExtArgs>
        fields: Prisma.CommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findFirst: {
            args: Prisma.CommentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          findMany: {
            args: Prisma.CommentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          create: {
            args: Prisma.CommentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          createMany: {
            args: Prisma.CommentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          delete: {
            args: Prisma.CommentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          update: {
            args: Prisma.CommentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          deleteMany: {
            args: Prisma.CommentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>[]
          }
          upsert: {
            args: Prisma.CommentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.CommentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      Reputation: {
        payload: Prisma.$ReputationPayload<ExtArgs>
        fields: Prisma.ReputationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReputationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReputationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>
          }
          findFirst: {
            args: Prisma.ReputationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReputationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>
          }
          findMany: {
            args: Prisma.ReputationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>[]
          }
          create: {
            args: Prisma.ReputationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>
          }
          createMany: {
            args: Prisma.ReputationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReputationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>[]
          }
          delete: {
            args: Prisma.ReputationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>
          }
          update: {
            args: Prisma.ReputationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>
          }
          deleteMany: {
            args: Prisma.ReputationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReputationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReputationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>[]
          }
          upsert: {
            args: Prisma.ReputationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReputationPayload>
          }
          aggregate: {
            args: Prisma.ReputationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReputation>
          }
          groupBy: {
            args: Prisma.ReputationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReputationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReputationCountArgs<ExtArgs>
            result: $Utils.Optional<ReputationCountAggregateOutputType> | number
          }
        }
      }
      WalletAddress: {
        payload: Prisma.$WalletAddressPayload<ExtArgs>
        fields: Prisma.WalletAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>
          }
          findFirst: {
            args: Prisma.WalletAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>
          }
          findMany: {
            args: Prisma.WalletAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>[]
          }
          create: {
            args: Prisma.WalletAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>
          }
          createMany: {
            args: Prisma.WalletAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>[]
          }
          delete: {
            args: Prisma.WalletAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>
          }
          update: {
            args: Prisma.WalletAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>
          }
          deleteMany: {
            args: Prisma.WalletAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WalletAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>[]
          }
          upsert: {
            args: Prisma.WalletAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletAddressPayload>
          }
          aggregate: {
            args: Prisma.WalletAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletAddress>
          }
          groupBy: {
            args: Prisma.WalletAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletAddressCountArgs<ExtArgs>
            result: $Utils.Optional<WalletAddressCountAggregateOutputType> | number
          }
        }
      }
      SocialAccount: {
        payload: Prisma.$SocialAccountPayload<ExtArgs>
        fields: Prisma.SocialAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>
          }
          findFirst: {
            args: Prisma.SocialAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>
          }
          findMany: {
            args: Prisma.SocialAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>[]
          }
          create: {
            args: Prisma.SocialAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>
          }
          createMany: {
            args: Prisma.SocialAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>[]
          }
          delete: {
            args: Prisma.SocialAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>
          }
          update: {
            args: Prisma.SocialAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>
          }
          deleteMany: {
            args: Prisma.SocialAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>[]
          }
          upsert: {
            args: Prisma.SocialAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialAccountPayload>
          }
          aggregate: {
            args: Prisma.SocialAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialAccount>
          }
          groupBy: {
            args: Prisma.SocialAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SocialAccountCountAggregateOutputType> | number
          }
        }
      }
      TokenHolding: {
        payload: Prisma.$TokenHoldingPayload<ExtArgs>
        fields: Prisma.TokenHoldingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenHoldingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenHoldingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>
          }
          findFirst: {
            args: Prisma.TokenHoldingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenHoldingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>
          }
          findMany: {
            args: Prisma.TokenHoldingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>[]
          }
          create: {
            args: Prisma.TokenHoldingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>
          }
          createMany: {
            args: Prisma.TokenHoldingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenHoldingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>[]
          }
          delete: {
            args: Prisma.TokenHoldingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>
          }
          update: {
            args: Prisma.TokenHoldingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>
          }
          deleteMany: {
            args: Prisma.TokenHoldingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenHoldingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenHoldingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>[]
          }
          upsert: {
            args: Prisma.TokenHoldingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenHoldingPayload>
          }
          aggregate: {
            args: Prisma.TokenHoldingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenHolding>
          }
          groupBy: {
            args: Prisma.TokenHoldingGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenHoldingGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenHoldingCountArgs<ExtArgs>
            result: $Utils.Optional<TokenHoldingCountAggregateOutputType> | number
          }
        }
      }
      PriceHistory: {
        payload: Prisma.$PriceHistoryPayload<ExtArgs>
        fields: Prisma.PriceHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findFirst: {
            args: Prisma.PriceHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          findMany: {
            args: Prisma.PriceHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          create: {
            args: Prisma.PriceHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          createMany: {
            args: Prisma.PriceHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          delete: {
            args: Prisma.PriceHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          update: {
            args: Prisma.PriceHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PriceHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PriceHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceHistoryPayload>
          }
          aggregate: {
            args: Prisma.PriceHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceHistory>
          }
          groupBy: {
            args: Prisma.PriceHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PriceHistoryCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Proposal: {
        payload: Prisma.$ProposalPayload<ExtArgs>
        fields: Prisma.ProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findFirst: {
            args: Prisma.ProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          findMany: {
            args: Prisma.ProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          create: {
            args: Prisma.ProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          createMany: {
            args: Prisma.ProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          delete: {
            args: Prisma.ProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          update: {
            args: Prisma.ProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          deleteMany: {
            args: Prisma.ProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>[]
          }
          upsert: {
            args: Prisma.ProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalPayload>
          }
          aggregate: {
            args: Prisma.ProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposal>
          }
          groupBy: {
            args: Prisma.ProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    coin?: CoinOmit
    milestone?: MilestoneOmit
    hashtag?: HashtagOmit
    bondingCurve?: BondingCurveOmit
    feeStructure?: FeeStructureOmit
    vote?: VoteOmit
    chatMessage?: ChatMessageOmit
    comments?: CommentsOmit
    reputation?: ReputationOmit
    walletAddress?: WalletAddressOmit
    socialAccount?: SocialAccountOmit
    tokenHolding?: TokenHoldingOmit
    priceHistory?: PriceHistoryOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    transaction?: TransactionOmit
    proposal?: ProposalOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    coinsCreated: number
    referrals: number
    walletAddresses: number
    socialAccounts: number
    tokenHoldings: number
    votes: number
    chatMessages: number
    comments: number
    accounts: number
    sessions: number
    transactions: number
    proposals: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coinsCreated?: boolean | UserCountOutputTypeCountCoinsCreatedArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    walletAddresses?: boolean | UserCountOutputTypeCountWalletAddressesArgs
    socialAccounts?: boolean | UserCountOutputTypeCountSocialAccountsArgs
    tokenHoldings?: boolean | UserCountOutputTypeCountTokenHoldingsArgs
    votes?: boolean | UserCountOutputTypeCountVotesArgs
    chatMessages?: boolean | UserCountOutputTypeCountChatMessagesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    proposals?: boolean | UserCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoinsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWalletAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletAddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokenHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenHoldingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type CoinCountOutputType
   */

  export type CoinCountOutputType = {
    chatMessages: number
    comments: number
    votes: number
    tokenHoldings: number
    milestones: number
    hashtags: number
    priceHistory: number
    transaction: number
    proposals: number
  }

  export type CoinCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatMessages?: boolean | CoinCountOutputTypeCountChatMessagesArgs
    comments?: boolean | CoinCountOutputTypeCountCommentsArgs
    votes?: boolean | CoinCountOutputTypeCountVotesArgs
    tokenHoldings?: boolean | CoinCountOutputTypeCountTokenHoldingsArgs
    milestones?: boolean | CoinCountOutputTypeCountMilestonesArgs
    hashtags?: boolean | CoinCountOutputTypeCountHashtagsArgs
    priceHistory?: boolean | CoinCountOutputTypeCountPriceHistoryArgs
    transaction?: boolean | CoinCountOutputTypeCountTransactionArgs
    proposals?: boolean | CoinCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinCountOutputType
     */
    select?: CoinCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountChatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountTokenHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenHoldingWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountHashtagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HashtagWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountPriceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * CoinCountOutputType without action
   */
  export type CoinCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
  }


  /**
   * Count Type HashtagCountOutputType
   */

  export type HashtagCountOutputType = {
    coins: number
  }

  export type HashtagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coins?: boolean | HashtagCountOutputTypeCountCoinsArgs
  }

  // Custom InputTypes
  /**
   * HashtagCountOutputType without action
   */
  export type HashtagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HashtagCountOutputType
     */
    select?: HashtagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HashtagCountOutputType without action
   */
  export type HashtagCountOutputTypeCountCoinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    confirmedEmail: string | null
    emailVerified: Date | null
    passwordHash: string | null
    role: string | null
    isVerified: boolean | null
    verificationToken: string | null
    verificationTokenExpiresAt: Date | null
    resetToken: string | null
    resetTokenExpiresAt: Date | null
    pictureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referrerId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    confirmedEmail: string | null
    emailVerified: Date | null
    passwordHash: string | null
    role: string | null
    isVerified: boolean | null
    verificationToken: string | null
    verificationTokenExpiresAt: Date | null
    resetToken: string | null
    resetTokenExpiresAt: Date | null
    pictureUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    referralCode: string | null
    referrerId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    confirmedEmail: number
    emailVerified: number
    passwordHash: number
    role: number
    isVerified: number
    verificationToken: number
    verificationTokenExpiresAt: number
    resetToken: number
    resetTokenExpiresAt: number
    pictureUrl: number
    createdAt: number
    updatedAt: number
    referralCode: number
    referrerId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    confirmedEmail?: true
    emailVerified?: true
    passwordHash?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    verificationTokenExpiresAt?: true
    resetToken?: true
    resetTokenExpiresAt?: true
    pictureUrl?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referrerId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    confirmedEmail?: true
    emailVerified?: true
    passwordHash?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    verificationTokenExpiresAt?: true
    resetToken?: true
    resetTokenExpiresAt?: true
    pictureUrl?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referrerId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    confirmedEmail?: true
    emailVerified?: true
    passwordHash?: true
    role?: true
    isVerified?: true
    verificationToken?: true
    verificationTokenExpiresAt?: true
    resetToken?: true
    resetTokenExpiresAt?: true
    pictureUrl?: true
    createdAt?: true
    updatedAt?: true
    referralCode?: true
    referrerId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string | null
    email: string | null
    confirmedEmail: string | null
    emailVerified: Date | null
    passwordHash: string
    role: string
    isVerified: boolean
    verificationToken: string | null
    verificationTokenExpiresAt: Date | null
    resetToken: string | null
    resetTokenExpiresAt: Date | null
    pictureUrl: string
    createdAt: Date
    updatedAt: Date
    referralCode: string | null
    referrerId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    confirmedEmail?: boolean
    emailVerified?: boolean
    passwordHash?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiresAt?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    pictureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referrerId?: boolean
    coinsCreated?: boolean | User$coinsCreatedArgs<ExtArgs>
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    walletAddresses?: boolean | User$walletAddressesArgs<ExtArgs>
    socialAccounts?: boolean | User$socialAccountsArgs<ExtArgs>
    tokenHoldings?: boolean | User$tokenHoldingsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    chatMessages?: boolean | User$chatMessagesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reputation?: boolean | User$reputationArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    proposals?: boolean | User$proposalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    confirmedEmail?: boolean
    emailVerified?: boolean
    passwordHash?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiresAt?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    pictureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referrerId?: boolean
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    confirmedEmail?: boolean
    emailVerified?: boolean
    passwordHash?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiresAt?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    pictureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referrerId?: boolean
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    confirmedEmail?: boolean
    emailVerified?: boolean
    passwordHash?: boolean
    role?: boolean
    isVerified?: boolean
    verificationToken?: boolean
    verificationTokenExpiresAt?: boolean
    resetToken?: boolean
    resetTokenExpiresAt?: boolean
    pictureUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    referralCode?: boolean
    referrerId?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "confirmedEmail" | "emailVerified" | "passwordHash" | "role" | "isVerified" | "verificationToken" | "verificationTokenExpiresAt" | "resetToken" | "resetTokenExpiresAt" | "pictureUrl" | "createdAt" | "updatedAt" | "referralCode" | "referrerId", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coinsCreated?: boolean | User$coinsCreatedArgs<ExtArgs>
    referrer?: boolean | User$referrerArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    walletAddresses?: boolean | User$walletAddressesArgs<ExtArgs>
    socialAccounts?: boolean | User$socialAccountsArgs<ExtArgs>
    tokenHoldings?: boolean | User$tokenHoldingsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    chatMessages?: boolean | User$chatMessagesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reputation?: boolean | User$reputationArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    proposals?: boolean | User$proposalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | User$referrerArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      coinsCreated: Prisma.$CoinPayload<ExtArgs>[]
      referrer: Prisma.$UserPayload<ExtArgs> | null
      referrals: Prisma.$UserPayload<ExtArgs>[]
      walletAddresses: Prisma.$WalletAddressPayload<ExtArgs>[]
      socialAccounts: Prisma.$SocialAccountPayload<ExtArgs>[]
      tokenHoldings: Prisma.$TokenHoldingPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
      chatMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      comments: Prisma.$CommentsPayload<ExtArgs>[]
      reputation: Prisma.$ReputationPayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string | null
      email: string | null
      confirmedEmail: string | null
      emailVerified: Date | null
      passwordHash: string
      role: string
      isVerified: boolean
      verificationToken: string | null
      verificationTokenExpiresAt: Date | null
      resetToken: string | null
      resetTokenExpiresAt: Date | null
      pictureUrl: string
      createdAt: Date
      updatedAt: Date
      referralCode: string | null
      referrerId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coinsCreated<T extends User$coinsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$coinsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrer<T extends User$referrerArgs<ExtArgs> = {}>(args?: Subset<T, User$referrerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    walletAddresses<T extends User$walletAddressesArgs<ExtArgs> = {}>(args?: Subset<T, User$walletAddressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialAccounts<T extends User$socialAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$socialAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokenHoldings<T extends User$tokenHoldingsArgs<ExtArgs> = {}>(args?: Subset<T, User$tokenHoldingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends User$votesArgs<ExtArgs> = {}>(args?: Subset<T, User$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatMessages<T extends User$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reputation<T extends User$reputationArgs<ExtArgs> = {}>(args?: Subset<T, User$reputationArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposals<T extends User$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, User$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly confirmedEmail: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly verificationTokenExpiresAt: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiresAt: FieldRef<"User", 'DateTime'>
    readonly pictureUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly referrerId: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.coinsCreated
   */
  export type User$coinsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    where?: CoinWhereInput
    orderBy?: CoinOrderByWithRelationInput | CoinOrderByWithRelationInput[]
    cursor?: CoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoinScalarFieldEnum | CoinScalarFieldEnum[]
  }

  /**
   * User.referrer
   */
  export type User$referrerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.walletAddresses
   */
  export type User$walletAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    where?: WalletAddressWhereInput
    orderBy?: WalletAddressOrderByWithRelationInput | WalletAddressOrderByWithRelationInput[]
    cursor?: WalletAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletAddressScalarFieldEnum | WalletAddressScalarFieldEnum[]
  }

  /**
   * User.socialAccounts
   */
  export type User$socialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    where?: SocialAccountWhereInput
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[]
    cursor?: SocialAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[]
  }

  /**
   * User.tokenHoldings
   */
  export type User$tokenHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    where?: TokenHoldingWhereInput
    orderBy?: TokenHoldingOrderByWithRelationInput | TokenHoldingOrderByWithRelationInput[]
    cursor?: TokenHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenHoldingScalarFieldEnum | TokenHoldingScalarFieldEnum[]
  }

  /**
   * User.votes
   */
  export type User$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * User.chatMessages
   */
  export type User$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * User.reputation
   */
  export type User$reputationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    where?: ReputationWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.proposals
   */
  export type User$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Coin
   */

  export type AggregateCoin = {
    _count: CoinCountAggregateOutputType | null
    _avg: CoinAvgAggregateOutputType | null
    _sum: CoinSumAggregateOutputType | null
    _min: CoinMinAggregateOutputType | null
    _max: CoinMaxAggregateOutputType | null
  }

  export type CoinAvgAggregateOutputType = {
    totalSupply: Decimal | null
    airdropAmount: Decimal | null
    reputationScore: number | null
    marketCap: Decimal | null
  }

  export type CoinSumAggregateOutputType = {
    totalSupply: Decimal | null
    airdropAmount: Decimal | null
    reputationScore: number | null
    marketCap: Decimal | null
  }

  export type CoinMinAggregateOutputType = {
    id: string | null
    name: string | null
    ticker: string | null
    description: string | null
    pictureUrl: string | null
    telegramLink: string | null
    discordLink: string | null
    totalSupply: Decimal | null
    airdropAmount: Decimal | null
    blockchain: $Enums.Blockchain | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    reputationScore: number | null
    status: $Enums.CoinStatus | null
    marketCap: Decimal | null
  }

  export type CoinMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ticker: string | null
    description: string | null
    pictureUrl: string | null
    telegramLink: string | null
    discordLink: string | null
    totalSupply: Decimal | null
    airdropAmount: Decimal | null
    blockchain: $Enums.Blockchain | null
    createdAt: Date | null
    updatedAt: Date | null
    creatorId: string | null
    reputationScore: number | null
    status: $Enums.CoinStatus | null
    marketCap: Decimal | null
  }

  export type CoinCountAggregateOutputType = {
    id: number
    name: number
    ticker: number
    description: number
    pictureUrl: number
    telegramLink: number
    discordLink: number
    socialLinks: number
    totalSupply: number
    airdropAmount: number
    blockchain: number
    createdAt: number
    updatedAt: number
    creatorId: number
    reputationScore: number
    status: number
    marketCap: number
    _all: number
  }


  export type CoinAvgAggregateInputType = {
    totalSupply?: true
    airdropAmount?: true
    reputationScore?: true
    marketCap?: true
  }

  export type CoinSumAggregateInputType = {
    totalSupply?: true
    airdropAmount?: true
    reputationScore?: true
    marketCap?: true
  }

  export type CoinMinAggregateInputType = {
    id?: true
    name?: true
    ticker?: true
    description?: true
    pictureUrl?: true
    telegramLink?: true
    discordLink?: true
    totalSupply?: true
    airdropAmount?: true
    blockchain?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    reputationScore?: true
    status?: true
    marketCap?: true
  }

  export type CoinMaxAggregateInputType = {
    id?: true
    name?: true
    ticker?: true
    description?: true
    pictureUrl?: true
    telegramLink?: true
    discordLink?: true
    totalSupply?: true
    airdropAmount?: true
    blockchain?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    reputationScore?: true
    status?: true
    marketCap?: true
  }

  export type CoinCountAggregateInputType = {
    id?: true
    name?: true
    ticker?: true
    description?: true
    pictureUrl?: true
    telegramLink?: true
    discordLink?: true
    socialLinks?: true
    totalSupply?: true
    airdropAmount?: true
    blockchain?: true
    createdAt?: true
    updatedAt?: true
    creatorId?: true
    reputationScore?: true
    status?: true
    marketCap?: true
    _all?: true
  }

  export type CoinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coin to aggregate.
     */
    where?: CoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coins to fetch.
     */
    orderBy?: CoinOrderByWithRelationInput | CoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coins
    **/
    _count?: true | CoinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoinMaxAggregateInputType
  }

  export type GetCoinAggregateType<T extends CoinAggregateArgs> = {
        [P in keyof T & keyof AggregateCoin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoin[P]>
      : GetScalarType<T[P], AggregateCoin[P]>
  }




  export type CoinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinWhereInput
    orderBy?: CoinOrderByWithAggregationInput | CoinOrderByWithAggregationInput[]
    by: CoinScalarFieldEnum[] | CoinScalarFieldEnum
    having?: CoinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoinCountAggregateInputType | true
    _avg?: CoinAvgAggregateInputType
    _sum?: CoinSumAggregateInputType
    _min?: CoinMinAggregateInputType
    _max?: CoinMaxAggregateInputType
  }

  export type CoinGroupByOutputType = {
    id: string
    name: string
    ticker: string
    description: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks: JsonValue | null
    totalSupply: Decimal
    airdropAmount: Decimal
    blockchain: $Enums.Blockchain | null
    createdAt: Date
    updatedAt: Date
    creatorId: string
    reputationScore: number
    status: $Enums.CoinStatus
    marketCap: Decimal
    _count: CoinCountAggregateOutputType | null
    _avg: CoinAvgAggregateOutputType | null
    _sum: CoinSumAggregateOutputType | null
    _min: CoinMinAggregateOutputType | null
    _max: CoinMaxAggregateOutputType | null
  }

  type GetCoinGroupByPayload<T extends CoinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoinGroupByOutputType[P]>
            : GetScalarType<T[P], CoinGroupByOutputType[P]>
        }
      >
    >


  export type CoinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ticker?: boolean
    description?: boolean
    pictureUrl?: boolean
    telegramLink?: boolean
    discordLink?: boolean
    socialLinks?: boolean
    totalSupply?: boolean
    airdropAmount?: boolean
    blockchain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    reputationScore?: boolean
    status?: boolean
    marketCap?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    chatMessages?: boolean | Coin$chatMessagesArgs<ExtArgs>
    comments?: boolean | Coin$commentsArgs<ExtArgs>
    bondingCurve?: boolean | Coin$bondingCurveArgs<ExtArgs>
    votes?: boolean | Coin$votesArgs<ExtArgs>
    tokenHoldings?: boolean | Coin$tokenHoldingsArgs<ExtArgs>
    milestones?: boolean | Coin$milestonesArgs<ExtArgs>
    hashtags?: boolean | Coin$hashtagsArgs<ExtArgs>
    priceHistory?: boolean | Coin$priceHistoryArgs<ExtArgs>
    transaction?: boolean | Coin$transactionArgs<ExtArgs>
    proposals?: boolean | Coin$proposalsArgs<ExtArgs>
    _count?: boolean | CoinCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coin"]>

  export type CoinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ticker?: boolean
    description?: boolean
    pictureUrl?: boolean
    telegramLink?: boolean
    discordLink?: boolean
    socialLinks?: boolean
    totalSupply?: boolean
    airdropAmount?: boolean
    blockchain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    reputationScore?: boolean
    status?: boolean
    marketCap?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coin"]>

  export type CoinSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ticker?: boolean
    description?: boolean
    pictureUrl?: boolean
    telegramLink?: boolean
    discordLink?: boolean
    socialLinks?: boolean
    totalSupply?: boolean
    airdropAmount?: boolean
    blockchain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    reputationScore?: boolean
    status?: boolean
    marketCap?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coin"]>

  export type CoinSelectScalar = {
    id?: boolean
    name?: boolean
    ticker?: boolean
    description?: boolean
    pictureUrl?: boolean
    telegramLink?: boolean
    discordLink?: boolean
    socialLinks?: boolean
    totalSupply?: boolean
    airdropAmount?: boolean
    blockchain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creatorId?: boolean
    reputationScore?: boolean
    status?: boolean
    marketCap?: boolean
  }

  export type CoinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "ticker" | "description" | "pictureUrl" | "telegramLink" | "discordLink" | "socialLinks" | "totalSupply" | "airdropAmount" | "blockchain" | "createdAt" | "updatedAt" | "creatorId" | "reputationScore" | "status" | "marketCap", ExtArgs["result"]["coin"]>
  export type CoinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    chatMessages?: boolean | Coin$chatMessagesArgs<ExtArgs>
    comments?: boolean | Coin$commentsArgs<ExtArgs>
    bondingCurve?: boolean | Coin$bondingCurveArgs<ExtArgs>
    votes?: boolean | Coin$votesArgs<ExtArgs>
    tokenHoldings?: boolean | Coin$tokenHoldingsArgs<ExtArgs>
    milestones?: boolean | Coin$milestonesArgs<ExtArgs>
    hashtags?: boolean | Coin$hashtagsArgs<ExtArgs>
    priceHistory?: boolean | Coin$priceHistoryArgs<ExtArgs>
    transaction?: boolean | Coin$transactionArgs<ExtArgs>
    proposals?: boolean | Coin$proposalsArgs<ExtArgs>
    _count?: boolean | CoinCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CoinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CoinIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coin"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      chatMessages: Prisma.$ChatMessagePayload<ExtArgs>[]
      comments: Prisma.$CommentsPayload<ExtArgs>[]
      bondingCurve: Prisma.$BondingCurvePayload<ExtArgs> | null
      votes: Prisma.$VotePayload<ExtArgs>[]
      tokenHoldings: Prisma.$TokenHoldingPayload<ExtArgs>[]
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      hashtags: Prisma.$HashtagPayload<ExtArgs>[]
      priceHistory: Prisma.$PriceHistoryPayload<ExtArgs>[]
      transaction: Prisma.$TransactionPayload<ExtArgs>[]
      proposals: Prisma.$ProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ticker: string
      description: string | null
      pictureUrl: string
      telegramLink: string
      discordLink: string
      socialLinks: Prisma.JsonValue | null
      totalSupply: Prisma.Decimal
      airdropAmount: Prisma.Decimal
      blockchain: $Enums.Blockchain | null
      createdAt: Date
      updatedAt: Date
      creatorId: string
      reputationScore: number
      status: $Enums.CoinStatus
      marketCap: Prisma.Decimal
    }, ExtArgs["result"]["coin"]>
    composites: {}
  }

  type CoinGetPayload<S extends boolean | null | undefined | CoinDefaultArgs> = $Result.GetResult<Prisma.$CoinPayload, S>

  type CoinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoinCountAggregateInputType | true
    }

  export interface CoinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coin'], meta: { name: 'Coin' } }
    /**
     * Find zero or one Coin that matches the filter.
     * @param {CoinFindUniqueArgs} args - Arguments to find a Coin
     * @example
     * // Get one Coin
     * const coin = await prisma.coin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoinFindUniqueArgs>(args: SelectSubset<T, CoinFindUniqueArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoinFindUniqueOrThrowArgs} args - Arguments to find a Coin
     * @example
     * // Get one Coin
     * const coin = await prisma.coin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoinFindUniqueOrThrowArgs>(args: SelectSubset<T, CoinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinFindFirstArgs} args - Arguments to find a Coin
     * @example
     * // Get one Coin
     * const coin = await prisma.coin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoinFindFirstArgs>(args?: SelectSubset<T, CoinFindFirstArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinFindFirstOrThrowArgs} args - Arguments to find a Coin
     * @example
     * // Get one Coin
     * const coin = await prisma.coin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoinFindFirstOrThrowArgs>(args?: SelectSubset<T, CoinFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coins
     * const coins = await prisma.coin.findMany()
     * 
     * // Get first 10 Coins
     * const coins = await prisma.coin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coinWithIdOnly = await prisma.coin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoinFindManyArgs>(args?: SelectSubset<T, CoinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coin.
     * @param {CoinCreateArgs} args - Arguments to create a Coin.
     * @example
     * // Create one Coin
     * const Coin = await prisma.coin.create({
     *   data: {
     *     // ... data to create a Coin
     *   }
     * })
     * 
     */
    create<T extends CoinCreateArgs>(args: SelectSubset<T, CoinCreateArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coins.
     * @param {CoinCreateManyArgs} args - Arguments to create many Coins.
     * @example
     * // Create many Coins
     * const coin = await prisma.coin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoinCreateManyArgs>(args?: SelectSubset<T, CoinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coins and returns the data saved in the database.
     * @param {CoinCreateManyAndReturnArgs} args - Arguments to create many Coins.
     * @example
     * // Create many Coins
     * const coin = await prisma.coin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coins and only return the `id`
     * const coinWithIdOnly = await prisma.coin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoinCreateManyAndReturnArgs>(args?: SelectSubset<T, CoinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coin.
     * @param {CoinDeleteArgs} args - Arguments to delete one Coin.
     * @example
     * // Delete one Coin
     * const Coin = await prisma.coin.delete({
     *   where: {
     *     // ... filter to delete one Coin
     *   }
     * })
     * 
     */
    delete<T extends CoinDeleteArgs>(args: SelectSubset<T, CoinDeleteArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coin.
     * @param {CoinUpdateArgs} args - Arguments to update one Coin.
     * @example
     * // Update one Coin
     * const coin = await prisma.coin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoinUpdateArgs>(args: SelectSubset<T, CoinUpdateArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coins.
     * @param {CoinDeleteManyArgs} args - Arguments to filter Coins to delete.
     * @example
     * // Delete a few Coins
     * const { count } = await prisma.coin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoinDeleteManyArgs>(args?: SelectSubset<T, CoinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coins
     * const coin = await prisma.coin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoinUpdateManyArgs>(args: SelectSubset<T, CoinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coins and returns the data updated in the database.
     * @param {CoinUpdateManyAndReturnArgs} args - Arguments to update many Coins.
     * @example
     * // Update many Coins
     * const coin = await prisma.coin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coins and only return the `id`
     * const coinWithIdOnly = await prisma.coin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoinUpdateManyAndReturnArgs>(args: SelectSubset<T, CoinUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coin.
     * @param {CoinUpsertArgs} args - Arguments to update or create a Coin.
     * @example
     * // Update or create a Coin
     * const coin = await prisma.coin.upsert({
     *   create: {
     *     // ... data to create a Coin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coin we want to update
     *   }
     * })
     */
    upsert<T extends CoinUpsertArgs>(args: SelectSubset<T, CoinUpsertArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinCountArgs} args - Arguments to filter Coins to count.
     * @example
     * // Count the number of Coins
     * const count = await prisma.coin.count({
     *   where: {
     *     // ... the filter for the Coins we want to count
     *   }
     * })
    **/
    count<T extends CoinCountArgs>(
      args?: Subset<T, CoinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoinAggregateArgs>(args: Subset<T, CoinAggregateArgs>): Prisma.PrismaPromise<GetCoinAggregateType<T>>

    /**
     * Group by Coin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoinGroupByArgs['orderBy'] }
        : { orderBy?: CoinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coin model
   */
  readonly fields: CoinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chatMessages<T extends Coin$chatMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Coin$chatMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Coin$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Coin$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bondingCurve<T extends Coin$bondingCurveArgs<ExtArgs> = {}>(args?: Subset<T, Coin$bondingCurveArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    votes<T extends Coin$votesArgs<ExtArgs> = {}>(args?: Subset<T, Coin$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokenHoldings<T extends Coin$tokenHoldingsArgs<ExtArgs> = {}>(args?: Subset<T, Coin$tokenHoldingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    milestones<T extends Coin$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Coin$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hashtags<T extends Coin$hashtagsArgs<ExtArgs> = {}>(args?: Subset<T, Coin$hashtagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    priceHistory<T extends Coin$priceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Coin$priceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaction<T extends Coin$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Coin$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposals<T extends Coin$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Coin$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coin model
   */
  interface CoinFieldRefs {
    readonly id: FieldRef<"Coin", 'String'>
    readonly name: FieldRef<"Coin", 'String'>
    readonly ticker: FieldRef<"Coin", 'String'>
    readonly description: FieldRef<"Coin", 'String'>
    readonly pictureUrl: FieldRef<"Coin", 'String'>
    readonly telegramLink: FieldRef<"Coin", 'String'>
    readonly discordLink: FieldRef<"Coin", 'String'>
    readonly socialLinks: FieldRef<"Coin", 'Json'>
    readonly totalSupply: FieldRef<"Coin", 'Decimal'>
    readonly airdropAmount: FieldRef<"Coin", 'Decimal'>
    readonly blockchain: FieldRef<"Coin", 'Blockchain'>
    readonly createdAt: FieldRef<"Coin", 'DateTime'>
    readonly updatedAt: FieldRef<"Coin", 'DateTime'>
    readonly creatorId: FieldRef<"Coin", 'String'>
    readonly reputationScore: FieldRef<"Coin", 'Int'>
    readonly status: FieldRef<"Coin", 'CoinStatus'>
    readonly marketCap: FieldRef<"Coin", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Coin findUnique
   */
  export type CoinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * Filter, which Coin to fetch.
     */
    where: CoinWhereUniqueInput
  }

  /**
   * Coin findUniqueOrThrow
   */
  export type CoinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * Filter, which Coin to fetch.
     */
    where: CoinWhereUniqueInput
  }

  /**
   * Coin findFirst
   */
  export type CoinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * Filter, which Coin to fetch.
     */
    where?: CoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coins to fetch.
     */
    orderBy?: CoinOrderByWithRelationInput | CoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coins.
     */
    cursor?: CoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coins.
     */
    distinct?: CoinScalarFieldEnum | CoinScalarFieldEnum[]
  }

  /**
   * Coin findFirstOrThrow
   */
  export type CoinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * Filter, which Coin to fetch.
     */
    where?: CoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coins to fetch.
     */
    orderBy?: CoinOrderByWithRelationInput | CoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coins.
     */
    cursor?: CoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coins.
     */
    distinct?: CoinScalarFieldEnum | CoinScalarFieldEnum[]
  }

  /**
   * Coin findMany
   */
  export type CoinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * Filter, which Coins to fetch.
     */
    where?: CoinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coins to fetch.
     */
    orderBy?: CoinOrderByWithRelationInput | CoinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coins.
     */
    cursor?: CoinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coins.
     */
    skip?: number
    distinct?: CoinScalarFieldEnum | CoinScalarFieldEnum[]
  }

  /**
   * Coin create
   */
  export type CoinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * The data needed to create a Coin.
     */
    data: XOR<CoinCreateInput, CoinUncheckedCreateInput>
  }

  /**
   * Coin createMany
   */
  export type CoinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coins.
     */
    data: CoinCreateManyInput | CoinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coin createManyAndReturn
   */
  export type CoinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * The data used to create many Coins.
     */
    data: CoinCreateManyInput | CoinCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coin update
   */
  export type CoinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * The data needed to update a Coin.
     */
    data: XOR<CoinUpdateInput, CoinUncheckedUpdateInput>
    /**
     * Choose, which Coin to update.
     */
    where: CoinWhereUniqueInput
  }

  /**
   * Coin updateMany
   */
  export type CoinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coins.
     */
    data: XOR<CoinUpdateManyMutationInput, CoinUncheckedUpdateManyInput>
    /**
     * Filter which Coins to update
     */
    where?: CoinWhereInput
    /**
     * Limit how many Coins to update.
     */
    limit?: number
  }

  /**
   * Coin updateManyAndReturn
   */
  export type CoinUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * The data used to update Coins.
     */
    data: XOR<CoinUpdateManyMutationInput, CoinUncheckedUpdateManyInput>
    /**
     * Filter which Coins to update
     */
    where?: CoinWhereInput
    /**
     * Limit how many Coins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coin upsert
   */
  export type CoinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * The filter to search for the Coin to update in case it exists.
     */
    where: CoinWhereUniqueInput
    /**
     * In case the Coin found by the `where` argument doesn't exist, create a new Coin with this data.
     */
    create: XOR<CoinCreateInput, CoinUncheckedCreateInput>
    /**
     * In case the Coin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoinUpdateInput, CoinUncheckedUpdateInput>
  }

  /**
   * Coin delete
   */
  export type CoinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    /**
     * Filter which Coin to delete.
     */
    where: CoinWhereUniqueInput
  }

  /**
   * Coin deleteMany
   */
  export type CoinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coins to delete
     */
    where?: CoinWhereInput
    /**
     * Limit how many Coins to delete.
     */
    limit?: number
  }

  /**
   * Coin.chatMessages
   */
  export type Coin$chatMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Coin.comments
   */
  export type Coin$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    cursor?: CommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Coin.bondingCurve
   */
  export type Coin$bondingCurveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    where?: BondingCurveWhereInput
  }

  /**
   * Coin.votes
   */
  export type Coin$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Coin.tokenHoldings
   */
  export type Coin$tokenHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    where?: TokenHoldingWhereInput
    orderBy?: TokenHoldingOrderByWithRelationInput | TokenHoldingOrderByWithRelationInput[]
    cursor?: TokenHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenHoldingScalarFieldEnum | TokenHoldingScalarFieldEnum[]
  }

  /**
   * Coin.milestones
   */
  export type Coin$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Coin.hashtags
   */
  export type Coin$hashtagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    where?: HashtagWhereInput
    orderBy?: HashtagOrderByWithRelationInput | HashtagOrderByWithRelationInput[]
    cursor?: HashtagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HashtagScalarFieldEnum | HashtagScalarFieldEnum[]
  }

  /**
   * Coin.priceHistory
   */
  export type Coin$priceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    cursor?: PriceHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * Coin.transaction
   */
  export type Coin$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Coin.proposals
   */
  export type Coin$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    cursor?: ProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Coin without action
   */
  export type CoinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    coinId: string | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    description: string | null
    coinId: string | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    date: number
    description: number
    coinId: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    date?: true
    description?: true
    coinId?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    date?: true
    description?: true
    coinId?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    date?: true
    description?: true
    coinId?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    date: Date
    description: string
    coinId: string
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    coinId?: boolean
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    coinId?: boolean
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    description?: boolean
    coinId?: boolean
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    date?: boolean
    description?: boolean
    coinId?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "description" | "coinId", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      description: string
      coinId: string
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones and returns the data updated in the database.
     * @param {MilestoneUpdateManyAndReturnArgs} args - Arguments to update many Milestones.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, MilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly date: FieldRef<"Milestone", 'DateTime'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly coinId: FieldRef<"Milestone", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone updateManyAndReturn
   */
  export type MilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Hashtag
   */

  export type AggregateHashtag = {
    _count: HashtagCountAggregateOutputType | null
    _avg: HashtagAvgAggregateOutputType | null
    _sum: HashtagSumAggregateOutputType | null
    _min: HashtagMinAggregateOutputType | null
    _max: HashtagMaxAggregateOutputType | null
  }

  export type HashtagAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type HashtagSumAggregateOutputType = {
    usageCount: number | null
  }

  export type HashtagMinAggregateOutputType = {
    id: string | null
    tag: string | null
    usageCount: number | null
  }

  export type HashtagMaxAggregateOutputType = {
    id: string | null
    tag: string | null
    usageCount: number | null
  }

  export type HashtagCountAggregateOutputType = {
    id: number
    tag: number
    usageCount: number
    _all: number
  }


  export type HashtagAvgAggregateInputType = {
    usageCount?: true
  }

  export type HashtagSumAggregateInputType = {
    usageCount?: true
  }

  export type HashtagMinAggregateInputType = {
    id?: true
    tag?: true
    usageCount?: true
  }

  export type HashtagMaxAggregateInputType = {
    id?: true
    tag?: true
    usageCount?: true
  }

  export type HashtagCountAggregateInputType = {
    id?: true
    tag?: true
    usageCount?: true
    _all?: true
  }

  export type HashtagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hashtag to aggregate.
     */
    where?: HashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hashtags to fetch.
     */
    orderBy?: HashtagOrderByWithRelationInput | HashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hashtags
    **/
    _count?: true | HashtagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HashtagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HashtagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HashtagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HashtagMaxAggregateInputType
  }

  export type GetHashtagAggregateType<T extends HashtagAggregateArgs> = {
        [P in keyof T & keyof AggregateHashtag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHashtag[P]>
      : GetScalarType<T[P], AggregateHashtag[P]>
  }




  export type HashtagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HashtagWhereInput
    orderBy?: HashtagOrderByWithAggregationInput | HashtagOrderByWithAggregationInput[]
    by: HashtagScalarFieldEnum[] | HashtagScalarFieldEnum
    having?: HashtagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HashtagCountAggregateInputType | true
    _avg?: HashtagAvgAggregateInputType
    _sum?: HashtagSumAggregateInputType
    _min?: HashtagMinAggregateInputType
    _max?: HashtagMaxAggregateInputType
  }

  export type HashtagGroupByOutputType = {
    id: string
    tag: string
    usageCount: number
    _count: HashtagCountAggregateOutputType | null
    _avg: HashtagAvgAggregateOutputType | null
    _sum: HashtagSumAggregateOutputType | null
    _min: HashtagMinAggregateOutputType | null
    _max: HashtagMaxAggregateOutputType | null
  }

  type GetHashtagGroupByPayload<T extends HashtagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HashtagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HashtagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HashtagGroupByOutputType[P]>
            : GetScalarType<T[P], HashtagGroupByOutputType[P]>
        }
      >
    >


  export type HashtagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    usageCount?: boolean
    coins?: boolean | Hashtag$coinsArgs<ExtArgs>
    _count?: boolean | HashtagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hashtag"]>

  export type HashtagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    usageCount?: boolean
  }, ExtArgs["result"]["hashtag"]>

  export type HashtagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tag?: boolean
    usageCount?: boolean
  }, ExtArgs["result"]["hashtag"]>

  export type HashtagSelectScalar = {
    id?: boolean
    tag?: boolean
    usageCount?: boolean
  }

  export type HashtagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tag" | "usageCount", ExtArgs["result"]["hashtag"]>
  export type HashtagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coins?: boolean | Hashtag$coinsArgs<ExtArgs>
    _count?: boolean | HashtagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HashtagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type HashtagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HashtagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hashtag"
    objects: {
      coins: Prisma.$CoinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tag: string
      usageCount: number
    }, ExtArgs["result"]["hashtag"]>
    composites: {}
  }

  type HashtagGetPayload<S extends boolean | null | undefined | HashtagDefaultArgs> = $Result.GetResult<Prisma.$HashtagPayload, S>

  type HashtagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HashtagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HashtagCountAggregateInputType | true
    }

  export interface HashtagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hashtag'], meta: { name: 'Hashtag' } }
    /**
     * Find zero or one Hashtag that matches the filter.
     * @param {HashtagFindUniqueArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HashtagFindUniqueArgs>(args: SelectSubset<T, HashtagFindUniqueArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hashtag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HashtagFindUniqueOrThrowArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HashtagFindUniqueOrThrowArgs>(args: SelectSubset<T, HashtagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hashtag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagFindFirstArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HashtagFindFirstArgs>(args?: SelectSubset<T, HashtagFindFirstArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hashtag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagFindFirstOrThrowArgs} args - Arguments to find a Hashtag
     * @example
     * // Get one Hashtag
     * const hashtag = await prisma.hashtag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HashtagFindFirstOrThrowArgs>(args?: SelectSubset<T, HashtagFindFirstOrThrowArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hashtags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hashtags
     * const hashtags = await prisma.hashtag.findMany()
     * 
     * // Get first 10 Hashtags
     * const hashtags = await prisma.hashtag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hashtagWithIdOnly = await prisma.hashtag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HashtagFindManyArgs>(args?: SelectSubset<T, HashtagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hashtag.
     * @param {HashtagCreateArgs} args - Arguments to create a Hashtag.
     * @example
     * // Create one Hashtag
     * const Hashtag = await prisma.hashtag.create({
     *   data: {
     *     // ... data to create a Hashtag
     *   }
     * })
     * 
     */
    create<T extends HashtagCreateArgs>(args: SelectSubset<T, HashtagCreateArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hashtags.
     * @param {HashtagCreateManyArgs} args - Arguments to create many Hashtags.
     * @example
     * // Create many Hashtags
     * const hashtag = await prisma.hashtag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HashtagCreateManyArgs>(args?: SelectSubset<T, HashtagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hashtags and returns the data saved in the database.
     * @param {HashtagCreateManyAndReturnArgs} args - Arguments to create many Hashtags.
     * @example
     * // Create many Hashtags
     * const hashtag = await prisma.hashtag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hashtags and only return the `id`
     * const hashtagWithIdOnly = await prisma.hashtag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HashtagCreateManyAndReturnArgs>(args?: SelectSubset<T, HashtagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Hashtag.
     * @param {HashtagDeleteArgs} args - Arguments to delete one Hashtag.
     * @example
     * // Delete one Hashtag
     * const Hashtag = await prisma.hashtag.delete({
     *   where: {
     *     // ... filter to delete one Hashtag
     *   }
     * })
     * 
     */
    delete<T extends HashtagDeleteArgs>(args: SelectSubset<T, HashtagDeleteArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hashtag.
     * @param {HashtagUpdateArgs} args - Arguments to update one Hashtag.
     * @example
     * // Update one Hashtag
     * const hashtag = await prisma.hashtag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HashtagUpdateArgs>(args: SelectSubset<T, HashtagUpdateArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hashtags.
     * @param {HashtagDeleteManyArgs} args - Arguments to filter Hashtags to delete.
     * @example
     * // Delete a few Hashtags
     * const { count } = await prisma.hashtag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HashtagDeleteManyArgs>(args?: SelectSubset<T, HashtagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hashtags
     * const hashtag = await prisma.hashtag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HashtagUpdateManyArgs>(args: SelectSubset<T, HashtagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hashtags and returns the data updated in the database.
     * @param {HashtagUpdateManyAndReturnArgs} args - Arguments to update many Hashtags.
     * @example
     * // Update many Hashtags
     * const hashtag = await prisma.hashtag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Hashtags and only return the `id`
     * const hashtagWithIdOnly = await prisma.hashtag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HashtagUpdateManyAndReturnArgs>(args: SelectSubset<T, HashtagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Hashtag.
     * @param {HashtagUpsertArgs} args - Arguments to update or create a Hashtag.
     * @example
     * // Update or create a Hashtag
     * const hashtag = await prisma.hashtag.upsert({
     *   create: {
     *     // ... data to create a Hashtag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hashtag we want to update
     *   }
     * })
     */
    upsert<T extends HashtagUpsertArgs>(args: SelectSubset<T, HashtagUpsertArgs<ExtArgs>>): Prisma__HashtagClient<$Result.GetResult<Prisma.$HashtagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hashtags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagCountArgs} args - Arguments to filter Hashtags to count.
     * @example
     * // Count the number of Hashtags
     * const count = await prisma.hashtag.count({
     *   where: {
     *     // ... the filter for the Hashtags we want to count
     *   }
     * })
    **/
    count<T extends HashtagCountArgs>(
      args?: Subset<T, HashtagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HashtagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HashtagAggregateArgs>(args: Subset<T, HashtagAggregateArgs>): Prisma.PrismaPromise<GetHashtagAggregateType<T>>

    /**
     * Group by Hashtag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HashtagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HashtagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HashtagGroupByArgs['orderBy'] }
        : { orderBy?: HashtagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HashtagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHashtagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hashtag model
   */
  readonly fields: HashtagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hashtag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HashtagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coins<T extends Hashtag$coinsArgs<ExtArgs> = {}>(args?: Subset<T, Hashtag$coinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hashtag model
   */
  interface HashtagFieldRefs {
    readonly id: FieldRef<"Hashtag", 'String'>
    readonly tag: FieldRef<"Hashtag", 'String'>
    readonly usageCount: FieldRef<"Hashtag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Hashtag findUnique
   */
  export type HashtagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * Filter, which Hashtag to fetch.
     */
    where: HashtagWhereUniqueInput
  }

  /**
   * Hashtag findUniqueOrThrow
   */
  export type HashtagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * Filter, which Hashtag to fetch.
     */
    where: HashtagWhereUniqueInput
  }

  /**
   * Hashtag findFirst
   */
  export type HashtagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * Filter, which Hashtag to fetch.
     */
    where?: HashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hashtags to fetch.
     */
    orderBy?: HashtagOrderByWithRelationInput | HashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hashtags.
     */
    cursor?: HashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hashtags.
     */
    distinct?: HashtagScalarFieldEnum | HashtagScalarFieldEnum[]
  }

  /**
   * Hashtag findFirstOrThrow
   */
  export type HashtagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * Filter, which Hashtag to fetch.
     */
    where?: HashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hashtags to fetch.
     */
    orderBy?: HashtagOrderByWithRelationInput | HashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hashtags.
     */
    cursor?: HashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hashtags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hashtags.
     */
    distinct?: HashtagScalarFieldEnum | HashtagScalarFieldEnum[]
  }

  /**
   * Hashtag findMany
   */
  export type HashtagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * Filter, which Hashtags to fetch.
     */
    where?: HashtagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hashtags to fetch.
     */
    orderBy?: HashtagOrderByWithRelationInput | HashtagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hashtags.
     */
    cursor?: HashtagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hashtags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hashtags.
     */
    skip?: number
    distinct?: HashtagScalarFieldEnum | HashtagScalarFieldEnum[]
  }

  /**
   * Hashtag create
   */
  export type HashtagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * The data needed to create a Hashtag.
     */
    data: XOR<HashtagCreateInput, HashtagUncheckedCreateInput>
  }

  /**
   * Hashtag createMany
   */
  export type HashtagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hashtags.
     */
    data: HashtagCreateManyInput | HashtagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hashtag createManyAndReturn
   */
  export type HashtagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * The data used to create many Hashtags.
     */
    data: HashtagCreateManyInput | HashtagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hashtag update
   */
  export type HashtagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * The data needed to update a Hashtag.
     */
    data: XOR<HashtagUpdateInput, HashtagUncheckedUpdateInput>
    /**
     * Choose, which Hashtag to update.
     */
    where: HashtagWhereUniqueInput
  }

  /**
   * Hashtag updateMany
   */
  export type HashtagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hashtags.
     */
    data: XOR<HashtagUpdateManyMutationInput, HashtagUncheckedUpdateManyInput>
    /**
     * Filter which Hashtags to update
     */
    where?: HashtagWhereInput
    /**
     * Limit how many Hashtags to update.
     */
    limit?: number
  }

  /**
   * Hashtag updateManyAndReturn
   */
  export type HashtagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * The data used to update Hashtags.
     */
    data: XOR<HashtagUpdateManyMutationInput, HashtagUncheckedUpdateManyInput>
    /**
     * Filter which Hashtags to update
     */
    where?: HashtagWhereInput
    /**
     * Limit how many Hashtags to update.
     */
    limit?: number
  }

  /**
   * Hashtag upsert
   */
  export type HashtagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * The filter to search for the Hashtag to update in case it exists.
     */
    where: HashtagWhereUniqueInput
    /**
     * In case the Hashtag found by the `where` argument doesn't exist, create a new Hashtag with this data.
     */
    create: XOR<HashtagCreateInput, HashtagUncheckedCreateInput>
    /**
     * In case the Hashtag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HashtagUpdateInput, HashtagUncheckedUpdateInput>
  }

  /**
   * Hashtag delete
   */
  export type HashtagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
    /**
     * Filter which Hashtag to delete.
     */
    where: HashtagWhereUniqueInput
  }

  /**
   * Hashtag deleteMany
   */
  export type HashtagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hashtags to delete
     */
    where?: HashtagWhereInput
    /**
     * Limit how many Hashtags to delete.
     */
    limit?: number
  }

  /**
   * Hashtag.coins
   */
  export type Hashtag$coinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coin
     */
    select?: CoinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coin
     */
    omit?: CoinOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinInclude<ExtArgs> | null
    where?: CoinWhereInput
    orderBy?: CoinOrderByWithRelationInput | CoinOrderByWithRelationInput[]
    cursor?: CoinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoinScalarFieldEnum | CoinScalarFieldEnum[]
  }

  /**
   * Hashtag without action
   */
  export type HashtagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hashtag
     */
    select?: HashtagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Hashtag
     */
    omit?: HashtagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HashtagInclude<ExtArgs> | null
  }


  /**
   * Model BondingCurve
   */

  export type AggregateBondingCurve = {
    _count: BondingCurveCountAggregateOutputType | null
    _min: BondingCurveMinAggregateOutputType | null
    _max: BondingCurveMaxAggregateOutputType | null
  }

  export type BondingCurveMinAggregateOutputType = {
    id: string | null
    coinId: string | null
    feeStructureId: string | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BondingCurveMaxAggregateOutputType = {
    id: string | null
    coinId: string | null
    feeStructureId: string | null
    isCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BondingCurveCountAggregateOutputType = {
    id: number
    coinId: number
    curveDetail: number
    feeStructureId: number
    isCompleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BondingCurveMinAggregateInputType = {
    id?: true
    coinId?: true
    feeStructureId?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BondingCurveMaxAggregateInputType = {
    id?: true
    coinId?: true
    feeStructureId?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BondingCurveCountAggregateInputType = {
    id?: true
    coinId?: true
    curveDetail?: true
    feeStructureId?: true
    isCompleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BondingCurveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BondingCurve to aggregate.
     */
    where?: BondingCurveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BondingCurves to fetch.
     */
    orderBy?: BondingCurveOrderByWithRelationInput | BondingCurveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BondingCurveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BondingCurves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BondingCurves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BondingCurves
    **/
    _count?: true | BondingCurveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BondingCurveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BondingCurveMaxAggregateInputType
  }

  export type GetBondingCurveAggregateType<T extends BondingCurveAggregateArgs> = {
        [P in keyof T & keyof AggregateBondingCurve]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBondingCurve[P]>
      : GetScalarType<T[P], AggregateBondingCurve[P]>
  }




  export type BondingCurveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BondingCurveWhereInput
    orderBy?: BondingCurveOrderByWithAggregationInput | BondingCurveOrderByWithAggregationInput[]
    by: BondingCurveScalarFieldEnum[] | BondingCurveScalarFieldEnum
    having?: BondingCurveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BondingCurveCountAggregateInputType | true
    _min?: BondingCurveMinAggregateInputType
    _max?: BondingCurveMaxAggregateInputType
  }

  export type BondingCurveGroupByOutputType = {
    id: string
    coinId: string
    curveDetail: JsonValue
    feeStructureId: string | null
    isCompleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: BondingCurveCountAggregateOutputType | null
    _min: BondingCurveMinAggregateOutputType | null
    _max: BondingCurveMaxAggregateOutputType | null
  }

  type GetBondingCurveGroupByPayload<T extends BondingCurveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BondingCurveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BondingCurveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BondingCurveGroupByOutputType[P]>
            : GetScalarType<T[P], BondingCurveGroupByOutputType[P]>
        }
      >
    >


  export type BondingCurveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coinId?: boolean
    curveDetail?: boolean
    feeStructureId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feeStructure?: boolean | BondingCurve$feeStructureArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bondingCurve"]>

  export type BondingCurveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coinId?: boolean
    curveDetail?: boolean
    feeStructureId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feeStructure?: boolean | BondingCurve$feeStructureArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bondingCurve"]>

  export type BondingCurveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coinId?: boolean
    curveDetail?: boolean
    feeStructureId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    feeStructure?: boolean | BondingCurve$feeStructureArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bondingCurve"]>

  export type BondingCurveSelectScalar = {
    id?: boolean
    coinId?: boolean
    curveDetail?: boolean
    feeStructureId?: boolean
    isCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BondingCurveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "coinId" | "curveDetail" | "feeStructureId" | "isCompleted" | "createdAt" | "updatedAt", ExtArgs["result"]["bondingCurve"]>
  export type BondingCurveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeStructure?: boolean | BondingCurve$feeStructureArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type BondingCurveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeStructure?: boolean | BondingCurve$feeStructureArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type BondingCurveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feeStructure?: boolean | BondingCurve$feeStructureArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $BondingCurvePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BondingCurve"
    objects: {
      feeStructure: Prisma.$FeeStructurePayload<ExtArgs> | null
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coinId: string
      curveDetail: Prisma.JsonValue
      feeStructureId: string | null
      isCompleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bondingCurve"]>
    composites: {}
  }

  type BondingCurveGetPayload<S extends boolean | null | undefined | BondingCurveDefaultArgs> = $Result.GetResult<Prisma.$BondingCurvePayload, S>

  type BondingCurveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BondingCurveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BondingCurveCountAggregateInputType | true
    }

  export interface BondingCurveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BondingCurve'], meta: { name: 'BondingCurve' } }
    /**
     * Find zero or one BondingCurve that matches the filter.
     * @param {BondingCurveFindUniqueArgs} args - Arguments to find a BondingCurve
     * @example
     * // Get one BondingCurve
     * const bondingCurve = await prisma.bondingCurve.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BondingCurveFindUniqueArgs>(args: SelectSubset<T, BondingCurveFindUniqueArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BondingCurve that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BondingCurveFindUniqueOrThrowArgs} args - Arguments to find a BondingCurve
     * @example
     * // Get one BondingCurve
     * const bondingCurve = await prisma.bondingCurve.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BondingCurveFindUniqueOrThrowArgs>(args: SelectSubset<T, BondingCurveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BondingCurve that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BondingCurveFindFirstArgs} args - Arguments to find a BondingCurve
     * @example
     * // Get one BondingCurve
     * const bondingCurve = await prisma.bondingCurve.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BondingCurveFindFirstArgs>(args?: SelectSubset<T, BondingCurveFindFirstArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BondingCurve that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BondingCurveFindFirstOrThrowArgs} args - Arguments to find a BondingCurve
     * @example
     * // Get one BondingCurve
     * const bondingCurve = await prisma.bondingCurve.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BondingCurveFindFirstOrThrowArgs>(args?: SelectSubset<T, BondingCurveFindFirstOrThrowArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BondingCurves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BondingCurveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BondingCurves
     * const bondingCurves = await prisma.bondingCurve.findMany()
     * 
     * // Get first 10 BondingCurves
     * const bondingCurves = await prisma.bondingCurve.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bondingCurveWithIdOnly = await prisma.bondingCurve.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BondingCurveFindManyArgs>(args?: SelectSubset<T, BondingCurveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BondingCurve.
     * @param {BondingCurveCreateArgs} args - Arguments to create a BondingCurve.
     * @example
     * // Create one BondingCurve
     * const BondingCurve = await prisma.bondingCurve.create({
     *   data: {
     *     // ... data to create a BondingCurve
     *   }
     * })
     * 
     */
    create<T extends BondingCurveCreateArgs>(args: SelectSubset<T, BondingCurveCreateArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BondingCurves.
     * @param {BondingCurveCreateManyArgs} args - Arguments to create many BondingCurves.
     * @example
     * // Create many BondingCurves
     * const bondingCurve = await prisma.bondingCurve.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BondingCurveCreateManyArgs>(args?: SelectSubset<T, BondingCurveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BondingCurves and returns the data saved in the database.
     * @param {BondingCurveCreateManyAndReturnArgs} args - Arguments to create many BondingCurves.
     * @example
     * // Create many BondingCurves
     * const bondingCurve = await prisma.bondingCurve.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BondingCurves and only return the `id`
     * const bondingCurveWithIdOnly = await prisma.bondingCurve.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BondingCurveCreateManyAndReturnArgs>(args?: SelectSubset<T, BondingCurveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BondingCurve.
     * @param {BondingCurveDeleteArgs} args - Arguments to delete one BondingCurve.
     * @example
     * // Delete one BondingCurve
     * const BondingCurve = await prisma.bondingCurve.delete({
     *   where: {
     *     // ... filter to delete one BondingCurve
     *   }
     * })
     * 
     */
    delete<T extends BondingCurveDeleteArgs>(args: SelectSubset<T, BondingCurveDeleteArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BondingCurve.
     * @param {BondingCurveUpdateArgs} args - Arguments to update one BondingCurve.
     * @example
     * // Update one BondingCurve
     * const bondingCurve = await prisma.bondingCurve.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BondingCurveUpdateArgs>(args: SelectSubset<T, BondingCurveUpdateArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BondingCurves.
     * @param {BondingCurveDeleteManyArgs} args - Arguments to filter BondingCurves to delete.
     * @example
     * // Delete a few BondingCurves
     * const { count } = await prisma.bondingCurve.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BondingCurveDeleteManyArgs>(args?: SelectSubset<T, BondingCurveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BondingCurves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BondingCurveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BondingCurves
     * const bondingCurve = await prisma.bondingCurve.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BondingCurveUpdateManyArgs>(args: SelectSubset<T, BondingCurveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BondingCurves and returns the data updated in the database.
     * @param {BondingCurveUpdateManyAndReturnArgs} args - Arguments to update many BondingCurves.
     * @example
     * // Update many BondingCurves
     * const bondingCurve = await prisma.bondingCurve.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BondingCurves and only return the `id`
     * const bondingCurveWithIdOnly = await prisma.bondingCurve.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BondingCurveUpdateManyAndReturnArgs>(args: SelectSubset<T, BondingCurveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BondingCurve.
     * @param {BondingCurveUpsertArgs} args - Arguments to update or create a BondingCurve.
     * @example
     * // Update or create a BondingCurve
     * const bondingCurve = await prisma.bondingCurve.upsert({
     *   create: {
     *     // ... data to create a BondingCurve
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BondingCurve we want to update
     *   }
     * })
     */
    upsert<T extends BondingCurveUpsertArgs>(args: SelectSubset<T, BondingCurveUpsertArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BondingCurves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BondingCurveCountArgs} args - Arguments to filter BondingCurves to count.
     * @example
     * // Count the number of BondingCurves
     * const count = await prisma.bondingCurve.count({
     *   where: {
     *     // ... the filter for the BondingCurves we want to count
     *   }
     * })
    **/
    count<T extends BondingCurveCountArgs>(
      args?: Subset<T, BondingCurveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BondingCurveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BondingCurve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BondingCurveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BondingCurveAggregateArgs>(args: Subset<T, BondingCurveAggregateArgs>): Prisma.PrismaPromise<GetBondingCurveAggregateType<T>>

    /**
     * Group by BondingCurve.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BondingCurveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BondingCurveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BondingCurveGroupByArgs['orderBy'] }
        : { orderBy?: BondingCurveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BondingCurveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBondingCurveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BondingCurve model
   */
  readonly fields: BondingCurveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BondingCurve.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BondingCurveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feeStructure<T extends BondingCurve$feeStructureArgs<ExtArgs> = {}>(args?: Subset<T, BondingCurve$feeStructureArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BondingCurve model
   */
  interface BondingCurveFieldRefs {
    readonly id: FieldRef<"BondingCurve", 'String'>
    readonly coinId: FieldRef<"BondingCurve", 'String'>
    readonly curveDetail: FieldRef<"BondingCurve", 'Json'>
    readonly feeStructureId: FieldRef<"BondingCurve", 'String'>
    readonly isCompleted: FieldRef<"BondingCurve", 'Boolean'>
    readonly createdAt: FieldRef<"BondingCurve", 'DateTime'>
    readonly updatedAt: FieldRef<"BondingCurve", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BondingCurve findUnique
   */
  export type BondingCurveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * Filter, which BondingCurve to fetch.
     */
    where: BondingCurveWhereUniqueInput
  }

  /**
   * BondingCurve findUniqueOrThrow
   */
  export type BondingCurveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * Filter, which BondingCurve to fetch.
     */
    where: BondingCurveWhereUniqueInput
  }

  /**
   * BondingCurve findFirst
   */
  export type BondingCurveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * Filter, which BondingCurve to fetch.
     */
    where?: BondingCurveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BondingCurves to fetch.
     */
    orderBy?: BondingCurveOrderByWithRelationInput | BondingCurveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BondingCurves.
     */
    cursor?: BondingCurveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BondingCurves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BondingCurves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BondingCurves.
     */
    distinct?: BondingCurveScalarFieldEnum | BondingCurveScalarFieldEnum[]
  }

  /**
   * BondingCurve findFirstOrThrow
   */
  export type BondingCurveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * Filter, which BondingCurve to fetch.
     */
    where?: BondingCurveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BondingCurves to fetch.
     */
    orderBy?: BondingCurveOrderByWithRelationInput | BondingCurveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BondingCurves.
     */
    cursor?: BondingCurveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BondingCurves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BondingCurves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BondingCurves.
     */
    distinct?: BondingCurveScalarFieldEnum | BondingCurveScalarFieldEnum[]
  }

  /**
   * BondingCurve findMany
   */
  export type BondingCurveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * Filter, which BondingCurves to fetch.
     */
    where?: BondingCurveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BondingCurves to fetch.
     */
    orderBy?: BondingCurveOrderByWithRelationInput | BondingCurveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BondingCurves.
     */
    cursor?: BondingCurveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BondingCurves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BondingCurves.
     */
    skip?: number
    distinct?: BondingCurveScalarFieldEnum | BondingCurveScalarFieldEnum[]
  }

  /**
   * BondingCurve create
   */
  export type BondingCurveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * The data needed to create a BondingCurve.
     */
    data: XOR<BondingCurveCreateInput, BondingCurveUncheckedCreateInput>
  }

  /**
   * BondingCurve createMany
   */
  export type BondingCurveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BondingCurves.
     */
    data: BondingCurveCreateManyInput | BondingCurveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BondingCurve createManyAndReturn
   */
  export type BondingCurveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * The data used to create many BondingCurves.
     */
    data: BondingCurveCreateManyInput | BondingCurveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BondingCurve update
   */
  export type BondingCurveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * The data needed to update a BondingCurve.
     */
    data: XOR<BondingCurveUpdateInput, BondingCurveUncheckedUpdateInput>
    /**
     * Choose, which BondingCurve to update.
     */
    where: BondingCurveWhereUniqueInput
  }

  /**
   * BondingCurve updateMany
   */
  export type BondingCurveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BondingCurves.
     */
    data: XOR<BondingCurveUpdateManyMutationInput, BondingCurveUncheckedUpdateManyInput>
    /**
     * Filter which BondingCurves to update
     */
    where?: BondingCurveWhereInput
    /**
     * Limit how many BondingCurves to update.
     */
    limit?: number
  }

  /**
   * BondingCurve updateManyAndReturn
   */
  export type BondingCurveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * The data used to update BondingCurves.
     */
    data: XOR<BondingCurveUpdateManyMutationInput, BondingCurveUncheckedUpdateManyInput>
    /**
     * Filter which BondingCurves to update
     */
    where?: BondingCurveWhereInput
    /**
     * Limit how many BondingCurves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BondingCurve upsert
   */
  export type BondingCurveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * The filter to search for the BondingCurve to update in case it exists.
     */
    where: BondingCurveWhereUniqueInput
    /**
     * In case the BondingCurve found by the `where` argument doesn't exist, create a new BondingCurve with this data.
     */
    create: XOR<BondingCurveCreateInput, BondingCurveUncheckedCreateInput>
    /**
     * In case the BondingCurve was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BondingCurveUpdateInput, BondingCurveUncheckedUpdateInput>
  }

  /**
   * BondingCurve delete
   */
  export type BondingCurveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    /**
     * Filter which BondingCurve to delete.
     */
    where: BondingCurveWhereUniqueInput
  }

  /**
   * BondingCurve deleteMany
   */
  export type BondingCurveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BondingCurves to delete
     */
    where?: BondingCurveWhereInput
    /**
     * Limit how many BondingCurves to delete.
     */
    limit?: number
  }

  /**
   * BondingCurve.feeStructure
   */
  export type BondingCurve$feeStructureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    where?: FeeStructureWhereInput
  }

  /**
   * BondingCurve without action
   */
  export type BondingCurveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
  }


  /**
   * Model FeeStructure
   */

  export type AggregateFeeStructure = {
    _count: FeeStructureCountAggregateOutputType | null
    _avg: FeeStructureAvgAggregateOutputType | null
    _sum: FeeStructureSumAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  export type FeeStructureAvgAggregateOutputType = {
    tradeFee: number | null
    memecoinFee: number | null
  }

  export type FeeStructureSumAggregateOutputType = {
    tradeFee: number | null
    memecoinFee: number | null
  }

  export type FeeStructureMinAggregateOutputType = {
    id: string | null
    tradeFee: number | null
    memecoinFee: number | null
    feeDescription: string | null
  }

  export type FeeStructureMaxAggregateOutputType = {
    id: string | null
    tradeFee: number | null
    memecoinFee: number | null
    feeDescription: string | null
  }

  export type FeeStructureCountAggregateOutputType = {
    id: number
    tradeFee: number
    memecoinFee: number
    feeDescription: number
    _all: number
  }


  export type FeeStructureAvgAggregateInputType = {
    tradeFee?: true
    memecoinFee?: true
  }

  export type FeeStructureSumAggregateInputType = {
    tradeFee?: true
    memecoinFee?: true
  }

  export type FeeStructureMinAggregateInputType = {
    id?: true
    tradeFee?: true
    memecoinFee?: true
    feeDescription?: true
  }

  export type FeeStructureMaxAggregateInputType = {
    id?: true
    tradeFee?: true
    memecoinFee?: true
    feeDescription?: true
  }

  export type FeeStructureCountAggregateInputType = {
    id?: true
    tradeFee?: true
    memecoinFee?: true
    feeDescription?: true
    _all?: true
  }

  export type FeeStructureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructure to aggregate.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeStructures
    **/
    _count?: true | FeeStructureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeStructureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeStructureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeStructureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeStructureMaxAggregateInputType
  }

  export type GetFeeStructureAggregateType<T extends FeeStructureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeStructure]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeStructure[P]>
      : GetScalarType<T[P], AggregateFeeStructure[P]>
  }




  export type FeeStructureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeStructureWhereInput
    orderBy?: FeeStructureOrderByWithAggregationInput | FeeStructureOrderByWithAggregationInput[]
    by: FeeStructureScalarFieldEnum[] | FeeStructureScalarFieldEnum
    having?: FeeStructureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeStructureCountAggregateInputType | true
    _avg?: FeeStructureAvgAggregateInputType
    _sum?: FeeStructureSumAggregateInputType
    _min?: FeeStructureMinAggregateInputType
    _max?: FeeStructureMaxAggregateInputType
  }

  export type FeeStructureGroupByOutputType = {
    id: string
    tradeFee: number
    memecoinFee: number
    feeDescription: string
    _count: FeeStructureCountAggregateOutputType | null
    _avg: FeeStructureAvgAggregateOutputType | null
    _sum: FeeStructureSumAggregateOutputType | null
    _min: FeeStructureMinAggregateOutputType | null
    _max: FeeStructureMaxAggregateOutputType | null
  }

  type GetFeeStructureGroupByPayload<T extends FeeStructureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeStructureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeStructureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
            : GetScalarType<T[P], FeeStructureGroupByOutputType[P]>
        }
      >
    >


  export type FeeStructureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeFee?: boolean
    memecoinFee?: boolean
    feeDescription?: boolean
    bondingCurve?: boolean | FeeStructure$bondingCurveArgs<ExtArgs>
  }, ExtArgs["result"]["feeStructure"]>

  export type FeeStructureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeFee?: boolean
    memecoinFee?: boolean
    feeDescription?: boolean
  }, ExtArgs["result"]["feeStructure"]>

  export type FeeStructureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tradeFee?: boolean
    memecoinFee?: boolean
    feeDescription?: boolean
  }, ExtArgs["result"]["feeStructure"]>

  export type FeeStructureSelectScalar = {
    id?: boolean
    tradeFee?: boolean
    memecoinFee?: boolean
    feeDescription?: boolean
  }

  export type FeeStructureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tradeFee" | "memecoinFee" | "feeDescription", ExtArgs["result"]["feeStructure"]>
  export type FeeStructureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bondingCurve?: boolean | FeeStructure$bondingCurveArgs<ExtArgs>
  }
  export type FeeStructureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FeeStructureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FeeStructurePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeStructure"
    objects: {
      bondingCurve: Prisma.$BondingCurvePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tradeFee: number
      memecoinFee: number
      feeDescription: string
    }, ExtArgs["result"]["feeStructure"]>
    composites: {}
  }

  type FeeStructureGetPayload<S extends boolean | null | undefined | FeeStructureDefaultArgs> = $Result.GetResult<Prisma.$FeeStructurePayload, S>

  type FeeStructureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeeStructureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeeStructureCountAggregateInputType | true
    }

  export interface FeeStructureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeStructure'], meta: { name: 'FeeStructure' } }
    /**
     * Find zero or one FeeStructure that matches the filter.
     * @param {FeeStructureFindUniqueArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeStructureFindUniqueArgs>(args: SelectSubset<T, FeeStructureFindUniqueArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FeeStructure that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeeStructureFindUniqueOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeStructureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeStructureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeStructure that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeStructureFindFirstArgs>(args?: SelectSubset<T, FeeStructureFindFirstArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FeeStructure that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindFirstOrThrowArgs} args - Arguments to find a FeeStructure
     * @example
     * // Get one FeeStructure
     * const feeStructure = await prisma.feeStructure.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeStructureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeStructureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FeeStructures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany()
     * 
     * // Get first 10 FeeStructures
     * const feeStructures = await prisma.feeStructure.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeStructureFindManyArgs>(args?: SelectSubset<T, FeeStructureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FeeStructure.
     * @param {FeeStructureCreateArgs} args - Arguments to create a FeeStructure.
     * @example
     * // Create one FeeStructure
     * const FeeStructure = await prisma.feeStructure.create({
     *   data: {
     *     // ... data to create a FeeStructure
     *   }
     * })
     * 
     */
    create<T extends FeeStructureCreateArgs>(args: SelectSubset<T, FeeStructureCreateArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FeeStructures.
     * @param {FeeStructureCreateManyArgs} args - Arguments to create many FeeStructures.
     * @example
     * // Create many FeeStructures
     * const feeStructure = await prisma.feeStructure.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeStructureCreateManyArgs>(args?: SelectSubset<T, FeeStructureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeStructures and returns the data saved in the database.
     * @param {FeeStructureCreateManyAndReturnArgs} args - Arguments to create many FeeStructures.
     * @example
     * // Create many FeeStructures
     * const feeStructure = await prisma.feeStructure.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeStructures and only return the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeStructureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeStructureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FeeStructure.
     * @param {FeeStructureDeleteArgs} args - Arguments to delete one FeeStructure.
     * @example
     * // Delete one FeeStructure
     * const FeeStructure = await prisma.feeStructure.delete({
     *   where: {
     *     // ... filter to delete one FeeStructure
     *   }
     * })
     * 
     */
    delete<T extends FeeStructureDeleteArgs>(args: SelectSubset<T, FeeStructureDeleteArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FeeStructure.
     * @param {FeeStructureUpdateArgs} args - Arguments to update one FeeStructure.
     * @example
     * // Update one FeeStructure
     * const feeStructure = await prisma.feeStructure.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeStructureUpdateArgs>(args: SelectSubset<T, FeeStructureUpdateArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FeeStructures.
     * @param {FeeStructureDeleteManyArgs} args - Arguments to filter FeeStructures to delete.
     * @example
     * // Delete a few FeeStructures
     * const { count } = await prisma.feeStructure.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeStructureDeleteManyArgs>(args?: SelectSubset<T, FeeStructureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeStructures
     * const feeStructure = await prisma.feeStructure.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeStructureUpdateManyArgs>(args: SelectSubset<T, FeeStructureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeStructures and returns the data updated in the database.
     * @param {FeeStructureUpdateManyAndReturnArgs} args - Arguments to update many FeeStructures.
     * @example
     * // Update many FeeStructures
     * const feeStructure = await prisma.feeStructure.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FeeStructures and only return the `id`
     * const feeStructureWithIdOnly = await prisma.feeStructure.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeeStructureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeeStructureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FeeStructure.
     * @param {FeeStructureUpsertArgs} args - Arguments to update or create a FeeStructure.
     * @example
     * // Update or create a FeeStructure
     * const feeStructure = await prisma.feeStructure.upsert({
     *   create: {
     *     // ... data to create a FeeStructure
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeStructure we want to update
     *   }
     * })
     */
    upsert<T extends FeeStructureUpsertArgs>(args: SelectSubset<T, FeeStructureUpsertArgs<ExtArgs>>): Prisma__FeeStructureClient<$Result.GetResult<Prisma.$FeeStructurePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FeeStructures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureCountArgs} args - Arguments to filter FeeStructures to count.
     * @example
     * // Count the number of FeeStructures
     * const count = await prisma.feeStructure.count({
     *   where: {
     *     // ... the filter for the FeeStructures we want to count
     *   }
     * })
    **/
    count<T extends FeeStructureCountArgs>(
      args?: Subset<T, FeeStructureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeStructureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeStructureAggregateArgs>(args: Subset<T, FeeStructureAggregateArgs>): Prisma.PrismaPromise<GetFeeStructureAggregateType<T>>

    /**
     * Group by FeeStructure.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeStructureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeStructureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeStructureGroupByArgs['orderBy'] }
        : { orderBy?: FeeStructureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeStructureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeStructureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeStructure model
   */
  readonly fields: FeeStructureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeStructure.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeStructureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bondingCurve<T extends FeeStructure$bondingCurveArgs<ExtArgs> = {}>(args?: Subset<T, FeeStructure$bondingCurveArgs<ExtArgs>>): Prisma__BondingCurveClient<$Result.GetResult<Prisma.$BondingCurvePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeStructure model
   */
  interface FeeStructureFieldRefs {
    readonly id: FieldRef<"FeeStructure", 'String'>
    readonly tradeFee: FieldRef<"FeeStructure", 'Float'>
    readonly memecoinFee: FieldRef<"FeeStructure", 'Float'>
    readonly feeDescription: FieldRef<"FeeStructure", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FeeStructure findUnique
   */
  export type FeeStructureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure findUniqueOrThrow
   */
  export type FeeStructureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure findFirst
   */
  export type FeeStructureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure findFirstOrThrow
   */
  export type FeeStructureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructure to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeStructures.
     */
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure findMany
   */
  export type FeeStructureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter, which FeeStructures to fetch.
     */
    where?: FeeStructureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeStructures to fetch.
     */
    orderBy?: FeeStructureOrderByWithRelationInput | FeeStructureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeStructures.
     */
    cursor?: FeeStructureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeStructures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeStructures.
     */
    skip?: number
    distinct?: FeeStructureScalarFieldEnum | FeeStructureScalarFieldEnum[]
  }

  /**
   * FeeStructure create
   */
  export type FeeStructureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeStructure.
     */
    data: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
  }

  /**
   * FeeStructure createMany
   */
  export type FeeStructureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeStructures.
     */
    data: FeeStructureCreateManyInput | FeeStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeStructure createManyAndReturn
   */
  export type FeeStructureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * The data used to create many FeeStructures.
     */
    data: FeeStructureCreateManyInput | FeeStructureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeStructure update
   */
  export type FeeStructureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeStructure.
     */
    data: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
    /**
     * Choose, which FeeStructure to update.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure updateMany
   */
  export type FeeStructureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeStructures.
     */
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which FeeStructures to update
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to update.
     */
    limit?: number
  }

  /**
   * FeeStructure updateManyAndReturn
   */
  export type FeeStructureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * The data used to update FeeStructures.
     */
    data: XOR<FeeStructureUpdateManyMutationInput, FeeStructureUncheckedUpdateManyInput>
    /**
     * Filter which FeeStructures to update
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to update.
     */
    limit?: number
  }

  /**
   * FeeStructure upsert
   */
  export type FeeStructureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeStructure to update in case it exists.
     */
    where: FeeStructureWhereUniqueInput
    /**
     * In case the FeeStructure found by the `where` argument doesn't exist, create a new FeeStructure with this data.
     */
    create: XOR<FeeStructureCreateInput, FeeStructureUncheckedCreateInput>
    /**
     * In case the FeeStructure was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeStructureUpdateInput, FeeStructureUncheckedUpdateInput>
  }

  /**
   * FeeStructure delete
   */
  export type FeeStructureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
    /**
     * Filter which FeeStructure to delete.
     */
    where: FeeStructureWhereUniqueInput
  }

  /**
   * FeeStructure deleteMany
   */
  export type FeeStructureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeStructures to delete
     */
    where?: FeeStructureWhereInput
    /**
     * Limit how many FeeStructures to delete.
     */
    limit?: number
  }

  /**
   * FeeStructure.bondingCurve
   */
  export type FeeStructure$bondingCurveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BondingCurve
     */
    select?: BondingCurveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BondingCurve
     */
    omit?: BondingCurveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BondingCurveInclude<ExtArgs> | null
    where?: BondingCurveWhereInput
  }

  /**
   * FeeStructure without action
   */
  export type FeeStructureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeStructure
     */
    select?: FeeStructureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FeeStructure
     */
    omit?: FeeStructureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeStructureInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _avg: VoteAvgAggregateOutputType | null
    _sum: VoteSumAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteAvgAggregateOutputType = {
    value: number | null
  }

  export type VoteSumAggregateOutputType = {
    value: number | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    proposalId: string | null
    value: number | null
    createdAt: Date | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    proposalId: string | null
    value: number | null
    createdAt: Date | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    userId: number
    coinId: number
    proposalId: number
    value: number
    createdAt: number
    _all: number
  }


  export type VoteAvgAggregateInputType = {
    value?: true
  }

  export type VoteSumAggregateInputType = {
    value?: true
  }

  export type VoteMinAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    proposalId?: true
    value?: true
    createdAt?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    proposalId?: true
    value?: true
    createdAt?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    proposalId?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _avg?: VoteAvgAggregateInputType
    _sum?: VoteSumAggregateInputType
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    userId: string
    coinId: string
    proposalId: string | null
    value: number
    createdAt: Date
    _count: VoteCountAggregateOutputType | null
    _avg: VoteAvgAggregateOutputType | null
    _sum: VoteSumAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    proposalId?: boolean
    value?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    proposalId?: boolean
    value?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    proposalId?: boolean
    value?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectScalar = {
    id?: boolean
    userId?: boolean
    coinId?: boolean
    proposalId?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "coinId" | "proposalId" | "value" | "createdAt", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type VoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type VoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coinId: string
      proposalId: string | null
      value: number
      createdAt: Date
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {VoteUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoteUpdateManyAndReturnArgs>(args: SelectSubset<T, VoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly userId: FieldRef<"Vote", 'String'>
    readonly coinId: FieldRef<"Vote", 'String'>
    readonly proposalId: FieldRef<"Vote", 'String'>
    readonly value: FieldRef<"Vote", 'Int'>
    readonly createdAt: FieldRef<"Vote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote updateManyAndReturn
   */
  export type VoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageAvgAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type ChatMessageSumAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    message: string | null
    createdAt: Date | null
    media: string | null
    upvotes: number | null
    downvotes: number | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    message: string | null
    createdAt: Date | null
    media: string | null
    upvotes: number | null
    downvotes: number | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    userId: number
    coinId: number
    message: number
    createdAt: number
    media: number
    upvotes: number
    downvotes: number
    _all: number
  }


  export type ChatMessageAvgAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type ChatMessageSumAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type ChatMessageMinAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    message?: true
    createdAt?: true
    media?: true
    upvotes?: true
    downvotes?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    message?: true
    createdAt?: true
    media?: true
    upvotes?: true
    downvotes?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    message?: true
    createdAt?: true
    media?: true
    upvotes?: true
    downvotes?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _avg?: ChatMessageAvgAggregateInputType
    _sum?: ChatMessageSumAggregateInputType
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    userId: string
    coinId: string
    message: string
    createdAt: Date
    media: string | null
    upvotes: number
    downvotes: number
    _count: ChatMessageCountAggregateOutputType | null
    _avg: ChatMessageAvgAggregateOutputType | null
    _sum: ChatMessageSumAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    media?: boolean
    upvotes?: boolean
    downvotes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    media?: boolean
    upvotes?: boolean
    downvotes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    media?: boolean
    upvotes?: boolean
    downvotes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    media?: boolean
    upvotes?: boolean
    downvotes?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "coinId" | "message" | "createdAt" | "media" | "upvotes" | "downvotes", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coinId: string
      message: string
      createdAt: Date
      media: string | null
      upvotes: number
      downvotes: number
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly userId: FieldRef<"ChatMessage", 'String'>
    readonly coinId: FieldRef<"ChatMessage", 'String'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
    readonly media: FieldRef<"ChatMessage", 'String'>
    readonly upvotes: FieldRef<"ChatMessage", 'Int'>
    readonly downvotes: FieldRef<"ChatMessage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type CommentsSumAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type CommentsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    message: string | null
    createdAt: Date | null
    upvotes: number | null
    downvotes: number | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    message: string | null
    createdAt: Date | null
    upvotes: number | null
    downvotes: number | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    userId: number
    coinId: number
    message: number
    createdAt: number
    upvotes: number
    downvotes: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type CommentsSumAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    message?: true
    createdAt?: true
    upvotes?: true
    downvotes?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    message?: true
    createdAt?: true
    upvotes?: true
    downvotes?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    message?: true
    createdAt?: true
    upvotes?: true
    downvotes?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to aggregate.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type CommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentsWhereInput
    orderBy?: CommentsOrderByWithAggregationInput | CommentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: CommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: string
    userId: string
    coinId: string
    message: string
    createdAt: Date
    upvotes: number
    downvotes: number
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends CommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type CommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    upvotes?: boolean
    downvotes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    upvotes?: boolean
    downvotes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    upvotes?: boolean
    downvotes?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type CommentsSelectScalar = {
    id?: boolean
    userId?: boolean
    coinId?: boolean
    message?: boolean
    createdAt?: boolean
    upvotes?: boolean
    downvotes?: boolean
  }

  export type CommentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "coinId" | "message" | "createdAt" | "upvotes" | "downvotes", ExtArgs["result"]["comments"]>
  export type CommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type CommentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type CommentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $CommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comments"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coinId: string
      message: string
      createdAt: Date
      upvotes: number
      downvotes: number
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type CommentsGetPayload<S extends boolean | null | undefined | CommentsDefaultArgs> = $Result.GetResult<Prisma.$CommentsPayload, S>

  type CommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface CommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comments'], meta: { name: 'Comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {CommentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentsFindUniqueArgs>(args: SelectSubset<T, CommentsFindUniqueArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentsFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentsFindFirstArgs>(args?: SelectSubset<T, CommentsFindFirstArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentsFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentsFindManyArgs>(args?: SelectSubset<T, CommentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {CommentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends CommentsCreateArgs>(args: SelectSubset<T, CommentsCreateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentsCreateManyArgs>(args?: SelectSubset<T, CommentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentsCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comments.
     * @param {CommentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends CommentsDeleteArgs>(args: SelectSubset<T, CommentsDeleteArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {CommentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentsUpdateArgs>(args: SelectSubset<T, CommentsUpdateArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentsDeleteManyArgs>(args?: SelectSubset<T, CommentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentsUpdateManyArgs>(args: SelectSubset<T, CommentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentsUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comments.
     * @param {CommentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends CommentsUpsertArgs>(args: SelectSubset<T, CommentsUpsertArgs<ExtArgs>>): Prisma__CommentsClient<$Result.GetResult<Prisma.$CommentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentsCountArgs>(
      args?: Subset<T, CommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentsGroupByArgs['orderBy'] }
        : { orderBy?: CommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comments model
   */
  readonly fields: CommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comments model
   */
  interface CommentsFieldRefs {
    readonly id: FieldRef<"Comments", 'String'>
    readonly userId: FieldRef<"Comments", 'String'>
    readonly coinId: FieldRef<"Comments", 'String'>
    readonly message: FieldRef<"Comments", 'String'>
    readonly createdAt: FieldRef<"Comments", 'DateTime'>
    readonly upvotes: FieldRef<"Comments", 'Int'>
    readonly downvotes: FieldRef<"Comments", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comments findUnique
   */
  export type CommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findUniqueOrThrow
   */
  export type CommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments findFirst
   */
  export type CommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findFirstOrThrow
   */
  export type CommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments findMany
   */
  export type CommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentsOrderByWithRelationInput | CommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * Comments create
   */
  export type CommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Comments.
     */
    data: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
  }

  /**
   * Comments createMany
   */
  export type CommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentsCreateManyInput | CommentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comments createManyAndReturn
   */
  export type CommentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentsCreateManyInput | CommentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comments update
   */
  export type CommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Comments.
     */
    data: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
    /**
     * Choose, which Comments to update.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments updateMany
   */
  export type CommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comments updateManyAndReturn
   */
  export type CommentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comments upsert
   */
  export type CommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Comments to update in case it exists.
     */
    where: CommentsWhereUniqueInput
    /**
     * In case the Comments found by the `where` argument doesn't exist, create a new Comments with this data.
     */
    create: XOR<CommentsCreateInput, CommentsUncheckedCreateInput>
    /**
     * In case the Comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentsUpdateInput, CommentsUncheckedUpdateInput>
  }

  /**
   * Comments delete
   */
  export type CommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
    /**
     * Filter which Comments to delete.
     */
    where: CommentsWhereUniqueInput
  }

  /**
   * Comments deleteMany
   */
  export type CommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentsWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comments without action
   */
  export type CommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comments
     */
    select?: CommentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comments
     */
    omit?: CommentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentsInclude<ExtArgs> | null
  }


  /**
   * Model Reputation
   */

  export type AggregateReputation = {
    _count: ReputationCountAggregateOutputType | null
    _avg: ReputationAvgAggregateOutputType | null
    _sum: ReputationSumAggregateOutputType | null
    _min: ReputationMinAggregateOutputType | null
    _max: ReputationMaxAggregateOutputType | null
  }

  export type ReputationAvgAggregateOutputType = {
    score: number | null
  }

  export type ReputationSumAggregateOutputType = {
    score: number | null
  }

  export type ReputationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
  }

  export type ReputationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    score: number | null
  }

  export type ReputationCountAggregateOutputType = {
    id: number
    userId: number
    score: number
    _all: number
  }


  export type ReputationAvgAggregateInputType = {
    score?: true
  }

  export type ReputationSumAggregateInputType = {
    score?: true
  }

  export type ReputationMinAggregateInputType = {
    id?: true
    userId?: true
    score?: true
  }

  export type ReputationMaxAggregateInputType = {
    id?: true
    userId?: true
    score?: true
  }

  export type ReputationCountAggregateInputType = {
    id?: true
    userId?: true
    score?: true
    _all?: true
  }

  export type ReputationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reputation to aggregate.
     */
    where?: ReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reputations to fetch.
     */
    orderBy?: ReputationOrderByWithRelationInput | ReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reputations
    **/
    _count?: true | ReputationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReputationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReputationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReputationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReputationMaxAggregateInputType
  }

  export type GetReputationAggregateType<T extends ReputationAggregateArgs> = {
        [P in keyof T & keyof AggregateReputation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReputation[P]>
      : GetScalarType<T[P], AggregateReputation[P]>
  }




  export type ReputationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReputationWhereInput
    orderBy?: ReputationOrderByWithAggregationInput | ReputationOrderByWithAggregationInput[]
    by: ReputationScalarFieldEnum[] | ReputationScalarFieldEnum
    having?: ReputationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReputationCountAggregateInputType | true
    _avg?: ReputationAvgAggregateInputType
    _sum?: ReputationSumAggregateInputType
    _min?: ReputationMinAggregateInputType
    _max?: ReputationMaxAggregateInputType
  }

  export type ReputationGroupByOutputType = {
    id: string
    userId: string
    score: number
    _count: ReputationCountAggregateOutputType | null
    _avg: ReputationAvgAggregateOutputType | null
    _sum: ReputationSumAggregateOutputType | null
    _min: ReputationMinAggregateOutputType | null
    _max: ReputationMaxAggregateOutputType | null
  }

  type GetReputationGroupByPayload<T extends ReputationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReputationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReputationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReputationGroupByOutputType[P]>
            : GetScalarType<T[P], ReputationGroupByOutputType[P]>
        }
      >
    >


  export type ReputationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reputation"]>

  export type ReputationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reputation"]>

  export type ReputationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    score?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reputation"]>

  export type ReputationSelectScalar = {
    id?: boolean
    userId?: boolean
    score?: boolean
  }

  export type ReputationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "score", ExtArgs["result"]["reputation"]>
  export type ReputationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReputationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReputationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReputationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reputation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      score: number
    }, ExtArgs["result"]["reputation"]>
    composites: {}
  }

  type ReputationGetPayload<S extends boolean | null | undefined | ReputationDefaultArgs> = $Result.GetResult<Prisma.$ReputationPayload, S>

  type ReputationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReputationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReputationCountAggregateInputType | true
    }

  export interface ReputationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reputation'], meta: { name: 'Reputation' } }
    /**
     * Find zero or one Reputation that matches the filter.
     * @param {ReputationFindUniqueArgs} args - Arguments to find a Reputation
     * @example
     * // Get one Reputation
     * const reputation = await prisma.reputation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReputationFindUniqueArgs>(args: SelectSubset<T, ReputationFindUniqueArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reputation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReputationFindUniqueOrThrowArgs} args - Arguments to find a Reputation
     * @example
     * // Get one Reputation
     * const reputation = await prisma.reputation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReputationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReputationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reputation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReputationFindFirstArgs} args - Arguments to find a Reputation
     * @example
     * // Get one Reputation
     * const reputation = await prisma.reputation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReputationFindFirstArgs>(args?: SelectSubset<T, ReputationFindFirstArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reputation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReputationFindFirstOrThrowArgs} args - Arguments to find a Reputation
     * @example
     * // Get one Reputation
     * const reputation = await prisma.reputation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReputationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReputationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reputations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReputationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reputations
     * const reputations = await prisma.reputation.findMany()
     * 
     * // Get first 10 Reputations
     * const reputations = await prisma.reputation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reputationWithIdOnly = await prisma.reputation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReputationFindManyArgs>(args?: SelectSubset<T, ReputationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reputation.
     * @param {ReputationCreateArgs} args - Arguments to create a Reputation.
     * @example
     * // Create one Reputation
     * const Reputation = await prisma.reputation.create({
     *   data: {
     *     // ... data to create a Reputation
     *   }
     * })
     * 
     */
    create<T extends ReputationCreateArgs>(args: SelectSubset<T, ReputationCreateArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reputations.
     * @param {ReputationCreateManyArgs} args - Arguments to create many Reputations.
     * @example
     * // Create many Reputations
     * const reputation = await prisma.reputation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReputationCreateManyArgs>(args?: SelectSubset<T, ReputationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reputations and returns the data saved in the database.
     * @param {ReputationCreateManyAndReturnArgs} args - Arguments to create many Reputations.
     * @example
     * // Create many Reputations
     * const reputation = await prisma.reputation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reputations and only return the `id`
     * const reputationWithIdOnly = await prisma.reputation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReputationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReputationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reputation.
     * @param {ReputationDeleteArgs} args - Arguments to delete one Reputation.
     * @example
     * // Delete one Reputation
     * const Reputation = await prisma.reputation.delete({
     *   where: {
     *     // ... filter to delete one Reputation
     *   }
     * })
     * 
     */
    delete<T extends ReputationDeleteArgs>(args: SelectSubset<T, ReputationDeleteArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reputation.
     * @param {ReputationUpdateArgs} args - Arguments to update one Reputation.
     * @example
     * // Update one Reputation
     * const reputation = await prisma.reputation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReputationUpdateArgs>(args: SelectSubset<T, ReputationUpdateArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reputations.
     * @param {ReputationDeleteManyArgs} args - Arguments to filter Reputations to delete.
     * @example
     * // Delete a few Reputations
     * const { count } = await prisma.reputation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReputationDeleteManyArgs>(args?: SelectSubset<T, ReputationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reputations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReputationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reputations
     * const reputation = await prisma.reputation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReputationUpdateManyArgs>(args: SelectSubset<T, ReputationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reputations and returns the data updated in the database.
     * @param {ReputationUpdateManyAndReturnArgs} args - Arguments to update many Reputations.
     * @example
     * // Update many Reputations
     * const reputation = await prisma.reputation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reputations and only return the `id`
     * const reputationWithIdOnly = await prisma.reputation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReputationUpdateManyAndReturnArgs>(args: SelectSubset<T, ReputationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reputation.
     * @param {ReputationUpsertArgs} args - Arguments to update or create a Reputation.
     * @example
     * // Update or create a Reputation
     * const reputation = await prisma.reputation.upsert({
     *   create: {
     *     // ... data to create a Reputation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reputation we want to update
     *   }
     * })
     */
    upsert<T extends ReputationUpsertArgs>(args: SelectSubset<T, ReputationUpsertArgs<ExtArgs>>): Prisma__ReputationClient<$Result.GetResult<Prisma.$ReputationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reputations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReputationCountArgs} args - Arguments to filter Reputations to count.
     * @example
     * // Count the number of Reputations
     * const count = await prisma.reputation.count({
     *   where: {
     *     // ... the filter for the Reputations we want to count
     *   }
     * })
    **/
    count<T extends ReputationCountArgs>(
      args?: Subset<T, ReputationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReputationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reputation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReputationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReputationAggregateArgs>(args: Subset<T, ReputationAggregateArgs>): Prisma.PrismaPromise<GetReputationAggregateType<T>>

    /**
     * Group by Reputation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReputationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReputationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReputationGroupByArgs['orderBy'] }
        : { orderBy?: ReputationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReputationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReputationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reputation model
   */
  readonly fields: ReputationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reputation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReputationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reputation model
   */
  interface ReputationFieldRefs {
    readonly id: FieldRef<"Reputation", 'String'>
    readonly userId: FieldRef<"Reputation", 'String'>
    readonly score: FieldRef<"Reputation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Reputation findUnique
   */
  export type ReputationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * Filter, which Reputation to fetch.
     */
    where: ReputationWhereUniqueInput
  }

  /**
   * Reputation findUniqueOrThrow
   */
  export type ReputationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * Filter, which Reputation to fetch.
     */
    where: ReputationWhereUniqueInput
  }

  /**
   * Reputation findFirst
   */
  export type ReputationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * Filter, which Reputation to fetch.
     */
    where?: ReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reputations to fetch.
     */
    orderBy?: ReputationOrderByWithRelationInput | ReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reputations.
     */
    cursor?: ReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reputations.
     */
    distinct?: ReputationScalarFieldEnum | ReputationScalarFieldEnum[]
  }

  /**
   * Reputation findFirstOrThrow
   */
  export type ReputationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * Filter, which Reputation to fetch.
     */
    where?: ReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reputations to fetch.
     */
    orderBy?: ReputationOrderByWithRelationInput | ReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reputations.
     */
    cursor?: ReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reputations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reputations.
     */
    distinct?: ReputationScalarFieldEnum | ReputationScalarFieldEnum[]
  }

  /**
   * Reputation findMany
   */
  export type ReputationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * Filter, which Reputations to fetch.
     */
    where?: ReputationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reputations to fetch.
     */
    orderBy?: ReputationOrderByWithRelationInput | ReputationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reputations.
     */
    cursor?: ReputationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reputations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reputations.
     */
    skip?: number
    distinct?: ReputationScalarFieldEnum | ReputationScalarFieldEnum[]
  }

  /**
   * Reputation create
   */
  export type ReputationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reputation.
     */
    data: XOR<ReputationCreateInput, ReputationUncheckedCreateInput>
  }

  /**
   * Reputation createMany
   */
  export type ReputationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reputations.
     */
    data: ReputationCreateManyInput | ReputationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reputation createManyAndReturn
   */
  export type ReputationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * The data used to create many Reputations.
     */
    data: ReputationCreateManyInput | ReputationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reputation update
   */
  export type ReputationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reputation.
     */
    data: XOR<ReputationUpdateInput, ReputationUncheckedUpdateInput>
    /**
     * Choose, which Reputation to update.
     */
    where: ReputationWhereUniqueInput
  }

  /**
   * Reputation updateMany
   */
  export type ReputationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reputations.
     */
    data: XOR<ReputationUpdateManyMutationInput, ReputationUncheckedUpdateManyInput>
    /**
     * Filter which Reputations to update
     */
    where?: ReputationWhereInput
    /**
     * Limit how many Reputations to update.
     */
    limit?: number
  }

  /**
   * Reputation updateManyAndReturn
   */
  export type ReputationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * The data used to update Reputations.
     */
    data: XOR<ReputationUpdateManyMutationInput, ReputationUncheckedUpdateManyInput>
    /**
     * Filter which Reputations to update
     */
    where?: ReputationWhereInput
    /**
     * Limit how many Reputations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reputation upsert
   */
  export type ReputationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reputation to update in case it exists.
     */
    where: ReputationWhereUniqueInput
    /**
     * In case the Reputation found by the `where` argument doesn't exist, create a new Reputation with this data.
     */
    create: XOR<ReputationCreateInput, ReputationUncheckedCreateInput>
    /**
     * In case the Reputation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReputationUpdateInput, ReputationUncheckedUpdateInput>
  }

  /**
   * Reputation delete
   */
  export type ReputationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
    /**
     * Filter which Reputation to delete.
     */
    where: ReputationWhereUniqueInput
  }

  /**
   * Reputation deleteMany
   */
  export type ReputationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reputations to delete
     */
    where?: ReputationWhereInput
    /**
     * Limit how many Reputations to delete.
     */
    limit?: number
  }

  /**
   * Reputation without action
   */
  export type ReputationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reputation
     */
    select?: ReputationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reputation
     */
    omit?: ReputationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReputationInclude<ExtArgs> | null
  }


  /**
   * Model WalletAddress
   */

  export type AggregateWalletAddress = {
    _count: WalletAddressCountAggregateOutputType | null
    _min: WalletAddressMinAggregateOutputType | null
    _max: WalletAddressMaxAggregateOutputType | null
  }

  export type WalletAddressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    network: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletAddressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    address: string | null
    network: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WalletAddressCountAggregateOutputType = {
    id: number
    userId: number
    address: number
    network: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WalletAddressMinAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    network?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletAddressMaxAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    network?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WalletAddressCountAggregateInputType = {
    id?: true
    userId?: true
    address?: true
    network?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletAddress to aggregate.
     */
    where?: WalletAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletAddresses to fetch.
     */
    orderBy?: WalletAddressOrderByWithRelationInput | WalletAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletAddresses
    **/
    _count?: true | WalletAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletAddressMaxAggregateInputType
  }

  export type GetWalletAddressAggregateType<T extends WalletAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletAddress[P]>
      : GetScalarType<T[P], AggregateWalletAddress[P]>
  }




  export type WalletAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletAddressWhereInput
    orderBy?: WalletAddressOrderByWithAggregationInput | WalletAddressOrderByWithAggregationInput[]
    by: WalletAddressScalarFieldEnum[] | WalletAddressScalarFieldEnum
    having?: WalletAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletAddressCountAggregateInputType | true
    _min?: WalletAddressMinAggregateInputType
    _max?: WalletAddressMaxAggregateInputType
  }

  export type WalletAddressGroupByOutputType = {
    id: string
    userId: string
    address: string
    network: string
    createdAt: Date
    updatedAt: Date
    _count: WalletAddressCountAggregateOutputType | null
    _min: WalletAddressMinAggregateOutputType | null
    _max: WalletAddressMaxAggregateOutputType | null
  }

  type GetWalletAddressGroupByPayload<T extends WalletAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletAddressGroupByOutputType[P]>
            : GetScalarType<T[P], WalletAddressGroupByOutputType[P]>
        }
      >
    >


  export type WalletAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    network?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletAddress"]>

  export type WalletAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    network?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletAddress"]>

  export type WalletAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    address?: boolean
    network?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletAddress"]>

  export type WalletAddressSelectScalar = {
    id?: boolean
    userId?: boolean
    address?: boolean
    network?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WalletAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "address" | "network" | "createdAt" | "updatedAt", ExtArgs["result"]["walletAddress"]>
  export type WalletAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WalletAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WalletAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletAddress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      address: string
      network: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["walletAddress"]>
    composites: {}
  }

  type WalletAddressGetPayload<S extends boolean | null | undefined | WalletAddressDefaultArgs> = $Result.GetResult<Prisma.$WalletAddressPayload, S>

  type WalletAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WalletAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletAddressCountAggregateInputType | true
    }

  export interface WalletAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletAddress'], meta: { name: 'WalletAddress' } }
    /**
     * Find zero or one WalletAddress that matches the filter.
     * @param {WalletAddressFindUniqueArgs} args - Arguments to find a WalletAddress
     * @example
     * // Get one WalletAddress
     * const walletAddress = await prisma.walletAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletAddressFindUniqueArgs>(args: SelectSubset<T, WalletAddressFindUniqueArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WalletAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WalletAddressFindUniqueOrThrowArgs} args - Arguments to find a WalletAddress
     * @example
     * // Get one WalletAddress
     * const walletAddress = await prisma.walletAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAddressFindFirstArgs} args - Arguments to find a WalletAddress
     * @example
     * // Get one WalletAddress
     * const walletAddress = await prisma.walletAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletAddressFindFirstArgs>(args?: SelectSubset<T, WalletAddressFindFirstArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WalletAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAddressFindFirstOrThrowArgs} args - Arguments to find a WalletAddress
     * @example
     * // Get one WalletAddress
     * const walletAddress = await prisma.walletAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WalletAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletAddresses
     * const walletAddresses = await prisma.walletAddress.findMany()
     * 
     * // Get first 10 WalletAddresses
     * const walletAddresses = await prisma.walletAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletAddressWithIdOnly = await prisma.walletAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletAddressFindManyArgs>(args?: SelectSubset<T, WalletAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WalletAddress.
     * @param {WalletAddressCreateArgs} args - Arguments to create a WalletAddress.
     * @example
     * // Create one WalletAddress
     * const WalletAddress = await prisma.walletAddress.create({
     *   data: {
     *     // ... data to create a WalletAddress
     *   }
     * })
     * 
     */
    create<T extends WalletAddressCreateArgs>(args: SelectSubset<T, WalletAddressCreateArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WalletAddresses.
     * @param {WalletAddressCreateManyArgs} args - Arguments to create many WalletAddresses.
     * @example
     * // Create many WalletAddresses
     * const walletAddress = await prisma.walletAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletAddressCreateManyArgs>(args?: SelectSubset<T, WalletAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletAddresses and returns the data saved in the database.
     * @param {WalletAddressCreateManyAndReturnArgs} args - Arguments to create many WalletAddresses.
     * @example
     * // Create many WalletAddresses
     * const walletAddress = await prisma.walletAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletAddresses and only return the `id`
     * const walletAddressWithIdOnly = await prisma.walletAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WalletAddress.
     * @param {WalletAddressDeleteArgs} args - Arguments to delete one WalletAddress.
     * @example
     * // Delete one WalletAddress
     * const WalletAddress = await prisma.walletAddress.delete({
     *   where: {
     *     // ... filter to delete one WalletAddress
     *   }
     * })
     * 
     */
    delete<T extends WalletAddressDeleteArgs>(args: SelectSubset<T, WalletAddressDeleteArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WalletAddress.
     * @param {WalletAddressUpdateArgs} args - Arguments to update one WalletAddress.
     * @example
     * // Update one WalletAddress
     * const walletAddress = await prisma.walletAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletAddressUpdateArgs>(args: SelectSubset<T, WalletAddressUpdateArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WalletAddresses.
     * @param {WalletAddressDeleteManyArgs} args - Arguments to filter WalletAddresses to delete.
     * @example
     * // Delete a few WalletAddresses
     * const { count } = await prisma.walletAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletAddressDeleteManyArgs>(args?: SelectSubset<T, WalletAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletAddresses
     * const walletAddress = await prisma.walletAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletAddressUpdateManyArgs>(args: SelectSubset<T, WalletAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletAddresses and returns the data updated in the database.
     * @param {WalletAddressUpdateManyAndReturnArgs} args - Arguments to update many WalletAddresses.
     * @example
     * // Update many WalletAddresses
     * const walletAddress = await prisma.walletAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WalletAddresses and only return the `id`
     * const walletAddressWithIdOnly = await prisma.walletAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WalletAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, WalletAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WalletAddress.
     * @param {WalletAddressUpsertArgs} args - Arguments to update or create a WalletAddress.
     * @example
     * // Update or create a WalletAddress
     * const walletAddress = await prisma.walletAddress.upsert({
     *   create: {
     *     // ... data to create a WalletAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletAddress we want to update
     *   }
     * })
     */
    upsert<T extends WalletAddressUpsertArgs>(args: SelectSubset<T, WalletAddressUpsertArgs<ExtArgs>>): Prisma__WalletAddressClient<$Result.GetResult<Prisma.$WalletAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WalletAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAddressCountArgs} args - Arguments to filter WalletAddresses to count.
     * @example
     * // Count the number of WalletAddresses
     * const count = await prisma.walletAddress.count({
     *   where: {
     *     // ... the filter for the WalletAddresses we want to count
     *   }
     * })
    **/
    count<T extends WalletAddressCountArgs>(
      args?: Subset<T, WalletAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAddressAggregateArgs>(args: Subset<T, WalletAddressAggregateArgs>): Prisma.PrismaPromise<GetWalletAddressAggregateType<T>>

    /**
     * Group by WalletAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletAddressGroupByArgs['orderBy'] }
        : { orderBy?: WalletAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletAddress model
   */
  readonly fields: WalletAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletAddress model
   */
  interface WalletAddressFieldRefs {
    readonly id: FieldRef<"WalletAddress", 'String'>
    readonly userId: FieldRef<"WalletAddress", 'String'>
    readonly address: FieldRef<"WalletAddress", 'String'>
    readonly network: FieldRef<"WalletAddress", 'String'>
    readonly createdAt: FieldRef<"WalletAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"WalletAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletAddress findUnique
   */
  export type WalletAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * Filter, which WalletAddress to fetch.
     */
    where: WalletAddressWhereUniqueInput
  }

  /**
   * WalletAddress findUniqueOrThrow
   */
  export type WalletAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * Filter, which WalletAddress to fetch.
     */
    where: WalletAddressWhereUniqueInput
  }

  /**
   * WalletAddress findFirst
   */
  export type WalletAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * Filter, which WalletAddress to fetch.
     */
    where?: WalletAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletAddresses to fetch.
     */
    orderBy?: WalletAddressOrderByWithRelationInput | WalletAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletAddresses.
     */
    cursor?: WalletAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletAddresses.
     */
    distinct?: WalletAddressScalarFieldEnum | WalletAddressScalarFieldEnum[]
  }

  /**
   * WalletAddress findFirstOrThrow
   */
  export type WalletAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * Filter, which WalletAddress to fetch.
     */
    where?: WalletAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletAddresses to fetch.
     */
    orderBy?: WalletAddressOrderByWithRelationInput | WalletAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletAddresses.
     */
    cursor?: WalletAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletAddresses.
     */
    distinct?: WalletAddressScalarFieldEnum | WalletAddressScalarFieldEnum[]
  }

  /**
   * WalletAddress findMany
   */
  export type WalletAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * Filter, which WalletAddresses to fetch.
     */
    where?: WalletAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletAddresses to fetch.
     */
    orderBy?: WalletAddressOrderByWithRelationInput | WalletAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletAddresses.
     */
    cursor?: WalletAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletAddresses.
     */
    skip?: number
    distinct?: WalletAddressScalarFieldEnum | WalletAddressScalarFieldEnum[]
  }

  /**
   * WalletAddress create
   */
  export type WalletAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletAddress.
     */
    data: XOR<WalletAddressCreateInput, WalletAddressUncheckedCreateInput>
  }

  /**
   * WalletAddress createMany
   */
  export type WalletAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletAddresses.
     */
    data: WalletAddressCreateManyInput | WalletAddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WalletAddress createManyAndReturn
   */
  export type WalletAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * The data used to create many WalletAddresses.
     */
    data: WalletAddressCreateManyInput | WalletAddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletAddress update
   */
  export type WalletAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletAddress.
     */
    data: XOR<WalletAddressUpdateInput, WalletAddressUncheckedUpdateInput>
    /**
     * Choose, which WalletAddress to update.
     */
    where: WalletAddressWhereUniqueInput
  }

  /**
   * WalletAddress updateMany
   */
  export type WalletAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletAddresses.
     */
    data: XOR<WalletAddressUpdateManyMutationInput, WalletAddressUncheckedUpdateManyInput>
    /**
     * Filter which WalletAddresses to update
     */
    where?: WalletAddressWhereInput
    /**
     * Limit how many WalletAddresses to update.
     */
    limit?: number
  }

  /**
   * WalletAddress updateManyAndReturn
   */
  export type WalletAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * The data used to update WalletAddresses.
     */
    data: XOR<WalletAddressUpdateManyMutationInput, WalletAddressUncheckedUpdateManyInput>
    /**
     * Filter which WalletAddresses to update
     */
    where?: WalletAddressWhereInput
    /**
     * Limit how many WalletAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletAddress upsert
   */
  export type WalletAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletAddress to update in case it exists.
     */
    where: WalletAddressWhereUniqueInput
    /**
     * In case the WalletAddress found by the `where` argument doesn't exist, create a new WalletAddress with this data.
     */
    create: XOR<WalletAddressCreateInput, WalletAddressUncheckedCreateInput>
    /**
     * In case the WalletAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletAddressUpdateInput, WalletAddressUncheckedUpdateInput>
  }

  /**
   * WalletAddress delete
   */
  export type WalletAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
    /**
     * Filter which WalletAddress to delete.
     */
    where: WalletAddressWhereUniqueInput
  }

  /**
   * WalletAddress deleteMany
   */
  export type WalletAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletAddresses to delete
     */
    where?: WalletAddressWhereInput
    /**
     * Limit how many WalletAddresses to delete.
     */
    limit?: number
  }

  /**
   * WalletAddress without action
   */
  export type WalletAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletAddress
     */
    select?: WalletAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WalletAddress
     */
    omit?: WalletAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletAddressInclude<ExtArgs> | null
  }


  /**
   * Model SocialAccount
   */

  export type AggregateSocialAccount = {
    _count: SocialAccountCountAggregateOutputType | null
    _min: SocialAccountMinAggregateOutputType | null
    _max: SocialAccountMaxAggregateOutputType | null
  }

  export type SocialAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    handle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: string | null
    handle: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialAccountCountAggregateOutputType = {
    id: number
    userId: number
    platform: number
    handle: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialAccountMinAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    handle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    handle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialAccountCountAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    handle?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialAccount to aggregate.
     */
    where?: SocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialAccounts
    **/
    _count?: true | SocialAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialAccountMaxAggregateInputType
  }

  export type GetSocialAccountAggregateType<T extends SocialAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialAccount[P]>
      : GetScalarType<T[P], AggregateSocialAccount[P]>
  }




  export type SocialAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialAccountWhereInput
    orderBy?: SocialAccountOrderByWithAggregationInput | SocialAccountOrderByWithAggregationInput[]
    by: SocialAccountScalarFieldEnum[] | SocialAccountScalarFieldEnum
    having?: SocialAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialAccountCountAggregateInputType | true
    _min?: SocialAccountMinAggregateInputType
    _max?: SocialAccountMaxAggregateInputType
  }

  export type SocialAccountGroupByOutputType = {
    id: string
    userId: string
    platform: string
    handle: string
    createdAt: Date
    updatedAt: Date
    _count: SocialAccountCountAggregateOutputType | null
    _min: SocialAccountMinAggregateOutputType | null
    _max: SocialAccountMaxAggregateOutputType | null
  }

  type GetSocialAccountGroupByPayload<T extends SocialAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SocialAccountGroupByOutputType[P]>
        }
      >
    >


  export type SocialAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    handle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialAccount"]>

  export type SocialAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    handle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialAccount"]>

  export type SocialAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    handle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialAccount"]>

  export type SocialAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    platform?: boolean
    handle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "platform" | "handle" | "createdAt" | "updatedAt", ExtArgs["result"]["socialAccount"]>
  export type SocialAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SocialAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SocialAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SocialAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      platform: string
      handle: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialAccount"]>
    composites: {}
  }

  type SocialAccountGetPayload<S extends boolean | null | undefined | SocialAccountDefaultArgs> = $Result.GetResult<Prisma.$SocialAccountPayload, S>

  type SocialAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialAccountCountAggregateInputType | true
    }

  export interface SocialAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialAccount'], meta: { name: 'SocialAccount' } }
    /**
     * Find zero or one SocialAccount that matches the filter.
     * @param {SocialAccountFindUniqueArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialAccountFindUniqueArgs>(args: SelectSubset<T, SocialAccountFindUniqueArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialAccountFindUniqueOrThrowArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountFindFirstArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialAccountFindFirstArgs>(args?: SelectSubset<T, SocialAccountFindFirstArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountFindFirstOrThrowArgs} args - Arguments to find a SocialAccount
     * @example
     * // Get one SocialAccount
     * const socialAccount = await prisma.socialAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialAccounts
     * const socialAccounts = await prisma.socialAccount.findMany()
     * 
     * // Get first 10 SocialAccounts
     * const socialAccounts = await prisma.socialAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialAccountWithIdOnly = await prisma.socialAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialAccountFindManyArgs>(args?: SelectSubset<T, SocialAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialAccount.
     * @param {SocialAccountCreateArgs} args - Arguments to create a SocialAccount.
     * @example
     * // Create one SocialAccount
     * const SocialAccount = await prisma.socialAccount.create({
     *   data: {
     *     // ... data to create a SocialAccount
     *   }
     * })
     * 
     */
    create<T extends SocialAccountCreateArgs>(args: SelectSubset<T, SocialAccountCreateArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialAccounts.
     * @param {SocialAccountCreateManyArgs} args - Arguments to create many SocialAccounts.
     * @example
     * // Create many SocialAccounts
     * const socialAccount = await prisma.socialAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialAccountCreateManyArgs>(args?: SelectSubset<T, SocialAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialAccounts and returns the data saved in the database.
     * @param {SocialAccountCreateManyAndReturnArgs} args - Arguments to create many SocialAccounts.
     * @example
     * // Create many SocialAccounts
     * const socialAccount = await prisma.socialAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialAccounts and only return the `id`
     * const socialAccountWithIdOnly = await prisma.socialAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialAccount.
     * @param {SocialAccountDeleteArgs} args - Arguments to delete one SocialAccount.
     * @example
     * // Delete one SocialAccount
     * const SocialAccount = await prisma.socialAccount.delete({
     *   where: {
     *     // ... filter to delete one SocialAccount
     *   }
     * })
     * 
     */
    delete<T extends SocialAccountDeleteArgs>(args: SelectSubset<T, SocialAccountDeleteArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialAccount.
     * @param {SocialAccountUpdateArgs} args - Arguments to update one SocialAccount.
     * @example
     * // Update one SocialAccount
     * const socialAccount = await prisma.socialAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialAccountUpdateArgs>(args: SelectSubset<T, SocialAccountUpdateArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialAccounts.
     * @param {SocialAccountDeleteManyArgs} args - Arguments to filter SocialAccounts to delete.
     * @example
     * // Delete a few SocialAccounts
     * const { count } = await prisma.socialAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialAccountDeleteManyArgs>(args?: SelectSubset<T, SocialAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialAccounts
     * const socialAccount = await prisma.socialAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialAccountUpdateManyArgs>(args: SelectSubset<T, SocialAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialAccounts and returns the data updated in the database.
     * @param {SocialAccountUpdateManyAndReturnArgs} args - Arguments to update many SocialAccounts.
     * @example
     * // Update many SocialAccounts
     * const socialAccount = await prisma.socialAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialAccounts and only return the `id`
     * const socialAccountWithIdOnly = await prisma.socialAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialAccount.
     * @param {SocialAccountUpsertArgs} args - Arguments to update or create a SocialAccount.
     * @example
     * // Update or create a SocialAccount
     * const socialAccount = await prisma.socialAccount.upsert({
     *   create: {
     *     // ... data to create a SocialAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialAccount we want to update
     *   }
     * })
     */
    upsert<T extends SocialAccountUpsertArgs>(args: SelectSubset<T, SocialAccountUpsertArgs<ExtArgs>>): Prisma__SocialAccountClient<$Result.GetResult<Prisma.$SocialAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountCountArgs} args - Arguments to filter SocialAccounts to count.
     * @example
     * // Count the number of SocialAccounts
     * const count = await prisma.socialAccount.count({
     *   where: {
     *     // ... the filter for the SocialAccounts we want to count
     *   }
     * })
    **/
    count<T extends SocialAccountCountArgs>(
      args?: Subset<T, SocialAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialAccountAggregateArgs>(args: Subset<T, SocialAccountAggregateArgs>): Prisma.PrismaPromise<GetSocialAccountAggregateType<T>>

    /**
     * Group by SocialAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialAccountGroupByArgs['orderBy'] }
        : { orderBy?: SocialAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialAccount model
   */
  readonly fields: SocialAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialAccount model
   */
  interface SocialAccountFieldRefs {
    readonly id: FieldRef<"SocialAccount", 'String'>
    readonly userId: FieldRef<"SocialAccount", 'String'>
    readonly platform: FieldRef<"SocialAccount", 'String'>
    readonly handle: FieldRef<"SocialAccount", 'String'>
    readonly createdAt: FieldRef<"SocialAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialAccount findUnique
   */
  export type SocialAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialAccount to fetch.
     */
    where: SocialAccountWhereUniqueInput
  }

  /**
   * SocialAccount findUniqueOrThrow
   */
  export type SocialAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialAccount to fetch.
     */
    where: SocialAccountWhereUniqueInput
  }

  /**
   * SocialAccount findFirst
   */
  export type SocialAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialAccount to fetch.
     */
    where?: SocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialAccounts.
     */
    cursor?: SocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialAccounts.
     */
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[]
  }

  /**
   * SocialAccount findFirstOrThrow
   */
  export type SocialAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialAccount to fetch.
     */
    where?: SocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialAccounts.
     */
    cursor?: SocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialAccounts.
     */
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[]
  }

  /**
   * SocialAccount findMany
   */
  export type SocialAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialAccounts to fetch.
     */
    where?: SocialAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialAccounts to fetch.
     */
    orderBy?: SocialAccountOrderByWithRelationInput | SocialAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialAccounts.
     */
    cursor?: SocialAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialAccounts.
     */
    skip?: number
    distinct?: SocialAccountScalarFieldEnum | SocialAccountScalarFieldEnum[]
  }

  /**
   * SocialAccount create
   */
  export type SocialAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialAccount.
     */
    data: XOR<SocialAccountCreateInput, SocialAccountUncheckedCreateInput>
  }

  /**
   * SocialAccount createMany
   */
  export type SocialAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialAccounts.
     */
    data: SocialAccountCreateManyInput | SocialAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialAccount createManyAndReturn
   */
  export type SocialAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SocialAccounts.
     */
    data: SocialAccountCreateManyInput | SocialAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialAccount update
   */
  export type SocialAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialAccount.
     */
    data: XOR<SocialAccountUpdateInput, SocialAccountUncheckedUpdateInput>
    /**
     * Choose, which SocialAccount to update.
     */
    where: SocialAccountWhereUniqueInput
  }

  /**
   * SocialAccount updateMany
   */
  export type SocialAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialAccounts.
     */
    data: XOR<SocialAccountUpdateManyMutationInput, SocialAccountUncheckedUpdateManyInput>
    /**
     * Filter which SocialAccounts to update
     */
    where?: SocialAccountWhereInput
    /**
     * Limit how many SocialAccounts to update.
     */
    limit?: number
  }

  /**
   * SocialAccount updateManyAndReturn
   */
  export type SocialAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * The data used to update SocialAccounts.
     */
    data: XOR<SocialAccountUpdateManyMutationInput, SocialAccountUncheckedUpdateManyInput>
    /**
     * Filter which SocialAccounts to update
     */
    where?: SocialAccountWhereInput
    /**
     * Limit how many SocialAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialAccount upsert
   */
  export type SocialAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialAccount to update in case it exists.
     */
    where: SocialAccountWhereUniqueInput
    /**
     * In case the SocialAccount found by the `where` argument doesn't exist, create a new SocialAccount with this data.
     */
    create: XOR<SocialAccountCreateInput, SocialAccountUncheckedCreateInput>
    /**
     * In case the SocialAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialAccountUpdateInput, SocialAccountUncheckedUpdateInput>
  }

  /**
   * SocialAccount delete
   */
  export type SocialAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
    /**
     * Filter which SocialAccount to delete.
     */
    where: SocialAccountWhereUniqueInput
  }

  /**
   * SocialAccount deleteMany
   */
  export type SocialAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialAccounts to delete
     */
    where?: SocialAccountWhereInput
    /**
     * Limit how many SocialAccounts to delete.
     */
    limit?: number
  }

  /**
   * SocialAccount without action
   */
  export type SocialAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialAccount
     */
    select?: SocialAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialAccount
     */
    omit?: SocialAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialAccountInclude<ExtArgs> | null
  }


  /**
   * Model TokenHolding
   */

  export type AggregateTokenHolding = {
    _count: TokenHoldingCountAggregateOutputType | null
    _avg: TokenHoldingAvgAggregateOutputType | null
    _sum: TokenHoldingSumAggregateOutputType | null
    _min: TokenHoldingMinAggregateOutputType | null
    _max: TokenHoldingMaxAggregateOutputType | null
  }

  export type TokenHoldingAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type TokenHoldingSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type TokenHoldingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenHoldingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    amount: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenHoldingCountAggregateOutputType = {
    id: number
    userId: number
    coinId: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokenHoldingAvgAggregateInputType = {
    amount?: true
  }

  export type TokenHoldingSumAggregateInputType = {
    amount?: true
  }

  export type TokenHoldingMinAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenHoldingMaxAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenHoldingCountAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokenHoldingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenHolding to aggregate.
     */
    where?: TokenHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHoldings to fetch.
     */
    orderBy?: TokenHoldingOrderByWithRelationInput | TokenHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenHoldings
    **/
    _count?: true | TokenHoldingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenHoldingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenHoldingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenHoldingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenHoldingMaxAggregateInputType
  }

  export type GetTokenHoldingAggregateType<T extends TokenHoldingAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenHolding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenHolding[P]>
      : GetScalarType<T[P], AggregateTokenHolding[P]>
  }




  export type TokenHoldingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenHoldingWhereInput
    orderBy?: TokenHoldingOrderByWithAggregationInput | TokenHoldingOrderByWithAggregationInput[]
    by: TokenHoldingScalarFieldEnum[] | TokenHoldingScalarFieldEnum
    having?: TokenHoldingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenHoldingCountAggregateInputType | true
    _avg?: TokenHoldingAvgAggregateInputType
    _sum?: TokenHoldingSumAggregateInputType
    _min?: TokenHoldingMinAggregateInputType
    _max?: TokenHoldingMaxAggregateInputType
  }

  export type TokenHoldingGroupByOutputType = {
    id: string
    userId: string
    coinId: string
    amount: Decimal
    createdAt: Date
    updatedAt: Date
    _count: TokenHoldingCountAggregateOutputType | null
    _avg: TokenHoldingAvgAggregateOutputType | null
    _sum: TokenHoldingSumAggregateOutputType | null
    _min: TokenHoldingMinAggregateOutputType | null
    _max: TokenHoldingMaxAggregateOutputType | null
  }

  type GetTokenHoldingGroupByPayload<T extends TokenHoldingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenHoldingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenHoldingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenHoldingGroupByOutputType[P]>
            : GetScalarType<T[P], TokenHoldingGroupByOutputType[P]>
        }
      >
    >


  export type TokenHoldingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenHolding"]>

  export type TokenHoldingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenHolding"]>

  export type TokenHoldingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenHolding"]>

  export type TokenHoldingSelectScalar = {
    id?: boolean
    userId?: boolean
    coinId?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TokenHoldingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "coinId" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["tokenHolding"]>
  export type TokenHoldingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type TokenHoldingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type TokenHoldingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $TokenHoldingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenHolding"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coinId: string
      amount: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tokenHolding"]>
    composites: {}
  }

  type TokenHoldingGetPayload<S extends boolean | null | undefined | TokenHoldingDefaultArgs> = $Result.GetResult<Prisma.$TokenHoldingPayload, S>

  type TokenHoldingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenHoldingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenHoldingCountAggregateInputType | true
    }

  export interface TokenHoldingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenHolding'], meta: { name: 'TokenHolding' } }
    /**
     * Find zero or one TokenHolding that matches the filter.
     * @param {TokenHoldingFindUniqueArgs} args - Arguments to find a TokenHolding
     * @example
     * // Get one TokenHolding
     * const tokenHolding = await prisma.tokenHolding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenHoldingFindUniqueArgs>(args: SelectSubset<T, TokenHoldingFindUniqueArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TokenHolding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenHoldingFindUniqueOrThrowArgs} args - Arguments to find a TokenHolding
     * @example
     * // Get one TokenHolding
     * const tokenHolding = await prisma.tokenHolding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenHoldingFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenHoldingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenHolding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHoldingFindFirstArgs} args - Arguments to find a TokenHolding
     * @example
     * // Get one TokenHolding
     * const tokenHolding = await prisma.tokenHolding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenHoldingFindFirstArgs>(args?: SelectSubset<T, TokenHoldingFindFirstArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenHolding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHoldingFindFirstOrThrowArgs} args - Arguments to find a TokenHolding
     * @example
     * // Get one TokenHolding
     * const tokenHolding = await prisma.tokenHolding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenHoldingFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenHoldingFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TokenHoldings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHoldingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenHoldings
     * const tokenHoldings = await prisma.tokenHolding.findMany()
     * 
     * // Get first 10 TokenHoldings
     * const tokenHoldings = await prisma.tokenHolding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenHoldingWithIdOnly = await prisma.tokenHolding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenHoldingFindManyArgs>(args?: SelectSubset<T, TokenHoldingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TokenHolding.
     * @param {TokenHoldingCreateArgs} args - Arguments to create a TokenHolding.
     * @example
     * // Create one TokenHolding
     * const TokenHolding = await prisma.tokenHolding.create({
     *   data: {
     *     // ... data to create a TokenHolding
     *   }
     * })
     * 
     */
    create<T extends TokenHoldingCreateArgs>(args: SelectSubset<T, TokenHoldingCreateArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TokenHoldings.
     * @param {TokenHoldingCreateManyArgs} args - Arguments to create many TokenHoldings.
     * @example
     * // Create many TokenHoldings
     * const tokenHolding = await prisma.tokenHolding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenHoldingCreateManyArgs>(args?: SelectSubset<T, TokenHoldingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenHoldings and returns the data saved in the database.
     * @param {TokenHoldingCreateManyAndReturnArgs} args - Arguments to create many TokenHoldings.
     * @example
     * // Create many TokenHoldings
     * const tokenHolding = await prisma.tokenHolding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenHoldings and only return the `id`
     * const tokenHoldingWithIdOnly = await prisma.tokenHolding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenHoldingCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenHoldingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TokenHolding.
     * @param {TokenHoldingDeleteArgs} args - Arguments to delete one TokenHolding.
     * @example
     * // Delete one TokenHolding
     * const TokenHolding = await prisma.tokenHolding.delete({
     *   where: {
     *     // ... filter to delete one TokenHolding
     *   }
     * })
     * 
     */
    delete<T extends TokenHoldingDeleteArgs>(args: SelectSubset<T, TokenHoldingDeleteArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TokenHolding.
     * @param {TokenHoldingUpdateArgs} args - Arguments to update one TokenHolding.
     * @example
     * // Update one TokenHolding
     * const tokenHolding = await prisma.tokenHolding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenHoldingUpdateArgs>(args: SelectSubset<T, TokenHoldingUpdateArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TokenHoldings.
     * @param {TokenHoldingDeleteManyArgs} args - Arguments to filter TokenHoldings to delete.
     * @example
     * // Delete a few TokenHoldings
     * const { count } = await prisma.tokenHolding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenHoldingDeleteManyArgs>(args?: SelectSubset<T, TokenHoldingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHoldingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenHoldings
     * const tokenHolding = await prisma.tokenHolding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenHoldingUpdateManyArgs>(args: SelectSubset<T, TokenHoldingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenHoldings and returns the data updated in the database.
     * @param {TokenHoldingUpdateManyAndReturnArgs} args - Arguments to update many TokenHoldings.
     * @example
     * // Update many TokenHoldings
     * const tokenHolding = await prisma.tokenHolding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TokenHoldings and only return the `id`
     * const tokenHoldingWithIdOnly = await prisma.tokenHolding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenHoldingUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenHoldingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TokenHolding.
     * @param {TokenHoldingUpsertArgs} args - Arguments to update or create a TokenHolding.
     * @example
     * // Update or create a TokenHolding
     * const tokenHolding = await prisma.tokenHolding.upsert({
     *   create: {
     *     // ... data to create a TokenHolding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenHolding we want to update
     *   }
     * })
     */
    upsert<T extends TokenHoldingUpsertArgs>(args: SelectSubset<T, TokenHoldingUpsertArgs<ExtArgs>>): Prisma__TokenHoldingClient<$Result.GetResult<Prisma.$TokenHoldingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TokenHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHoldingCountArgs} args - Arguments to filter TokenHoldings to count.
     * @example
     * // Count the number of TokenHoldings
     * const count = await prisma.tokenHolding.count({
     *   where: {
     *     // ... the filter for the TokenHoldings we want to count
     *   }
     * })
    **/
    count<T extends TokenHoldingCountArgs>(
      args?: Subset<T, TokenHoldingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenHoldingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHoldingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenHoldingAggregateArgs>(args: Subset<T, TokenHoldingAggregateArgs>): Prisma.PrismaPromise<GetTokenHoldingAggregateType<T>>

    /**
     * Group by TokenHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenHoldingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenHoldingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenHoldingGroupByArgs['orderBy'] }
        : { orderBy?: TokenHoldingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenHoldingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenHoldingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenHolding model
   */
  readonly fields: TokenHoldingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenHolding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenHoldingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenHolding model
   */
  interface TokenHoldingFieldRefs {
    readonly id: FieldRef<"TokenHolding", 'String'>
    readonly userId: FieldRef<"TokenHolding", 'String'>
    readonly coinId: FieldRef<"TokenHolding", 'String'>
    readonly amount: FieldRef<"TokenHolding", 'Decimal'>
    readonly createdAt: FieldRef<"TokenHolding", 'DateTime'>
    readonly updatedAt: FieldRef<"TokenHolding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TokenHolding findUnique
   */
  export type TokenHoldingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * Filter, which TokenHolding to fetch.
     */
    where: TokenHoldingWhereUniqueInput
  }

  /**
   * TokenHolding findUniqueOrThrow
   */
  export type TokenHoldingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * Filter, which TokenHolding to fetch.
     */
    where: TokenHoldingWhereUniqueInput
  }

  /**
   * TokenHolding findFirst
   */
  export type TokenHoldingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * Filter, which TokenHolding to fetch.
     */
    where?: TokenHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHoldings to fetch.
     */
    orderBy?: TokenHoldingOrderByWithRelationInput | TokenHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenHoldings.
     */
    cursor?: TokenHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenHoldings.
     */
    distinct?: TokenHoldingScalarFieldEnum | TokenHoldingScalarFieldEnum[]
  }

  /**
   * TokenHolding findFirstOrThrow
   */
  export type TokenHoldingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * Filter, which TokenHolding to fetch.
     */
    where?: TokenHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHoldings to fetch.
     */
    orderBy?: TokenHoldingOrderByWithRelationInput | TokenHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenHoldings.
     */
    cursor?: TokenHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenHoldings.
     */
    distinct?: TokenHoldingScalarFieldEnum | TokenHoldingScalarFieldEnum[]
  }

  /**
   * TokenHolding findMany
   */
  export type TokenHoldingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * Filter, which TokenHoldings to fetch.
     */
    where?: TokenHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenHoldings to fetch.
     */
    orderBy?: TokenHoldingOrderByWithRelationInput | TokenHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenHoldings.
     */
    cursor?: TokenHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenHoldings.
     */
    skip?: number
    distinct?: TokenHoldingScalarFieldEnum | TokenHoldingScalarFieldEnum[]
  }

  /**
   * TokenHolding create
   */
  export type TokenHoldingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenHolding.
     */
    data: XOR<TokenHoldingCreateInput, TokenHoldingUncheckedCreateInput>
  }

  /**
   * TokenHolding createMany
   */
  export type TokenHoldingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenHoldings.
     */
    data: TokenHoldingCreateManyInput | TokenHoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenHolding createManyAndReturn
   */
  export type TokenHoldingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * The data used to create many TokenHoldings.
     */
    data: TokenHoldingCreateManyInput | TokenHoldingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenHolding update
   */
  export type TokenHoldingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenHolding.
     */
    data: XOR<TokenHoldingUpdateInput, TokenHoldingUncheckedUpdateInput>
    /**
     * Choose, which TokenHolding to update.
     */
    where: TokenHoldingWhereUniqueInput
  }

  /**
   * TokenHolding updateMany
   */
  export type TokenHoldingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenHoldings.
     */
    data: XOR<TokenHoldingUpdateManyMutationInput, TokenHoldingUncheckedUpdateManyInput>
    /**
     * Filter which TokenHoldings to update
     */
    where?: TokenHoldingWhereInput
    /**
     * Limit how many TokenHoldings to update.
     */
    limit?: number
  }

  /**
   * TokenHolding updateManyAndReturn
   */
  export type TokenHoldingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * The data used to update TokenHoldings.
     */
    data: XOR<TokenHoldingUpdateManyMutationInput, TokenHoldingUncheckedUpdateManyInput>
    /**
     * Filter which TokenHoldings to update
     */
    where?: TokenHoldingWhereInput
    /**
     * Limit how many TokenHoldings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenHolding upsert
   */
  export type TokenHoldingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenHolding to update in case it exists.
     */
    where: TokenHoldingWhereUniqueInput
    /**
     * In case the TokenHolding found by the `where` argument doesn't exist, create a new TokenHolding with this data.
     */
    create: XOR<TokenHoldingCreateInput, TokenHoldingUncheckedCreateInput>
    /**
     * In case the TokenHolding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenHoldingUpdateInput, TokenHoldingUncheckedUpdateInput>
  }

  /**
   * TokenHolding delete
   */
  export type TokenHoldingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
    /**
     * Filter which TokenHolding to delete.
     */
    where: TokenHoldingWhereUniqueInput
  }

  /**
   * TokenHolding deleteMany
   */
  export type TokenHoldingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenHoldings to delete
     */
    where?: TokenHoldingWhereInput
    /**
     * Limit how many TokenHoldings to delete.
     */
    limit?: number
  }

  /**
   * TokenHolding without action
   */
  export type TokenHoldingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenHolding
     */
    select?: TokenHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenHolding
     */
    omit?: TokenHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenHoldingInclude<ExtArgs> | null
  }


  /**
   * Model PriceHistory
   */

  export type AggregatePriceHistory = {
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  export type PriceHistoryAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type PriceHistorySumAggregateOutputType = {
    price: Decimal | null
  }

  export type PriceHistoryMinAggregateOutputType = {
    id: string | null
    coinId: string | null
    price: Decimal | null
    timestamp: Date | null
  }

  export type PriceHistoryMaxAggregateOutputType = {
    id: string | null
    coinId: string | null
    price: Decimal | null
    timestamp: Date | null
  }

  export type PriceHistoryCountAggregateOutputType = {
    id: number
    coinId: number
    price: number
    timestamp: number
    _all: number
  }


  export type PriceHistoryAvgAggregateInputType = {
    price?: true
  }

  export type PriceHistorySumAggregateInputType = {
    price?: true
  }

  export type PriceHistoryMinAggregateInputType = {
    id?: true
    coinId?: true
    price?: true
    timestamp?: true
  }

  export type PriceHistoryMaxAggregateInputType = {
    id?: true
    coinId?: true
    price?: true
    timestamp?: true
  }

  export type PriceHistoryCountAggregateInputType = {
    id?: true
    coinId?: true
    price?: true
    timestamp?: true
    _all?: true
  }

  export type PriceHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistory to aggregate.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceHistories
    **/
    _count?: true | PriceHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type GetPriceHistoryAggregateType<T extends PriceHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceHistory[P]>
      : GetScalarType<T[P], AggregatePriceHistory[P]>
  }




  export type PriceHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceHistoryWhereInput
    orderBy?: PriceHistoryOrderByWithAggregationInput | PriceHistoryOrderByWithAggregationInput[]
    by: PriceHistoryScalarFieldEnum[] | PriceHistoryScalarFieldEnum
    having?: PriceHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceHistoryCountAggregateInputType | true
    _avg?: PriceHistoryAvgAggregateInputType
    _sum?: PriceHistorySumAggregateInputType
    _min?: PriceHistoryMinAggregateInputType
    _max?: PriceHistoryMaxAggregateInputType
  }

  export type PriceHistoryGroupByOutputType = {
    id: string
    coinId: string
    price: Decimal
    timestamp: Date
    _count: PriceHistoryCountAggregateOutputType | null
    _avg: PriceHistoryAvgAggregateOutputType | null
    _sum: PriceHistorySumAggregateOutputType | null
    _min: PriceHistoryMinAggregateOutputType | null
    _max: PriceHistoryMaxAggregateOutputType | null
  }

  type GetPriceHistoryGroupByPayload<T extends PriceHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PriceHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PriceHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coinId?: boolean
    price?: boolean
    timestamp?: boolean
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coinId?: boolean
    price?: boolean
    timestamp?: boolean
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    coinId?: boolean
    price?: boolean
    timestamp?: boolean
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceHistory"]>

  export type PriceHistorySelectScalar = {
    id?: boolean
    coinId?: boolean
    price?: boolean
    timestamp?: boolean
  }

  export type PriceHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "coinId" | "price" | "timestamp", ExtArgs["result"]["priceHistory"]>
  export type PriceHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type PriceHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type PriceHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $PriceHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceHistory"
    objects: {
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      coinId: string
      price: Prisma.Decimal
      timestamp: Date
    }, ExtArgs["result"]["priceHistory"]>
    composites: {}
  }

  type PriceHistoryGetPayload<S extends boolean | null | undefined | PriceHistoryDefaultArgs> = $Result.GetResult<Prisma.$PriceHistoryPayload, S>

  type PriceHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceHistoryCountAggregateInputType | true
    }

  export interface PriceHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceHistory'], meta: { name: 'PriceHistory' } }
    /**
     * Find zero or one PriceHistory that matches the filter.
     * @param {PriceHistoryFindUniqueArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceHistoryFindUniqueArgs>(args: SelectSubset<T, PriceHistoryFindUniqueArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceHistoryFindUniqueOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceHistoryFindFirstArgs>(args?: SelectSubset<T, PriceHistoryFindFirstArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindFirstOrThrowArgs} args - Arguments to find a PriceHistory
     * @example
     * // Get one PriceHistory
     * const priceHistory = await prisma.priceHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany()
     * 
     * // Get first 10 PriceHistories
     * const priceHistories = await prisma.priceHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceHistoryFindManyArgs>(args?: SelectSubset<T, PriceHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceHistory.
     * @param {PriceHistoryCreateArgs} args - Arguments to create a PriceHistory.
     * @example
     * // Create one PriceHistory
     * const PriceHistory = await prisma.priceHistory.create({
     *   data: {
     *     // ... data to create a PriceHistory
     *   }
     * })
     * 
     */
    create<T extends PriceHistoryCreateArgs>(args: SelectSubset<T, PriceHistoryCreateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceHistories.
     * @param {PriceHistoryCreateManyArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceHistoryCreateManyArgs>(args?: SelectSubset<T, PriceHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceHistories and returns the data saved in the database.
     * @param {PriceHistoryCreateManyAndReturnArgs} args - Arguments to create many PriceHistories.
     * @example
     * // Create many PriceHistories
     * const priceHistory = await prisma.priceHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceHistory.
     * @param {PriceHistoryDeleteArgs} args - Arguments to delete one PriceHistory.
     * @example
     * // Delete one PriceHistory
     * const PriceHistory = await prisma.priceHistory.delete({
     *   where: {
     *     // ... filter to delete one PriceHistory
     *   }
     * })
     * 
     */
    delete<T extends PriceHistoryDeleteArgs>(args: SelectSubset<T, PriceHistoryDeleteArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceHistory.
     * @param {PriceHistoryUpdateArgs} args - Arguments to update one PriceHistory.
     * @example
     * // Update one PriceHistory
     * const priceHistory = await prisma.priceHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceHistoryUpdateArgs>(args: SelectSubset<T, PriceHistoryUpdateArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceHistories.
     * @param {PriceHistoryDeleteManyArgs} args - Arguments to filter PriceHistories to delete.
     * @example
     * // Delete a few PriceHistories
     * const { count } = await prisma.priceHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceHistoryDeleteManyArgs>(args?: SelectSubset<T, PriceHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceHistoryUpdateManyArgs>(args: SelectSubset<T, PriceHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceHistories and returns the data updated in the database.
     * @param {PriceHistoryUpdateManyAndReturnArgs} args - Arguments to update many PriceHistories.
     * @example
     * // Update many PriceHistories
     * const priceHistory = await prisma.priceHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceHistories and only return the `id`
     * const priceHistoryWithIdOnly = await prisma.priceHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceHistory.
     * @param {PriceHistoryUpsertArgs} args - Arguments to update or create a PriceHistory.
     * @example
     * // Update or create a PriceHistory
     * const priceHistory = await prisma.priceHistory.upsert({
     *   create: {
     *     // ... data to create a PriceHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceHistory we want to update
     *   }
     * })
     */
    upsert<T extends PriceHistoryUpsertArgs>(args: SelectSubset<T, PriceHistoryUpsertArgs<ExtArgs>>): Prisma__PriceHistoryClient<$Result.GetResult<Prisma.$PriceHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryCountArgs} args - Arguments to filter PriceHistories to count.
     * @example
     * // Count the number of PriceHistories
     * const count = await prisma.priceHistory.count({
     *   where: {
     *     // ... the filter for the PriceHistories we want to count
     *   }
     * })
    **/
    count<T extends PriceHistoryCountArgs>(
      args?: Subset<T, PriceHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceHistoryAggregateArgs>(args: Subset<T, PriceHistoryAggregateArgs>): Prisma.PrismaPromise<GetPriceHistoryAggregateType<T>>

    /**
     * Group by PriceHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PriceHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceHistory model
   */
  readonly fields: PriceHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceHistory model
   */
  interface PriceHistoryFieldRefs {
    readonly id: FieldRef<"PriceHistory", 'String'>
    readonly coinId: FieldRef<"PriceHistory", 'String'>
    readonly price: FieldRef<"PriceHistory", 'Decimal'>
    readonly timestamp: FieldRef<"PriceHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceHistory findUnique
   */
  export type PriceHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findUniqueOrThrow
   */
  export type PriceHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory findFirst
   */
  export type PriceHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findFirstOrThrow
   */
  export type PriceHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistory to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceHistories.
     */
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory findMany
   */
  export type PriceHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PriceHistories to fetch.
     */
    where?: PriceHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceHistories to fetch.
     */
    orderBy?: PriceHistoryOrderByWithRelationInput | PriceHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceHistories.
     */
    cursor?: PriceHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceHistories.
     */
    skip?: number
    distinct?: PriceHistoryScalarFieldEnum | PriceHistoryScalarFieldEnum[]
  }

  /**
   * PriceHistory create
   */
  export type PriceHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceHistory.
     */
    data: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
  }

  /**
   * PriceHistory createMany
   */
  export type PriceHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceHistory createManyAndReturn
   */
  export type PriceHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PriceHistories.
     */
    data: PriceHistoryCreateManyInput | PriceHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceHistory update
   */
  export type PriceHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceHistory.
     */
    data: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
    /**
     * Choose, which PriceHistory to update.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory updateMany
   */
  export type PriceHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to update.
     */
    limit?: number
  }

  /**
   * PriceHistory updateManyAndReturn
   */
  export type PriceHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PriceHistories.
     */
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PriceHistories to update
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceHistory upsert
   */
  export type PriceHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceHistory to update in case it exists.
     */
    where: PriceHistoryWhereUniqueInput
    /**
     * In case the PriceHistory found by the `where` argument doesn't exist, create a new PriceHistory with this data.
     */
    create: XOR<PriceHistoryCreateInput, PriceHistoryUncheckedCreateInput>
    /**
     * In case the PriceHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceHistoryUpdateInput, PriceHistoryUncheckedUpdateInput>
  }

  /**
   * PriceHistory delete
   */
  export type PriceHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
    /**
     * Filter which PriceHistory to delete.
     */
    where: PriceHistoryWhereUniqueInput
  }

  /**
   * PriceHistory deleteMany
   */
  export type PriceHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceHistories to delete
     */
    where?: PriceHistoryWhereInput
    /**
     * Limit how many PriceHistories to delete.
     */
    limit?: number
  }

  /**
   * PriceHistory without action
   */
  export type PriceHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceHistory
     */
    select?: PriceHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceHistory
     */
    omit?: PriceHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    price: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    price: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    type: string | null
    proposalId: string | null
    amount: Decimal | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    coinId: string | null
    type: string | null
    proposalId: string | null
    amount: Decimal | null
    price: Decimal | null
    createdAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    coinId: number
    type: number
    proposalId: number
    amount: number
    price: number
    createdAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    price?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    price?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    type?: true
    proposalId?: true
    amount?: true
    price?: true
    createdAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    type?: true
    proposalId?: true
    amount?: true
    price?: true
    createdAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    coinId?: true
    type?: true
    proposalId?: true
    amount?: true
    price?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    coinId: string
    type: string
    proposalId: string | null
    amount: Decimal
    price: Decimal
    createdAt: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    type?: boolean
    proposalId?: boolean
    amount?: boolean
    price?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    type?: boolean
    proposalId?: boolean
    amount?: boolean
    price?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    coinId?: boolean
    type?: boolean
    proposalId?: boolean
    amount?: boolean
    price?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    coinId?: boolean
    type?: boolean
    proposalId?: boolean
    amount?: boolean
    price?: boolean
    createdAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "coinId" | "type" | "proposalId" | "amount" | "price" | "createdAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      coinId: string
      type: string
      proposalId: string | null
      amount: Prisma.Decimal
      price: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly coinId: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly proposalId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly price: FieldRef<"Transaction", 'Decimal'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Proposal
   */

  export type AggregateProposal = {
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  export type ProposalAvgAggregateOutputType = {
    votesFor: number | null
    votesAgainst: number | null
  }

  export type ProposalSumAggregateOutputType = {
    votesFor: number | null
    votesAgainst: number | null
  }

  export type ProposalMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    votesFor: number | null
    votesAgainst: number | null
    status: string | null
    createdAt: Date | null
    votingEnds: Date | null
    createdById: string | null
    coinId: string | null
  }

  export type ProposalMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    votesFor: number | null
    votesAgainst: number | null
    status: string | null
    createdAt: Date | null
    votingEnds: Date | null
    createdById: string | null
    coinId: string | null
  }

  export type ProposalCountAggregateOutputType = {
    id: number
    title: number
    description: number
    votesFor: number
    votesAgainst: number
    status: number
    createdAt: number
    votingEnds: number
    createdById: number
    coinId: number
    _all: number
  }


  export type ProposalAvgAggregateInputType = {
    votesFor?: true
    votesAgainst?: true
  }

  export type ProposalSumAggregateInputType = {
    votesFor?: true
    votesAgainst?: true
  }

  export type ProposalMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    votesFor?: true
    votesAgainst?: true
    status?: true
    createdAt?: true
    votingEnds?: true
    createdById?: true
    coinId?: true
  }

  export type ProposalMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    votesFor?: true
    votesAgainst?: true
    status?: true
    createdAt?: true
    votingEnds?: true
    createdById?: true
    coinId?: true
  }

  export type ProposalCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    votesFor?: true
    votesAgainst?: true
    status?: true
    createdAt?: true
    votingEnds?: true
    createdById?: true
    coinId?: true
    _all?: true
  }

  export type ProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposal to aggregate.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proposals
    **/
    _count?: true | ProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalMaxAggregateInputType
  }

  export type GetProposalAggregateType<T extends ProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposal[P]>
      : GetScalarType<T[P], AggregateProposal[P]>
  }




  export type ProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalWhereInput
    orderBy?: ProposalOrderByWithAggregationInput | ProposalOrderByWithAggregationInput[]
    by: ProposalScalarFieldEnum[] | ProposalScalarFieldEnum
    having?: ProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalCountAggregateInputType | true
    _avg?: ProposalAvgAggregateInputType
    _sum?: ProposalSumAggregateInputType
    _min?: ProposalMinAggregateInputType
    _max?: ProposalMaxAggregateInputType
  }

  export type ProposalGroupByOutputType = {
    id: string
    title: string
    description: string
    votesFor: number
    votesAgainst: number
    status: string
    createdAt: Date
    votingEnds: Date
    createdById: string
    coinId: string
    _count: ProposalCountAggregateOutputType | null
    _avg: ProposalAvgAggregateOutputType | null
    _sum: ProposalSumAggregateOutputType | null
    _min: ProposalMinAggregateOutputType | null
    _max: ProposalMaxAggregateOutputType | null
  }

  type GetProposalGroupByPayload<T extends ProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalGroupByOutputType[P]>
        }
      >
    >


  export type ProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    votesFor?: boolean
    votesAgainst?: boolean
    status?: boolean
    createdAt?: boolean
    votingEnds?: boolean
    createdById?: boolean
    coinId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    votesFor?: boolean
    votesAgainst?: boolean
    status?: boolean
    createdAt?: boolean
    votingEnds?: boolean
    createdById?: boolean
    coinId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    votesFor?: boolean
    votesAgainst?: boolean
    status?: boolean
    createdAt?: boolean
    votingEnds?: boolean
    createdById?: boolean
    coinId?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposal"]>

  export type ProposalSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    votesFor?: boolean
    votesAgainst?: boolean
    status?: boolean
    createdAt?: boolean
    votingEnds?: boolean
    createdById?: boolean
    coinId?: boolean
  }

  export type ProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "votesFor" | "votesAgainst" | "status" | "createdAt" | "votingEnds" | "createdById" | "coinId", ExtArgs["result"]["proposal"]>
  export type ProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type ProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }
  export type ProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    coin?: boolean | CoinDefaultArgs<ExtArgs>
  }

  export type $ProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proposal"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      coin: Prisma.$CoinPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      votesFor: number
      votesAgainst: number
      status: string
      createdAt: Date
      votingEnds: Date
      createdById: string
      coinId: string
    }, ExtArgs["result"]["proposal"]>
    composites: {}
  }

  type ProposalGetPayload<S extends boolean | null | undefined | ProposalDefaultArgs> = $Result.GetResult<Prisma.$ProposalPayload, S>

  type ProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProposalCountAggregateInputType | true
    }

  export interface ProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proposal'], meta: { name: 'Proposal' } }
    /**
     * Find zero or one Proposal that matches the filter.
     * @param {ProposalFindUniqueArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalFindUniqueArgs>(args: SelectSubset<T, ProposalFindUniqueArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalFindUniqueOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalFindFirstArgs>(args?: SelectSubset<T, ProposalFindFirstArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindFirstOrThrowArgs} args - Arguments to find a Proposal
     * @example
     * // Get one Proposal
     * const proposal = await prisma.proposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proposals
     * const proposals = await prisma.proposal.findMany()
     * 
     * // Get first 10 Proposals
     * const proposals = await prisma.proposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalWithIdOnly = await prisma.proposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalFindManyArgs>(args?: SelectSubset<T, ProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proposal.
     * @param {ProposalCreateArgs} args - Arguments to create a Proposal.
     * @example
     * // Create one Proposal
     * const Proposal = await prisma.proposal.create({
     *   data: {
     *     // ... data to create a Proposal
     *   }
     * })
     * 
     */
    create<T extends ProposalCreateArgs>(args: SelectSubset<T, ProposalCreateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proposals.
     * @param {ProposalCreateManyArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalCreateManyArgs>(args?: SelectSubset<T, ProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proposals and returns the data saved in the database.
     * @param {ProposalCreateManyAndReturnArgs} args - Arguments to create many Proposals.
     * @example
     * // Create many Proposals
     * const proposal = await prisma.proposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proposal.
     * @param {ProposalDeleteArgs} args - Arguments to delete one Proposal.
     * @example
     * // Delete one Proposal
     * const Proposal = await prisma.proposal.delete({
     *   where: {
     *     // ... filter to delete one Proposal
     *   }
     * })
     * 
     */
    delete<T extends ProposalDeleteArgs>(args: SelectSubset<T, ProposalDeleteArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proposal.
     * @param {ProposalUpdateArgs} args - Arguments to update one Proposal.
     * @example
     * // Update one Proposal
     * const proposal = await prisma.proposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalUpdateArgs>(args: SelectSubset<T, ProposalUpdateArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proposals.
     * @param {ProposalDeleteManyArgs} args - Arguments to filter Proposals to delete.
     * @example
     * // Delete a few Proposals
     * const { count } = await prisma.proposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalDeleteManyArgs>(args?: SelectSubset<T, ProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalUpdateManyArgs>(args: SelectSubset<T, ProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proposals and returns the data updated in the database.
     * @param {ProposalUpdateManyAndReturnArgs} args - Arguments to update many Proposals.
     * @example
     * // Update many Proposals
     * const proposal = await prisma.proposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proposals and only return the `id`
     * const proposalWithIdOnly = await prisma.proposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proposal.
     * @param {ProposalUpsertArgs} args - Arguments to update or create a Proposal.
     * @example
     * // Update or create a Proposal
     * const proposal = await prisma.proposal.upsert({
     *   create: {
     *     // ... data to create a Proposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proposal we want to update
     *   }
     * })
     */
    upsert<T extends ProposalUpsertArgs>(args: SelectSubset<T, ProposalUpsertArgs<ExtArgs>>): Prisma__ProposalClient<$Result.GetResult<Prisma.$ProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalCountArgs} args - Arguments to filter Proposals to count.
     * @example
     * // Count the number of Proposals
     * const count = await prisma.proposal.count({
     *   where: {
     *     // ... the filter for the Proposals we want to count
     *   }
     * })
    **/
    count<T extends ProposalCountArgs>(
      args?: Subset<T, ProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalAggregateArgs>(args: Subset<T, ProposalAggregateArgs>): Prisma.PrismaPromise<GetProposalAggregateType<T>>

    /**
     * Group by Proposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalGroupByArgs['orderBy'] }
        : { orderBy?: ProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proposal model
   */
  readonly fields: ProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coin<T extends CoinDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CoinDefaultArgs<ExtArgs>>): Prisma__CoinClient<$Result.GetResult<Prisma.$CoinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proposal model
   */
  interface ProposalFieldRefs {
    readonly id: FieldRef<"Proposal", 'String'>
    readonly title: FieldRef<"Proposal", 'String'>
    readonly description: FieldRef<"Proposal", 'String'>
    readonly votesFor: FieldRef<"Proposal", 'Int'>
    readonly votesAgainst: FieldRef<"Proposal", 'Int'>
    readonly status: FieldRef<"Proposal", 'String'>
    readonly createdAt: FieldRef<"Proposal", 'DateTime'>
    readonly votingEnds: FieldRef<"Proposal", 'DateTime'>
    readonly createdById: FieldRef<"Proposal", 'String'>
    readonly coinId: FieldRef<"Proposal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Proposal findUnique
   */
  export type ProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findUniqueOrThrow
   */
  export type ProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal findFirst
   */
  export type ProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findFirstOrThrow
   */
  export type ProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposal to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proposals.
     */
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal findMany
   */
  export type ProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter, which Proposals to fetch.
     */
    where?: ProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proposals to fetch.
     */
    orderBy?: ProposalOrderByWithRelationInput | ProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proposals.
     */
    cursor?: ProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proposals.
     */
    skip?: number
    distinct?: ProposalScalarFieldEnum | ProposalScalarFieldEnum[]
  }

  /**
   * Proposal create
   */
  export type ProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a Proposal.
     */
    data: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
  }

  /**
   * Proposal createMany
   */
  export type ProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proposal createManyAndReturn
   */
  export type ProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * The data used to create many Proposals.
     */
    data: ProposalCreateManyInput | ProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal update
   */
  export type ProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a Proposal.
     */
    data: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
    /**
     * Choose, which Proposal to update.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal updateMany
   */
  export type ProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to update.
     */
    limit?: number
  }

  /**
   * Proposal updateManyAndReturn
   */
  export type ProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * The data used to update Proposals.
     */
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyInput>
    /**
     * Filter which Proposals to update
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proposal upsert
   */
  export type ProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the Proposal to update in case it exists.
     */
    where: ProposalWhereUniqueInput
    /**
     * In case the Proposal found by the `where` argument doesn't exist, create a new Proposal with this data.
     */
    create: XOR<ProposalCreateInput, ProposalUncheckedCreateInput>
    /**
     * In case the Proposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalUpdateInput, ProposalUncheckedUpdateInput>
  }

  /**
   * Proposal delete
   */
  export type ProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
    /**
     * Filter which Proposal to delete.
     */
    where: ProposalWhereUniqueInput
  }

  /**
   * Proposal deleteMany
   */
  export type ProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proposals to delete
     */
    where?: ProposalWhereInput
    /**
     * Limit how many Proposals to delete.
     */
    limit?: number
  }

  /**
   * Proposal without action
   */
  export type ProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proposal
     */
    select?: ProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proposal
     */
    omit?: ProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    confirmedEmail: 'confirmedEmail',
    emailVerified: 'emailVerified',
    passwordHash: 'passwordHash',
    role: 'role',
    isVerified: 'isVerified',
    verificationToken: 'verificationToken',
    verificationTokenExpiresAt: 'verificationTokenExpiresAt',
    resetToken: 'resetToken',
    resetTokenExpiresAt: 'resetTokenExpiresAt',
    pictureUrl: 'pictureUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    referralCode: 'referralCode',
    referrerId: 'referrerId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CoinScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ticker: 'ticker',
    description: 'description',
    pictureUrl: 'pictureUrl',
    telegramLink: 'telegramLink',
    discordLink: 'discordLink',
    socialLinks: 'socialLinks',
    totalSupply: 'totalSupply',
    airdropAmount: 'airdropAmount',
    blockchain: 'blockchain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creatorId: 'creatorId',
    reputationScore: 'reputationScore',
    status: 'status',
    marketCap: 'marketCap'
  };

  export type CoinScalarFieldEnum = (typeof CoinScalarFieldEnum)[keyof typeof CoinScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    date: 'date',
    description: 'description',
    coinId: 'coinId'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const HashtagScalarFieldEnum: {
    id: 'id',
    tag: 'tag',
    usageCount: 'usageCount'
  };

  export type HashtagScalarFieldEnum = (typeof HashtagScalarFieldEnum)[keyof typeof HashtagScalarFieldEnum]


  export const BondingCurveScalarFieldEnum: {
    id: 'id',
    coinId: 'coinId',
    curveDetail: 'curveDetail',
    feeStructureId: 'feeStructureId',
    isCompleted: 'isCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BondingCurveScalarFieldEnum = (typeof BondingCurveScalarFieldEnum)[keyof typeof BondingCurveScalarFieldEnum]


  export const FeeStructureScalarFieldEnum: {
    id: 'id',
    tradeFee: 'tradeFee',
    memecoinFee: 'memecoinFee',
    feeDescription: 'feeDescription'
  };

  export type FeeStructureScalarFieldEnum = (typeof FeeStructureScalarFieldEnum)[keyof typeof FeeStructureScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coinId: 'coinId',
    proposalId: 'proposalId',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coinId: 'coinId',
    message: 'message',
    createdAt: 'createdAt',
    media: 'media',
    upvotes: 'upvotes',
    downvotes: 'downvotes'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coinId: 'coinId',
    message: 'message',
    createdAt: 'createdAt',
    upvotes: 'upvotes',
    downvotes: 'downvotes'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const ReputationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    score: 'score'
  };

  export type ReputationScalarFieldEnum = (typeof ReputationScalarFieldEnum)[keyof typeof ReputationScalarFieldEnum]


  export const WalletAddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    address: 'address',
    network: 'network',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WalletAddressScalarFieldEnum = (typeof WalletAddressScalarFieldEnum)[keyof typeof WalletAddressScalarFieldEnum]


  export const SocialAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    platform: 'platform',
    handle: 'handle',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialAccountScalarFieldEnum = (typeof SocialAccountScalarFieldEnum)[keyof typeof SocialAccountScalarFieldEnum]


  export const TokenHoldingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coinId: 'coinId',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokenHoldingScalarFieldEnum = (typeof TokenHoldingScalarFieldEnum)[keyof typeof TokenHoldingScalarFieldEnum]


  export const PriceHistoryScalarFieldEnum: {
    id: 'id',
    coinId: 'coinId',
    price: 'price',
    timestamp: 'timestamp'
  };

  export type PriceHistoryScalarFieldEnum = (typeof PriceHistoryScalarFieldEnum)[keyof typeof PriceHistoryScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    coinId: 'coinId',
    type: 'type',
    proposalId: 'proposalId',
    amount: 'amount',
    price: 'price',
    createdAt: 'createdAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const ProposalScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    votesFor: 'votesFor',
    votesAgainst: 'votesAgainst',
    status: 'status',
    createdAt: 'createdAt',
    votingEnds: 'votingEnds',
    createdById: 'createdById',
    coinId: 'coinId'
  };

  export type ProposalScalarFieldEnum = (typeof ProposalScalarFieldEnum)[keyof typeof ProposalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Blockchain'
   */
  export type EnumBlockchainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Blockchain'>
    


  /**
   * Reference to a field of type 'Blockchain[]'
   */
  export type ListEnumBlockchainFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Blockchain[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CoinStatus'
   */
  export type EnumCoinStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoinStatus'>
    


  /**
   * Reference to a field of type 'CoinStatus[]'
   */
  export type ListEnumCoinStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CoinStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    confirmedEmail?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    pictureUrl?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referralCode?: StringNullableFilter<"User"> | string | null
    referrerId?: StringNullableFilter<"User"> | string | null
    coinsCreated?: CoinListRelationFilter
    referrer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    walletAddresses?: WalletAddressListRelationFilter
    socialAccounts?: SocialAccountListRelationFilter
    tokenHoldings?: TokenHoldingListRelationFilter
    votes?: VoteListRelationFilter
    chatMessages?: ChatMessageListRelationFilter
    comments?: CommentsListRelationFilter
    reputation?: XOR<ReputationNullableScalarRelationFilter, ReputationWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    transactions?: TransactionListRelationFilter
    proposals?: ProposalListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    confirmedEmail?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpiresAt?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiresAt?: SortOrderInput | SortOrder
    pictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referrerId?: SortOrderInput | SortOrder
    coinsCreated?: CoinOrderByRelationAggregateInput
    referrer?: UserOrderByWithRelationInput
    referrals?: UserOrderByRelationAggregateInput
    walletAddresses?: WalletAddressOrderByRelationAggregateInput
    socialAccounts?: SocialAccountOrderByRelationAggregateInput
    tokenHoldings?: TokenHoldingOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
    chatMessages?: ChatMessageOrderByRelationAggregateInput
    comments?: CommentsOrderByRelationAggregateInput
    reputation?: ReputationOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    proposals?: ProposalOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    confirmedEmail?: string
    verificationToken?: string
    resetToken?: string
    referralCode?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    verificationTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    resetTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    pictureUrl?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referrerId?: StringNullableFilter<"User"> | string | null
    coinsCreated?: CoinListRelationFilter
    referrer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    referrals?: UserListRelationFilter
    walletAddresses?: WalletAddressListRelationFilter
    socialAccounts?: SocialAccountListRelationFilter
    tokenHoldings?: TokenHoldingListRelationFilter
    votes?: VoteListRelationFilter
    chatMessages?: ChatMessageListRelationFilter
    comments?: CommentsListRelationFilter
    reputation?: XOR<ReputationNullableScalarRelationFilter, ReputationWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    transactions?: TransactionListRelationFilter
    proposals?: ProposalListRelationFilter
  }, "id" | "username" | "email" | "confirmedEmail" | "verificationToken" | "resetToken" | "referralCode">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    confirmedEmail?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    verificationTokenExpiresAt?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiresAt?: SortOrderInput | SortOrder
    pictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrderInput | SortOrder
    referrerId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    confirmedEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    verificationTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    pictureUrl?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    referralCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    referrerId?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type CoinWhereInput = {
    AND?: CoinWhereInput | CoinWhereInput[]
    OR?: CoinWhereInput[]
    NOT?: CoinWhereInput | CoinWhereInput[]
    id?: StringFilter<"Coin"> | string
    name?: StringFilter<"Coin"> | string
    ticker?: StringFilter<"Coin"> | string
    description?: StringNullableFilter<"Coin"> | string | null
    pictureUrl?: StringFilter<"Coin"> | string
    telegramLink?: StringFilter<"Coin"> | string
    discordLink?: StringFilter<"Coin"> | string
    socialLinks?: JsonNullableFilter<"Coin">
    totalSupply?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    blockchain?: EnumBlockchainNullableFilter<"Coin"> | $Enums.Blockchain | null
    createdAt?: DateTimeFilter<"Coin"> | Date | string
    updatedAt?: DateTimeFilter<"Coin"> | Date | string
    creatorId?: StringFilter<"Coin"> | string
    reputationScore?: IntFilter<"Coin"> | number
    status?: EnumCoinStatusFilter<"Coin"> | $Enums.CoinStatus
    marketCap?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    chatMessages?: ChatMessageListRelationFilter
    comments?: CommentsListRelationFilter
    bondingCurve?: XOR<BondingCurveNullableScalarRelationFilter, BondingCurveWhereInput> | null
    votes?: VoteListRelationFilter
    tokenHoldings?: TokenHoldingListRelationFilter
    milestones?: MilestoneListRelationFilter
    hashtags?: HashtagListRelationFilter
    priceHistory?: PriceHistoryListRelationFilter
    transaction?: TransactionListRelationFilter
    proposals?: ProposalListRelationFilter
  }

  export type CoinOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    description?: SortOrderInput | SortOrder
    pictureUrl?: SortOrder
    telegramLink?: SortOrder
    discordLink?: SortOrder
    socialLinks?: SortOrderInput | SortOrder
    totalSupply?: SortOrder
    airdropAmount?: SortOrder
    blockchain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    reputationScore?: SortOrder
    status?: SortOrder
    marketCap?: SortOrder
    creator?: UserOrderByWithRelationInput
    chatMessages?: ChatMessageOrderByRelationAggregateInput
    comments?: CommentsOrderByRelationAggregateInput
    bondingCurve?: BondingCurveOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
    tokenHoldings?: TokenHoldingOrderByRelationAggregateInput
    milestones?: MilestoneOrderByRelationAggregateInput
    hashtags?: HashtagOrderByRelationAggregateInput
    priceHistory?: PriceHistoryOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
    proposals?: ProposalOrderByRelationAggregateInput
  }

  export type CoinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CoinWhereInput | CoinWhereInput[]
    OR?: CoinWhereInput[]
    NOT?: CoinWhereInput | CoinWhereInput[]
    name?: StringFilter<"Coin"> | string
    ticker?: StringFilter<"Coin"> | string
    description?: StringNullableFilter<"Coin"> | string | null
    pictureUrl?: StringFilter<"Coin"> | string
    telegramLink?: StringFilter<"Coin"> | string
    discordLink?: StringFilter<"Coin"> | string
    socialLinks?: JsonNullableFilter<"Coin">
    totalSupply?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    blockchain?: EnumBlockchainNullableFilter<"Coin"> | $Enums.Blockchain | null
    createdAt?: DateTimeFilter<"Coin"> | Date | string
    updatedAt?: DateTimeFilter<"Coin"> | Date | string
    creatorId?: StringFilter<"Coin"> | string
    reputationScore?: IntFilter<"Coin"> | number
    status?: EnumCoinStatusFilter<"Coin"> | $Enums.CoinStatus
    marketCap?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    chatMessages?: ChatMessageListRelationFilter
    comments?: CommentsListRelationFilter
    bondingCurve?: XOR<BondingCurveNullableScalarRelationFilter, BondingCurveWhereInput> | null
    votes?: VoteListRelationFilter
    tokenHoldings?: TokenHoldingListRelationFilter
    milestones?: MilestoneListRelationFilter
    hashtags?: HashtagListRelationFilter
    priceHistory?: PriceHistoryListRelationFilter
    transaction?: TransactionListRelationFilter
    proposals?: ProposalListRelationFilter
  }, "id">

  export type CoinOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    description?: SortOrderInput | SortOrder
    pictureUrl?: SortOrder
    telegramLink?: SortOrder
    discordLink?: SortOrder
    socialLinks?: SortOrderInput | SortOrder
    totalSupply?: SortOrder
    airdropAmount?: SortOrder
    blockchain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    reputationScore?: SortOrder
    status?: SortOrder
    marketCap?: SortOrder
    _count?: CoinCountOrderByAggregateInput
    _avg?: CoinAvgOrderByAggregateInput
    _max?: CoinMaxOrderByAggregateInput
    _min?: CoinMinOrderByAggregateInput
    _sum?: CoinSumOrderByAggregateInput
  }

  export type CoinScalarWhereWithAggregatesInput = {
    AND?: CoinScalarWhereWithAggregatesInput | CoinScalarWhereWithAggregatesInput[]
    OR?: CoinScalarWhereWithAggregatesInput[]
    NOT?: CoinScalarWhereWithAggregatesInput | CoinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coin"> | string
    name?: StringWithAggregatesFilter<"Coin"> | string
    ticker?: StringWithAggregatesFilter<"Coin"> | string
    description?: StringNullableWithAggregatesFilter<"Coin"> | string | null
    pictureUrl?: StringWithAggregatesFilter<"Coin"> | string
    telegramLink?: StringWithAggregatesFilter<"Coin"> | string
    discordLink?: StringWithAggregatesFilter<"Coin"> | string
    socialLinks?: JsonNullableWithAggregatesFilter<"Coin">
    totalSupply?: DecimalWithAggregatesFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalWithAggregatesFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    blockchain?: EnumBlockchainNullableWithAggregatesFilter<"Coin"> | $Enums.Blockchain | null
    createdAt?: DateTimeWithAggregatesFilter<"Coin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coin"> | Date | string
    creatorId?: StringWithAggregatesFilter<"Coin"> | string
    reputationScore?: IntWithAggregatesFilter<"Coin"> | number
    status?: EnumCoinStatusWithAggregatesFilter<"Coin"> | $Enums.CoinStatus
    marketCap?: DecimalWithAggregatesFilter<"Coin"> | Decimal | DecimalJsLike | number | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    date?: DateTimeFilter<"Milestone"> | Date | string
    description?: StringFilter<"Milestone"> | string
    coinId?: StringFilter<"Milestone"> | string
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    coinId?: SortOrder
    coin?: CoinOrderByWithRelationInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    date?: DateTimeFilter<"Milestone"> | Date | string
    description?: StringFilter<"Milestone"> | string
    coinId?: StringFilter<"Milestone"> | string
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    coinId?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    date?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    description?: StringWithAggregatesFilter<"Milestone"> | string
    coinId?: StringWithAggregatesFilter<"Milestone"> | string
  }

  export type HashtagWhereInput = {
    AND?: HashtagWhereInput | HashtagWhereInput[]
    OR?: HashtagWhereInput[]
    NOT?: HashtagWhereInput | HashtagWhereInput[]
    id?: StringFilter<"Hashtag"> | string
    tag?: StringFilter<"Hashtag"> | string
    usageCount?: IntFilter<"Hashtag"> | number
    coins?: CoinListRelationFilter
  }

  export type HashtagOrderByWithRelationInput = {
    id?: SortOrder
    tag?: SortOrder
    usageCount?: SortOrder
    coins?: CoinOrderByRelationAggregateInput
  }

  export type HashtagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tag?: string
    AND?: HashtagWhereInput | HashtagWhereInput[]
    OR?: HashtagWhereInput[]
    NOT?: HashtagWhereInput | HashtagWhereInput[]
    usageCount?: IntFilter<"Hashtag"> | number
    coins?: CoinListRelationFilter
  }, "id" | "tag">

  export type HashtagOrderByWithAggregationInput = {
    id?: SortOrder
    tag?: SortOrder
    usageCount?: SortOrder
    _count?: HashtagCountOrderByAggregateInput
    _avg?: HashtagAvgOrderByAggregateInput
    _max?: HashtagMaxOrderByAggregateInput
    _min?: HashtagMinOrderByAggregateInput
    _sum?: HashtagSumOrderByAggregateInput
  }

  export type HashtagScalarWhereWithAggregatesInput = {
    AND?: HashtagScalarWhereWithAggregatesInput | HashtagScalarWhereWithAggregatesInput[]
    OR?: HashtagScalarWhereWithAggregatesInput[]
    NOT?: HashtagScalarWhereWithAggregatesInput | HashtagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Hashtag"> | string
    tag?: StringWithAggregatesFilter<"Hashtag"> | string
    usageCount?: IntWithAggregatesFilter<"Hashtag"> | number
  }

  export type BondingCurveWhereInput = {
    AND?: BondingCurveWhereInput | BondingCurveWhereInput[]
    OR?: BondingCurveWhereInput[]
    NOT?: BondingCurveWhereInput | BondingCurveWhereInput[]
    id?: StringFilter<"BondingCurve"> | string
    coinId?: StringFilter<"BondingCurve"> | string
    curveDetail?: JsonFilter<"BondingCurve">
    feeStructureId?: StringNullableFilter<"BondingCurve"> | string | null
    isCompleted?: BoolFilter<"BondingCurve"> | boolean
    createdAt?: DateTimeFilter<"BondingCurve"> | Date | string
    updatedAt?: DateTimeFilter<"BondingCurve"> | Date | string
    feeStructure?: XOR<FeeStructureNullableScalarRelationFilter, FeeStructureWhereInput> | null
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type BondingCurveOrderByWithRelationInput = {
    id?: SortOrder
    coinId?: SortOrder
    curveDetail?: SortOrder
    feeStructureId?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    feeStructure?: FeeStructureOrderByWithRelationInput
    coin?: CoinOrderByWithRelationInput
  }

  export type BondingCurveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    coinId?: string
    feeStructureId?: string
    AND?: BondingCurveWhereInput | BondingCurveWhereInput[]
    OR?: BondingCurveWhereInput[]
    NOT?: BondingCurveWhereInput | BondingCurveWhereInput[]
    curveDetail?: JsonFilter<"BondingCurve">
    isCompleted?: BoolFilter<"BondingCurve"> | boolean
    createdAt?: DateTimeFilter<"BondingCurve"> | Date | string
    updatedAt?: DateTimeFilter<"BondingCurve"> | Date | string
    feeStructure?: XOR<FeeStructureNullableScalarRelationFilter, FeeStructureWhereInput> | null
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id" | "coinId" | "feeStructureId">

  export type BondingCurveOrderByWithAggregationInput = {
    id?: SortOrder
    coinId?: SortOrder
    curveDetail?: SortOrder
    feeStructureId?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BondingCurveCountOrderByAggregateInput
    _max?: BondingCurveMaxOrderByAggregateInput
    _min?: BondingCurveMinOrderByAggregateInput
  }

  export type BondingCurveScalarWhereWithAggregatesInput = {
    AND?: BondingCurveScalarWhereWithAggregatesInput | BondingCurveScalarWhereWithAggregatesInput[]
    OR?: BondingCurveScalarWhereWithAggregatesInput[]
    NOT?: BondingCurveScalarWhereWithAggregatesInput | BondingCurveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BondingCurve"> | string
    coinId?: StringWithAggregatesFilter<"BondingCurve"> | string
    curveDetail?: JsonWithAggregatesFilter<"BondingCurve">
    feeStructureId?: StringNullableWithAggregatesFilter<"BondingCurve"> | string | null
    isCompleted?: BoolWithAggregatesFilter<"BondingCurve"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BondingCurve"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BondingCurve"> | Date | string
  }

  export type FeeStructureWhereInput = {
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    id?: StringFilter<"FeeStructure"> | string
    tradeFee?: FloatFilter<"FeeStructure"> | number
    memecoinFee?: FloatFilter<"FeeStructure"> | number
    feeDescription?: StringFilter<"FeeStructure"> | string
    bondingCurve?: XOR<BondingCurveNullableScalarRelationFilter, BondingCurveWhereInput> | null
  }

  export type FeeStructureOrderByWithRelationInput = {
    id?: SortOrder
    tradeFee?: SortOrder
    memecoinFee?: SortOrder
    feeDescription?: SortOrder
    bondingCurve?: BondingCurveOrderByWithRelationInput
  }

  export type FeeStructureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeStructureWhereInput | FeeStructureWhereInput[]
    OR?: FeeStructureWhereInput[]
    NOT?: FeeStructureWhereInput | FeeStructureWhereInput[]
    tradeFee?: FloatFilter<"FeeStructure"> | number
    memecoinFee?: FloatFilter<"FeeStructure"> | number
    feeDescription?: StringFilter<"FeeStructure"> | string
    bondingCurve?: XOR<BondingCurveNullableScalarRelationFilter, BondingCurveWhereInput> | null
  }, "id">

  export type FeeStructureOrderByWithAggregationInput = {
    id?: SortOrder
    tradeFee?: SortOrder
    memecoinFee?: SortOrder
    feeDescription?: SortOrder
    _count?: FeeStructureCountOrderByAggregateInput
    _avg?: FeeStructureAvgOrderByAggregateInput
    _max?: FeeStructureMaxOrderByAggregateInput
    _min?: FeeStructureMinOrderByAggregateInput
    _sum?: FeeStructureSumOrderByAggregateInput
  }

  export type FeeStructureScalarWhereWithAggregatesInput = {
    AND?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    OR?: FeeStructureScalarWhereWithAggregatesInput[]
    NOT?: FeeStructureScalarWhereWithAggregatesInput | FeeStructureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeStructure"> | string
    tradeFee?: FloatWithAggregatesFilter<"FeeStructure"> | number
    memecoinFee?: FloatWithAggregatesFilter<"FeeStructure"> | number
    feeDescription?: StringWithAggregatesFilter<"FeeStructure"> | string
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    coinId?: StringFilter<"Vote"> | string
    proposalId?: StringNullableFilter<"Vote"> | string | null
    value?: IntFilter<"Vote"> | number
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coin?: CoinOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    userId?: StringFilter<"Vote"> | string
    coinId?: StringFilter<"Vote"> | string
    proposalId?: StringNullableFilter<"Vote"> | string | null
    value?: IntFilter<"Vote"> | number
    createdAt?: DateTimeFilter<"Vote"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _avg?: VoteAvgOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
    _sum?: VoteSumOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    userId?: StringWithAggregatesFilter<"Vote"> | string
    coinId?: StringWithAggregatesFilter<"Vote"> | string
    proposalId?: StringNullableWithAggregatesFilter<"Vote"> | string | null
    value?: IntWithAggregatesFilter<"Vote"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Vote"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    userId?: StringFilter<"ChatMessage"> | string
    coinId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    media?: StringNullableFilter<"ChatMessage"> | string | null
    upvotes?: IntFilter<"ChatMessage"> | number
    downvotes?: IntFilter<"ChatMessage"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    media?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    user?: UserOrderByWithRelationInput
    coin?: CoinOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    userId?: StringFilter<"ChatMessage"> | string
    coinId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    media?: StringNullableFilter<"ChatMessage"> | string | null
    upvotes?: IntFilter<"ChatMessage"> | number
    downvotes?: IntFilter<"ChatMessage"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    media?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _avg?: ChatMessageAvgOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
    _sum?: ChatMessageSumOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    userId?: StringWithAggregatesFilter<"ChatMessage"> | string
    coinId?: StringWithAggregatesFilter<"ChatMessage"> | string
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    media?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    upvotes?: IntWithAggregatesFilter<"ChatMessage"> | number
    downvotes?: IntWithAggregatesFilter<"ChatMessage"> | number
  }

  export type CommentsWhereInput = {
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    id?: StringFilter<"Comments"> | string
    userId?: StringFilter<"Comments"> | string
    coinId?: StringFilter<"Comments"> | string
    message?: StringFilter<"Comments"> | string
    createdAt?: DateTimeFilter<"Comments"> | Date | string
    upvotes?: IntFilter<"Comments"> | number
    downvotes?: IntFilter<"Comments"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type CommentsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    user?: UserOrderByWithRelationInput
    coin?: CoinOrderByWithRelationInput
  }

  export type CommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentsWhereInput | CommentsWhereInput[]
    OR?: CommentsWhereInput[]
    NOT?: CommentsWhereInput | CommentsWhereInput[]
    userId?: StringFilter<"Comments"> | string
    coinId?: StringFilter<"Comments"> | string
    message?: StringFilter<"Comments"> | string
    createdAt?: DateTimeFilter<"Comments"> | Date | string
    upvotes?: IntFilter<"Comments"> | number
    downvotes?: IntFilter<"Comments"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id">

  export type CommentsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    _count?: CommentsCountOrderByAggregateInput
    _avg?: CommentsAvgOrderByAggregateInput
    _max?: CommentsMaxOrderByAggregateInput
    _min?: CommentsMinOrderByAggregateInput
    _sum?: CommentsSumOrderByAggregateInput
  }

  export type CommentsScalarWhereWithAggregatesInput = {
    AND?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    OR?: CommentsScalarWhereWithAggregatesInput[]
    NOT?: CommentsScalarWhereWithAggregatesInput | CommentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comments"> | string
    userId?: StringWithAggregatesFilter<"Comments"> | string
    coinId?: StringWithAggregatesFilter<"Comments"> | string
    message?: StringWithAggregatesFilter<"Comments"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comments"> | Date | string
    upvotes?: IntWithAggregatesFilter<"Comments"> | number
    downvotes?: IntWithAggregatesFilter<"Comments"> | number
  }

  export type ReputationWhereInput = {
    AND?: ReputationWhereInput | ReputationWhereInput[]
    OR?: ReputationWhereInput[]
    NOT?: ReputationWhereInput | ReputationWhereInput[]
    id?: StringFilter<"Reputation"> | string
    userId?: StringFilter<"Reputation"> | string
    score?: IntFilter<"Reputation"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReputationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ReputationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ReputationWhereInput | ReputationWhereInput[]
    OR?: ReputationWhereInput[]
    NOT?: ReputationWhereInput | ReputationWhereInput[]
    score?: IntFilter<"Reputation"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ReputationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
    _count?: ReputationCountOrderByAggregateInput
    _avg?: ReputationAvgOrderByAggregateInput
    _max?: ReputationMaxOrderByAggregateInput
    _min?: ReputationMinOrderByAggregateInput
    _sum?: ReputationSumOrderByAggregateInput
  }

  export type ReputationScalarWhereWithAggregatesInput = {
    AND?: ReputationScalarWhereWithAggregatesInput | ReputationScalarWhereWithAggregatesInput[]
    OR?: ReputationScalarWhereWithAggregatesInput[]
    NOT?: ReputationScalarWhereWithAggregatesInput | ReputationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reputation"> | string
    userId?: StringWithAggregatesFilter<"Reputation"> | string
    score?: IntWithAggregatesFilter<"Reputation"> | number
  }

  export type WalletAddressWhereInput = {
    AND?: WalletAddressWhereInput | WalletAddressWhereInput[]
    OR?: WalletAddressWhereInput[]
    NOT?: WalletAddressWhereInput | WalletAddressWhereInput[]
    id?: StringFilter<"WalletAddress"> | string
    userId?: StringFilter<"WalletAddress"> | string
    address?: StringFilter<"WalletAddress"> | string
    network?: StringFilter<"WalletAddress"> | string
    createdAt?: DateTimeFilter<"WalletAddress"> | Date | string
    updatedAt?: DateTimeFilter<"WalletAddress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WalletAddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    network?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WalletAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_network?: WalletAddressUserId_networkCompoundUniqueInput
    AND?: WalletAddressWhereInput | WalletAddressWhereInput[]
    OR?: WalletAddressWhereInput[]
    NOT?: WalletAddressWhereInput | WalletAddressWhereInput[]
    userId?: StringFilter<"WalletAddress"> | string
    address?: StringFilter<"WalletAddress"> | string
    network?: StringFilter<"WalletAddress"> | string
    createdAt?: DateTimeFilter<"WalletAddress"> | Date | string
    updatedAt?: DateTimeFilter<"WalletAddress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_network">

  export type WalletAddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    network?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletAddressCountOrderByAggregateInput
    _max?: WalletAddressMaxOrderByAggregateInput
    _min?: WalletAddressMinOrderByAggregateInput
  }

  export type WalletAddressScalarWhereWithAggregatesInput = {
    AND?: WalletAddressScalarWhereWithAggregatesInput | WalletAddressScalarWhereWithAggregatesInput[]
    OR?: WalletAddressScalarWhereWithAggregatesInput[]
    NOT?: WalletAddressScalarWhereWithAggregatesInput | WalletAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletAddress"> | string
    userId?: StringWithAggregatesFilter<"WalletAddress"> | string
    address?: StringWithAggregatesFilter<"WalletAddress"> | string
    network?: StringWithAggregatesFilter<"WalletAddress"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WalletAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WalletAddress"> | Date | string
  }

  export type SocialAccountWhereInput = {
    AND?: SocialAccountWhereInput | SocialAccountWhereInput[]
    OR?: SocialAccountWhereInput[]
    NOT?: SocialAccountWhereInput | SocialAccountWhereInput[]
    id?: StringFilter<"SocialAccount"> | string
    userId?: StringFilter<"SocialAccount"> | string
    platform?: StringFilter<"SocialAccount"> | string
    handle?: StringFilter<"SocialAccount"> | string
    createdAt?: DateTimeFilter<"SocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SocialAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SocialAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SocialAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_platform?: SocialAccountUserId_platformCompoundUniqueInput
    AND?: SocialAccountWhereInput | SocialAccountWhereInput[]
    OR?: SocialAccountWhereInput[]
    NOT?: SocialAccountWhereInput | SocialAccountWhereInput[]
    userId?: StringFilter<"SocialAccount"> | string
    platform?: StringFilter<"SocialAccount"> | string
    handle?: StringFilter<"SocialAccount"> | string
    createdAt?: DateTimeFilter<"SocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SocialAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_platform">

  export type SocialAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialAccountCountOrderByAggregateInput
    _max?: SocialAccountMaxOrderByAggregateInput
    _min?: SocialAccountMinOrderByAggregateInput
  }

  export type SocialAccountScalarWhereWithAggregatesInput = {
    AND?: SocialAccountScalarWhereWithAggregatesInput | SocialAccountScalarWhereWithAggregatesInput[]
    OR?: SocialAccountScalarWhereWithAggregatesInput[]
    NOT?: SocialAccountScalarWhereWithAggregatesInput | SocialAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialAccount"> | string
    userId?: StringWithAggregatesFilter<"SocialAccount"> | string
    platform?: StringWithAggregatesFilter<"SocialAccount"> | string
    handle?: StringWithAggregatesFilter<"SocialAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SocialAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialAccount"> | Date | string
  }

  export type TokenHoldingWhereInput = {
    AND?: TokenHoldingWhereInput | TokenHoldingWhereInput[]
    OR?: TokenHoldingWhereInput[]
    NOT?: TokenHoldingWhereInput | TokenHoldingWhereInput[]
    id?: StringFilter<"TokenHolding"> | string
    userId?: StringFilter<"TokenHolding"> | string
    coinId?: StringFilter<"TokenHolding"> | string
    amount?: DecimalFilter<"TokenHolding"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TokenHolding"> | Date | string
    updatedAt?: DateTimeFilter<"TokenHolding"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type TokenHoldingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coin?: CoinOrderByWithRelationInput
  }

  export type TokenHoldingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_coin_unique?: TokenHoldingUser_coin_uniqueCompoundUniqueInput
    AND?: TokenHoldingWhereInput | TokenHoldingWhereInput[]
    OR?: TokenHoldingWhereInput[]
    NOT?: TokenHoldingWhereInput | TokenHoldingWhereInput[]
    userId?: StringFilter<"TokenHolding"> | string
    coinId?: StringFilter<"TokenHolding"> | string
    amount?: DecimalFilter<"TokenHolding"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TokenHolding"> | Date | string
    updatedAt?: DateTimeFilter<"TokenHolding"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id" | "user_coin_unique">

  export type TokenHoldingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TokenHoldingCountOrderByAggregateInput
    _avg?: TokenHoldingAvgOrderByAggregateInput
    _max?: TokenHoldingMaxOrderByAggregateInput
    _min?: TokenHoldingMinOrderByAggregateInput
    _sum?: TokenHoldingSumOrderByAggregateInput
  }

  export type TokenHoldingScalarWhereWithAggregatesInput = {
    AND?: TokenHoldingScalarWhereWithAggregatesInput | TokenHoldingScalarWhereWithAggregatesInput[]
    OR?: TokenHoldingScalarWhereWithAggregatesInput[]
    NOT?: TokenHoldingScalarWhereWithAggregatesInput | TokenHoldingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TokenHolding"> | string
    userId?: StringWithAggregatesFilter<"TokenHolding"> | string
    coinId?: StringWithAggregatesFilter<"TokenHolding"> | string
    amount?: DecimalWithAggregatesFilter<"TokenHolding"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"TokenHolding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TokenHolding"> | Date | string
  }

  export type PriceHistoryWhereInput = {
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    coinId?: StringFilter<"PriceHistory"> | string
    price?: DecimalFilter<"PriceHistory"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFilter<"PriceHistory"> | Date | string
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type PriceHistoryOrderByWithRelationInput = {
    id?: SortOrder
    coinId?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    coin?: CoinOrderByWithRelationInput
  }

  export type PriceHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    OR?: PriceHistoryWhereInput[]
    NOT?: PriceHistoryWhereInput | PriceHistoryWhereInput[]
    coinId?: StringFilter<"PriceHistory"> | string
    price?: DecimalFilter<"PriceHistory"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFilter<"PriceHistory"> | Date | string
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id">

  export type PriceHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    coinId?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
    _count?: PriceHistoryCountOrderByAggregateInput
    _avg?: PriceHistoryAvgOrderByAggregateInput
    _max?: PriceHistoryMaxOrderByAggregateInput
    _min?: PriceHistoryMinOrderByAggregateInput
    _sum?: PriceHistorySumOrderByAggregateInput
  }

  export type PriceHistoryScalarWhereWithAggregatesInput = {
    AND?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    OR?: PriceHistoryScalarWhereWithAggregatesInput[]
    NOT?: PriceHistoryScalarWhereWithAggregatesInput | PriceHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceHistory"> | string
    coinId?: StringWithAggregatesFilter<"PriceHistory"> | string
    price?: DecimalWithAggregatesFilter<"PriceHistory"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeWithAggregatesFilter<"PriceHistory"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    coinId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    proposalId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    type?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    amount?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    coin?: CoinOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    coinId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    proposalId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    type?: SortOrder
    proposalId?: SortOrderInput | SortOrder
    amount?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    coinId?: StringWithAggregatesFilter<"Transaction"> | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    proposalId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    price?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type ProposalWhereInput = {
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    id?: StringFilter<"Proposal"> | string
    title?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    votesFor?: IntFilter<"Proposal"> | number
    votesAgainst?: IntFilter<"Proposal"> | number
    status?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    votingEnds?: DateTimeFilter<"Proposal"> | Date | string
    createdById?: StringFilter<"Proposal"> | string
    coinId?: StringFilter<"Proposal"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }

  export type ProposalOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    votesFor?: SortOrder
    votesAgainst?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    votingEnds?: SortOrder
    createdById?: SortOrder
    coinId?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    coin?: CoinOrderByWithRelationInput
  }

  export type ProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalWhereInput | ProposalWhereInput[]
    OR?: ProposalWhereInput[]
    NOT?: ProposalWhereInput | ProposalWhereInput[]
    title?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    votesFor?: IntFilter<"Proposal"> | number
    votesAgainst?: IntFilter<"Proposal"> | number
    status?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    votingEnds?: DateTimeFilter<"Proposal"> | Date | string
    createdById?: StringFilter<"Proposal"> | string
    coinId?: StringFilter<"Proposal"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    coin?: XOR<CoinScalarRelationFilter, CoinWhereInput>
  }, "id">

  export type ProposalOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    votesFor?: SortOrder
    votesAgainst?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    votingEnds?: SortOrder
    createdById?: SortOrder
    coinId?: SortOrder
    _count?: ProposalCountOrderByAggregateInput
    _avg?: ProposalAvgOrderByAggregateInput
    _max?: ProposalMaxOrderByAggregateInput
    _min?: ProposalMinOrderByAggregateInput
    _sum?: ProposalSumOrderByAggregateInput
  }

  export type ProposalScalarWhereWithAggregatesInput = {
    AND?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    OR?: ProposalScalarWhereWithAggregatesInput[]
    NOT?: ProposalScalarWhereWithAggregatesInput | ProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proposal"> | string
    title?: StringWithAggregatesFilter<"Proposal"> | string
    description?: StringWithAggregatesFilter<"Proposal"> | string
    votesFor?: IntWithAggregatesFilter<"Proposal"> | number
    votesAgainst?: IntWithAggregatesFilter<"Proposal"> | number
    status?: StringWithAggregatesFilter<"Proposal"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    votingEnds?: DateTimeWithAggregatesFilter<"Proposal"> | Date | string
    createdById?: StringWithAggregatesFilter<"Proposal"> | string
    coinId?: StringWithAggregatesFilter<"Proposal"> | string
  }

  export type UserCreateInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CoinCreateInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type CoinCreateManyInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
  }

  export type CoinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type CoinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type MilestoneCreateInput = {
    id?: string
    date: Date | string
    description: string
    coin: CoinCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    date: Date | string
    description: string
    coinId: string
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    coin?: CoinUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    date: Date | string
    description: string
    coinId: string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
  }

  export type HashtagCreateInput = {
    id?: string
    tag: string
    usageCount?: number
    coins?: CoinCreateNestedManyWithoutHashtagsInput
  }

  export type HashtagUncheckedCreateInput = {
    id?: string
    tag: string
    usageCount?: number
    coins?: CoinUncheckedCreateNestedManyWithoutHashtagsInput
  }

  export type HashtagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    coins?: CoinUpdateManyWithoutHashtagsNestedInput
  }

  export type HashtagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    coins?: CoinUncheckedUpdateManyWithoutHashtagsNestedInput
  }

  export type HashtagCreateManyInput = {
    id?: string
    tag: string
    usageCount?: number
  }

  export type HashtagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type HashtagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type BondingCurveCreateInput = {
    id?: string
    curveDetail: JsonNullValueInput | InputJsonValue
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feeStructure?: FeeStructureCreateNestedOneWithoutBondingCurveInput
    coin: CoinCreateNestedOneWithoutBondingCurveInput
  }

  export type BondingCurveUncheckedCreateInput = {
    id?: string
    coinId: string
    curveDetail: JsonNullValueInput | InputJsonValue
    feeStructureId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BondingCurveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeStructure?: FeeStructureUpdateOneWithoutBondingCurveNestedInput
    coin?: CoinUpdateOneRequiredWithoutBondingCurveNestedInput
  }

  export type BondingCurveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BondingCurveCreateManyInput = {
    id?: string
    coinId: string
    curveDetail: JsonNullValueInput | InputJsonValue
    feeStructureId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BondingCurveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BondingCurveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeStructureCreateInput = {
    id?: string
    tradeFee: number
    memecoinFee: number
    feeDescription: string
    bondingCurve?: BondingCurveCreateNestedOneWithoutFeeStructureInput
  }

  export type FeeStructureUncheckedCreateInput = {
    id?: string
    tradeFee: number
    memecoinFee: number
    feeDescription: string
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutFeeStructureInput
  }

  export type FeeStructureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeFee?: FloatFieldUpdateOperationsInput | number
    memecoinFee?: FloatFieldUpdateOperationsInput | number
    feeDescription?: StringFieldUpdateOperationsInput | string
    bondingCurve?: BondingCurveUpdateOneWithoutFeeStructureNestedInput
  }

  export type FeeStructureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeFee?: FloatFieldUpdateOperationsInput | number
    memecoinFee?: FloatFieldUpdateOperationsInput | number
    feeDescription?: StringFieldUpdateOperationsInput | string
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutFeeStructureNestedInput
  }

  export type FeeStructureCreateManyInput = {
    id?: string
    tradeFee: number
    memecoinFee: number
    feeDescription: string
  }

  export type FeeStructureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeFee?: FloatFieldUpdateOperationsInput | number
    memecoinFee?: FloatFieldUpdateOperationsInput | number
    feeDescription?: StringFieldUpdateOperationsInput | string
  }

  export type FeeStructureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeFee?: FloatFieldUpdateOperationsInput | number
    memecoinFee?: FloatFieldUpdateOperationsInput | number
    feeDescription?: StringFieldUpdateOperationsInput | string
  }

  export type VoteCreateInput = {
    id?: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutVotesInput
    coin: CoinCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    userId: string
    coinId: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
  }

  export type VoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVotesNestedInput
    coin?: CoinUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteCreateManyInput = {
    id?: string
    userId: string
    coinId: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
  }

  export type VoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
    user: UserCreateNestedOneWithoutChatMessagesInput
    coin: CoinCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    userId: string
    coinId: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutChatMessagesNestedInput
    coin?: CoinUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    userId: string
    coinId: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentsCreateInput = {
    id?: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
    user: UserCreateNestedOneWithoutCommentsInput
    coin: CoinCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateInput = {
    id?: string
    userId: string
    coinId: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
  }

  export type CommentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    coin?: CoinUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentsCreateManyInput = {
    id?: string
    userId: string
    coinId: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
  }

  export type CommentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type ReputationCreateInput = {
    id?: string
    score?: number
    user: UserCreateNestedOneWithoutReputationInput
  }

  export type ReputationUncheckedCreateInput = {
    id?: string
    userId: string
    score?: number
  }

  export type ReputationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutReputationNestedInput
  }

  export type ReputationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
  }

  export type ReputationCreateManyInput = {
    id?: string
    userId: string
    score?: number
  }

  export type ReputationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
  }

  export type ReputationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
  }

  export type WalletAddressCreateInput = {
    id?: string
    address: string
    network: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWalletAddressesInput
  }

  export type WalletAddressUncheckedCreateInput = {
    id?: string
    userId: string
    address: string
    network: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWalletAddressesNestedInput
  }

  export type WalletAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletAddressCreateManyInput = {
    id?: string
    userId: string
    address: string
    network: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAccountCreateInput = {
    id?: string
    platform: string
    handle: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialAccountsInput
  }

  export type SocialAccountUncheckedCreateInput = {
    id?: string
    userId: string
    platform: string
    handle: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialAccountsNestedInput
  }

  export type SocialAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAccountCreateManyInput = {
    id?: string
    userId: string
    platform: string
    handle: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenHoldingCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTokenHoldingsInput
    coin: CoinCreateNestedOneWithoutTokenHoldingsInput
  }

  export type TokenHoldingUncheckedCreateInput = {
    id?: string
    userId: string
    coinId: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenHoldingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTokenHoldingsNestedInput
    coin?: CoinUpdateOneRequiredWithoutTokenHoldingsNestedInput
  }

  export type TokenHoldingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenHoldingCreateManyInput = {
    id?: string
    userId: string
    coinId: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenHoldingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenHoldingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
    coin: CoinCreateNestedOneWithoutPriceHistoryInput
  }

  export type PriceHistoryUncheckedCreateInput = {
    id?: string
    coinId: string
    price: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
  }

  export type PriceHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    coin?: CoinUpdateOneRequiredWithoutPriceHistoryNestedInput
  }

  export type PriceHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryCreateManyInput = {
    id?: string
    coinId: string
    price: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
  }

  export type PriceHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    coin: CoinCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    coinId: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    coin?: CoinUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    coinId: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalCreateInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    createdBy: UserCreateNestedOneWithoutProposalsInput
    coin: CoinCreateNestedOneWithoutProposalsInput
  }

  export type ProposalUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    createdById: string
    coinId: string
  }

  export type ProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProposalsNestedInput
    coin?: CoinUpdateOneRequiredWithoutProposalsNestedInput
  }

  export type ProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalCreateManyInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    createdById: string
    coinId: string
  }

  export type ProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CoinListRelationFilter = {
    every?: CoinWhereInput
    some?: CoinWhereInput
    none?: CoinWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type WalletAddressListRelationFilter = {
    every?: WalletAddressWhereInput
    some?: WalletAddressWhereInput
    none?: WalletAddressWhereInput
  }

  export type SocialAccountListRelationFilter = {
    every?: SocialAccountWhereInput
    some?: SocialAccountWhereInput
    none?: SocialAccountWhereInput
  }

  export type TokenHoldingListRelationFilter = {
    every?: TokenHoldingWhereInput
    some?: TokenHoldingWhereInput
    none?: TokenHoldingWhereInput
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type CommentsListRelationFilter = {
    every?: CommentsWhereInput
    some?: CommentsWhereInput
    none?: CommentsWhereInput
  }

  export type ReputationNullableScalarRelationFilter = {
    is?: ReputationWhereInput | null
    isNot?: ReputationWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type ProposalListRelationFilter = {
    every?: ProposalWhereInput
    some?: ProposalWhereInput
    none?: ProposalWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CoinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenHoldingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    confirmedEmail?: SortOrder
    emailVerified?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiresAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiresAt?: SortOrder
    pictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referrerId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    confirmedEmail?: SortOrder
    emailVerified?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiresAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiresAt?: SortOrder
    pictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referrerId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    confirmedEmail?: SortOrder
    emailVerified?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    verificationToken?: SortOrder
    verificationTokenExpiresAt?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiresAt?: SortOrder
    pictureUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    referralCode?: SortOrder
    referrerId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumBlockchainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Blockchain | EnumBlockchainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBlockchainNullableFilter<$PrismaModel> | $Enums.Blockchain | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumCoinStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinStatus | EnumCoinStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinStatusFilter<$PrismaModel> | $Enums.CoinStatus
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BondingCurveNullableScalarRelationFilter = {
    is?: BondingCurveWhereInput | null
    isNot?: BondingCurveWhereInput | null
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type HashtagListRelationFilter = {
    every?: HashtagWhereInput
    some?: HashtagWhereInput
    none?: HashtagWhereInput
  }

  export type PriceHistoryListRelationFilter = {
    every?: PriceHistoryWhereInput
    some?: PriceHistoryWhereInput
    none?: PriceHistoryWhereInput
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HashtagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoinCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    description?: SortOrder
    pictureUrl?: SortOrder
    telegramLink?: SortOrder
    discordLink?: SortOrder
    socialLinks?: SortOrder
    totalSupply?: SortOrder
    airdropAmount?: SortOrder
    blockchain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    reputationScore?: SortOrder
    status?: SortOrder
    marketCap?: SortOrder
  }

  export type CoinAvgOrderByAggregateInput = {
    totalSupply?: SortOrder
    airdropAmount?: SortOrder
    reputationScore?: SortOrder
    marketCap?: SortOrder
  }

  export type CoinMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    description?: SortOrder
    pictureUrl?: SortOrder
    telegramLink?: SortOrder
    discordLink?: SortOrder
    totalSupply?: SortOrder
    airdropAmount?: SortOrder
    blockchain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    reputationScore?: SortOrder
    status?: SortOrder
    marketCap?: SortOrder
  }

  export type CoinMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ticker?: SortOrder
    description?: SortOrder
    pictureUrl?: SortOrder
    telegramLink?: SortOrder
    discordLink?: SortOrder
    totalSupply?: SortOrder
    airdropAmount?: SortOrder
    blockchain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creatorId?: SortOrder
    reputationScore?: SortOrder
    status?: SortOrder
    marketCap?: SortOrder
  }

  export type CoinSumOrderByAggregateInput = {
    totalSupply?: SortOrder
    airdropAmount?: SortOrder
    reputationScore?: SortOrder
    marketCap?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumBlockchainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Blockchain | EnumBlockchainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBlockchainNullableWithAggregatesFilter<$PrismaModel> | $Enums.Blockchain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBlockchainNullableFilter<$PrismaModel>
    _max?: NestedEnumBlockchainNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumCoinStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinStatus | EnumCoinStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinStatusWithAggregatesFilter<$PrismaModel> | $Enums.CoinStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoinStatusFilter<$PrismaModel>
    _max?: NestedEnumCoinStatusFilter<$PrismaModel>
  }

  export type CoinScalarRelationFilter = {
    is?: CoinWhereInput
    isNot?: CoinWhereInput
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    coinId?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    coinId?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    coinId?: SortOrder
  }

  export type HashtagCountOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    usageCount?: SortOrder
  }

  export type HashtagAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type HashtagMaxOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    usageCount?: SortOrder
  }

  export type HashtagMinOrderByAggregateInput = {
    id?: SortOrder
    tag?: SortOrder
    usageCount?: SortOrder
  }

  export type HashtagSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FeeStructureNullableScalarRelationFilter = {
    is?: FeeStructureWhereInput | null
    isNot?: FeeStructureWhereInput | null
  }

  export type BondingCurveCountOrderByAggregateInput = {
    id?: SortOrder
    coinId?: SortOrder
    curveDetail?: SortOrder
    feeStructureId?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BondingCurveMaxOrderByAggregateInput = {
    id?: SortOrder
    coinId?: SortOrder
    feeStructureId?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BondingCurveMinOrderByAggregateInput = {
    id?: SortOrder
    coinId?: SortOrder
    feeStructureId?: SortOrder
    isCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FeeStructureCountOrderByAggregateInput = {
    id?: SortOrder
    tradeFee?: SortOrder
    memecoinFee?: SortOrder
    feeDescription?: SortOrder
  }

  export type FeeStructureAvgOrderByAggregateInput = {
    tradeFee?: SortOrder
    memecoinFee?: SortOrder
  }

  export type FeeStructureMaxOrderByAggregateInput = {
    id?: SortOrder
    tradeFee?: SortOrder
    memecoinFee?: SortOrder
    feeDescription?: SortOrder
  }

  export type FeeStructureMinOrderByAggregateInput = {
    id?: SortOrder
    tradeFee?: SortOrder
    memecoinFee?: SortOrder
    feeDescription?: SortOrder
  }

  export type FeeStructureSumOrderByAggregateInput = {
    tradeFee?: SortOrder
    memecoinFee?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    proposalId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type VoteAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    proposalId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    proposalId?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type VoteSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    media?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type ChatMessageAvgOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    media?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    media?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type ChatMessageSumOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CommentsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CommentsAvgOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CommentsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CommentsSumOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type ReputationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
  }

  export type ReputationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ReputationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
  }

  export type ReputationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    score?: SortOrder
  }

  export type ReputationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type WalletAddressUserId_networkCompoundUniqueInput = {
    userId: string
    network: string
  }

  export type WalletAddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    network?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    network?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    address?: SortOrder
    network?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialAccountUserId_platformCompoundUniqueInput = {
    userId: string
    platform: string
  }

  export type SocialAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    handle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenHoldingUser_coin_uniqueCompoundUniqueInput = {
    userId: string
    coinId: string
  }

  export type TokenHoldingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenHoldingAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TokenHoldingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenHoldingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenHoldingSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PriceHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    coinId?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
  }

  export type PriceHistoryAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PriceHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    coinId?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
  }

  export type PriceHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    coinId?: SortOrder
    price?: SortOrder
    timestamp?: SortOrder
  }

  export type PriceHistorySumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    type?: SortOrder
    proposalId?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    price?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    type?: SortOrder
    proposalId?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    coinId?: SortOrder
    type?: SortOrder
    proposalId?: SortOrder
    amount?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    price?: SortOrder
  }

  export type ProposalCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    votesFor?: SortOrder
    votesAgainst?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    votingEnds?: SortOrder
    createdById?: SortOrder
    coinId?: SortOrder
  }

  export type ProposalAvgOrderByAggregateInput = {
    votesFor?: SortOrder
    votesAgainst?: SortOrder
  }

  export type ProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    votesFor?: SortOrder
    votesAgainst?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    votingEnds?: SortOrder
    createdById?: SortOrder
    coinId?: SortOrder
  }

  export type ProposalMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    votesFor?: SortOrder
    votesAgainst?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    votingEnds?: SortOrder
    createdById?: SortOrder
    coinId?: SortOrder
  }

  export type ProposalSumOrderByAggregateInput = {
    votesFor?: SortOrder
    votesAgainst?: SortOrder
  }

  export type CoinCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CoinCreateWithoutCreatorInput, CoinUncheckedCreateWithoutCreatorInput> | CoinCreateWithoutCreatorInput[] | CoinUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutCreatorInput | CoinCreateOrConnectWithoutCreatorInput[]
    createMany?: CoinCreateManyCreatorInputEnvelope
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WalletAddressCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletAddressCreateWithoutUserInput, WalletAddressUncheckedCreateWithoutUserInput> | WalletAddressCreateWithoutUserInput[] | WalletAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletAddressCreateOrConnectWithoutUserInput | WalletAddressCreateOrConnectWithoutUserInput[]
    createMany?: WalletAddressCreateManyUserInputEnvelope
    connect?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
  }

  export type SocialAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput> | SocialAccountCreateWithoutUserInput[] | SocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialAccountCreateOrConnectWithoutUserInput | SocialAccountCreateOrConnectWithoutUserInput[]
    createMany?: SocialAccountCreateManyUserInputEnvelope
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
  }

  export type TokenHoldingCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenHoldingCreateWithoutUserInput, TokenHoldingUncheckedCreateWithoutUserInput> | TokenHoldingCreateWithoutUserInput[] | TokenHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutUserInput | TokenHoldingCreateOrConnectWithoutUserInput[]
    createMany?: TokenHoldingCreateManyUserInputEnvelope
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutUserInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ChatMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type ReputationCreateNestedOneWithoutUserInput = {
    create?: XOR<ReputationCreateWithoutUserInput, ReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReputationCreateOrConnectWithoutUserInput
    connect?: ReputationWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type CoinUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CoinCreateWithoutCreatorInput, CoinUncheckedCreateWithoutCreatorInput> | CoinCreateWithoutCreatorInput[] | CoinUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutCreatorInput | CoinCreateOrConnectWithoutCreatorInput[]
    createMany?: CoinCreateManyCreatorInputEnvelope
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WalletAddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WalletAddressCreateWithoutUserInput, WalletAddressUncheckedCreateWithoutUserInput> | WalletAddressCreateWithoutUserInput[] | WalletAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletAddressCreateOrConnectWithoutUserInput | WalletAddressCreateOrConnectWithoutUserInput[]
    createMany?: WalletAddressCreateManyUserInputEnvelope
    connect?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
  }

  export type SocialAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput> | SocialAccountCreateWithoutUserInput[] | SocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialAccountCreateOrConnectWithoutUserInput | SocialAccountCreateOrConnectWithoutUserInput[]
    createMany?: SocialAccountCreateManyUserInputEnvelope
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
  }

  export type TokenHoldingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenHoldingCreateWithoutUserInput, TokenHoldingUncheckedCreateWithoutUserInput> | TokenHoldingCreateWithoutUserInput[] | TokenHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutUserInput | TokenHoldingCreateOrConnectWithoutUserInput[]
    createMany?: TokenHoldingCreateManyUserInputEnvelope
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type ReputationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ReputationCreateWithoutUserInput, ReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReputationCreateOrConnectWithoutUserInput
    connect?: ReputationWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CoinUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CoinCreateWithoutCreatorInput, CoinUncheckedCreateWithoutCreatorInput> | CoinCreateWithoutCreatorInput[] | CoinUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutCreatorInput | CoinCreateOrConnectWithoutCreatorInput[]
    upsert?: CoinUpsertWithWhereUniqueWithoutCreatorInput | CoinUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CoinCreateManyCreatorInputEnvelope
    set?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    disconnect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    delete?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    update?: CoinUpdateWithWhereUniqueWithoutCreatorInput | CoinUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CoinUpdateManyWithWhereWithoutCreatorInput | CoinUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CoinScalarWhereInput | CoinScalarWhereInput[]
  }

  export type UserUpdateOneWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WalletAddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletAddressCreateWithoutUserInput, WalletAddressUncheckedCreateWithoutUserInput> | WalletAddressCreateWithoutUserInput[] | WalletAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletAddressCreateOrConnectWithoutUserInput | WalletAddressCreateOrConnectWithoutUserInput[]
    upsert?: WalletAddressUpsertWithWhereUniqueWithoutUserInput | WalletAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletAddressCreateManyUserInputEnvelope
    set?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    disconnect?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    delete?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    connect?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    update?: WalletAddressUpdateWithWhereUniqueWithoutUserInput | WalletAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletAddressUpdateManyWithWhereWithoutUserInput | WalletAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletAddressScalarWhereInput | WalletAddressScalarWhereInput[]
  }

  export type SocialAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput> | SocialAccountCreateWithoutUserInput[] | SocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialAccountCreateOrConnectWithoutUserInput | SocialAccountCreateOrConnectWithoutUserInput[]
    upsert?: SocialAccountUpsertWithWhereUniqueWithoutUserInput | SocialAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialAccountCreateManyUserInputEnvelope
    set?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    disconnect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    delete?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    update?: SocialAccountUpdateWithWhereUniqueWithoutUserInput | SocialAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialAccountUpdateManyWithWhereWithoutUserInput | SocialAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[]
  }

  export type TokenHoldingUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenHoldingCreateWithoutUserInput, TokenHoldingUncheckedCreateWithoutUserInput> | TokenHoldingCreateWithoutUserInput[] | TokenHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutUserInput | TokenHoldingCreateOrConnectWithoutUserInput[]
    upsert?: TokenHoldingUpsertWithWhereUniqueWithoutUserInput | TokenHoldingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenHoldingCreateManyUserInputEnvelope
    set?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    disconnect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    delete?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    update?: TokenHoldingUpdateWithWhereUniqueWithoutUserInput | TokenHoldingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenHoldingUpdateManyWithWhereWithoutUserInput | TokenHoldingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenHoldingScalarWhereInput | TokenHoldingScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutUserInput | VoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutUserInput | VoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutUserInput | VoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type ChatMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutUserInput | ChatMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutUserInput | ChatMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutUserInput | ChatMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutUserInput | CommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutUserInput | CommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutUserInput | CommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type ReputationUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReputationCreateWithoutUserInput, ReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReputationCreateOrConnectWithoutUserInput
    upsert?: ReputationUpsertWithoutUserInput
    disconnect?: ReputationWhereInput | boolean
    delete?: ReputationWhereInput | boolean
    connect?: ReputationWhereUniqueInput
    update?: XOR<XOR<ReputationUpdateToOneWithWhereWithoutUserInput, ReputationUpdateWithoutUserInput>, ReputationUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCreatedByInput | ProposalUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCreatedByInput | ProposalUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCreatedByInput | ProposalUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type CoinUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CoinCreateWithoutCreatorInput, CoinUncheckedCreateWithoutCreatorInput> | CoinCreateWithoutCreatorInput[] | CoinUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutCreatorInput | CoinCreateOrConnectWithoutCreatorInput[]
    upsert?: CoinUpsertWithWhereUniqueWithoutCreatorInput | CoinUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CoinCreateManyCreatorInputEnvelope
    set?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    disconnect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    delete?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    update?: CoinUpdateWithWhereUniqueWithoutCreatorInput | CoinUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CoinUpdateManyWithWhereWithoutCreatorInput | CoinUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CoinScalarWhereInput | CoinScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput> | UserCreateWithoutReferrerInput[] | UserUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReferrerInput | UserCreateOrConnectWithoutReferrerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReferrerInput | UserUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: UserCreateManyReferrerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReferrerInput | UserUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReferrerInput | UserUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WalletAddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WalletAddressCreateWithoutUserInput, WalletAddressUncheckedCreateWithoutUserInput> | WalletAddressCreateWithoutUserInput[] | WalletAddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WalletAddressCreateOrConnectWithoutUserInput | WalletAddressCreateOrConnectWithoutUserInput[]
    upsert?: WalletAddressUpsertWithWhereUniqueWithoutUserInput | WalletAddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WalletAddressCreateManyUserInputEnvelope
    set?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    disconnect?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    delete?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    connect?: WalletAddressWhereUniqueInput | WalletAddressWhereUniqueInput[]
    update?: WalletAddressUpdateWithWhereUniqueWithoutUserInput | WalletAddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WalletAddressUpdateManyWithWhereWithoutUserInput | WalletAddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WalletAddressScalarWhereInput | WalletAddressScalarWhereInput[]
  }

  export type SocialAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput> | SocialAccountCreateWithoutUserInput[] | SocialAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialAccountCreateOrConnectWithoutUserInput | SocialAccountCreateOrConnectWithoutUserInput[]
    upsert?: SocialAccountUpsertWithWhereUniqueWithoutUserInput | SocialAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialAccountCreateManyUserInputEnvelope
    set?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    disconnect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    delete?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    connect?: SocialAccountWhereUniqueInput | SocialAccountWhereUniqueInput[]
    update?: SocialAccountUpdateWithWhereUniqueWithoutUserInput | SocialAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialAccountUpdateManyWithWhereWithoutUserInput | SocialAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[]
  }

  export type TokenHoldingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenHoldingCreateWithoutUserInput, TokenHoldingUncheckedCreateWithoutUserInput> | TokenHoldingCreateWithoutUserInput[] | TokenHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutUserInput | TokenHoldingCreateOrConnectWithoutUserInput[]
    upsert?: TokenHoldingUpsertWithWhereUniqueWithoutUserInput | TokenHoldingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenHoldingCreateManyUserInputEnvelope
    set?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    disconnect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    delete?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    update?: TokenHoldingUpdateWithWhereUniqueWithoutUserInput | TokenHoldingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenHoldingUpdateManyWithWhereWithoutUserInput | TokenHoldingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenHoldingScalarWhereInput | TokenHoldingScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutUserInput | VoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutUserInput | VoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutUserInput | VoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput> | ChatMessageCreateWithoutUserInput[] | ChatMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutUserInput | ChatMessageCreateOrConnectWithoutUserInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutUserInput | ChatMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatMessageCreateManyUserInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutUserInput | ChatMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutUserInput | ChatMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput> | CommentsCreateWithoutUserInput[] | CommentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutUserInput | CommentsCreateOrConnectWithoutUserInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutUserInput | CommentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentsCreateManyUserInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutUserInput | CommentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutUserInput | CommentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type ReputationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ReputationCreateWithoutUserInput, ReputationUncheckedCreateWithoutUserInput>
    connectOrCreate?: ReputationCreateOrConnectWithoutUserInput
    upsert?: ReputationUpsertWithoutUserInput
    disconnect?: ReputationWhereInput | boolean
    delete?: ReputationWhereInput | boolean
    connect?: ReputationWhereUniqueInput
    update?: XOR<XOR<ReputationUpdateToOneWithWhereWithoutUserInput, ReputationUpdateWithoutUserInput>, ReputationUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput> | ProposalCreateWithoutCreatedByInput[] | ProposalUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCreatedByInput | ProposalCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCreatedByInput | ProposalUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProposalCreateManyCreatedByInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCreatedByInput | ProposalUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCreatedByInput | ProposalUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCoinsCreatedInput = {
    create?: XOR<UserCreateWithoutCoinsCreatedInput, UserUncheckedCreateWithoutCoinsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoinsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutCoinInput = {
    create?: XOR<ChatMessageCreateWithoutCoinInput, ChatMessageUncheckedCreateWithoutCoinInput> | ChatMessageCreateWithoutCoinInput[] | ChatMessageUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutCoinInput | ChatMessageCreateOrConnectWithoutCoinInput[]
    createMany?: ChatMessageCreateManyCoinInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CommentsCreateNestedManyWithoutCoinInput = {
    create?: XOR<CommentsCreateWithoutCoinInput, CommentsUncheckedCreateWithoutCoinInput> | CommentsCreateWithoutCoinInput[] | CommentsUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutCoinInput | CommentsCreateOrConnectWithoutCoinInput[]
    createMany?: CommentsCreateManyCoinInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type BondingCurveCreateNestedOneWithoutCoinInput = {
    create?: XOR<BondingCurveCreateWithoutCoinInput, BondingCurveUncheckedCreateWithoutCoinInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutCoinInput
    connect?: BondingCurveWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutCoinInput = {
    create?: XOR<VoteCreateWithoutCoinInput, VoteUncheckedCreateWithoutCoinInput> | VoteCreateWithoutCoinInput[] | VoteUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCoinInput | VoteCreateOrConnectWithoutCoinInput[]
    createMany?: VoteCreateManyCoinInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type TokenHoldingCreateNestedManyWithoutCoinInput = {
    create?: XOR<TokenHoldingCreateWithoutCoinInput, TokenHoldingUncheckedCreateWithoutCoinInput> | TokenHoldingCreateWithoutCoinInput[] | TokenHoldingUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutCoinInput | TokenHoldingCreateOrConnectWithoutCoinInput[]
    createMany?: TokenHoldingCreateManyCoinInputEnvelope
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
  }

  export type MilestoneCreateNestedManyWithoutCoinInput = {
    create?: XOR<MilestoneCreateWithoutCoinInput, MilestoneUncheckedCreateWithoutCoinInput> | MilestoneCreateWithoutCoinInput[] | MilestoneUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutCoinInput | MilestoneCreateOrConnectWithoutCoinInput[]
    createMany?: MilestoneCreateManyCoinInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type HashtagCreateNestedManyWithoutCoinsInput = {
    create?: XOR<HashtagCreateWithoutCoinsInput, HashtagUncheckedCreateWithoutCoinsInput> | HashtagCreateWithoutCoinsInput[] | HashtagUncheckedCreateWithoutCoinsInput[]
    connectOrCreate?: HashtagCreateOrConnectWithoutCoinsInput | HashtagCreateOrConnectWithoutCoinsInput[]
    connect?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
  }

  export type PriceHistoryCreateNestedManyWithoutCoinInput = {
    create?: XOR<PriceHistoryCreateWithoutCoinInput, PriceHistoryUncheckedCreateWithoutCoinInput> | PriceHistoryCreateWithoutCoinInput[] | PriceHistoryUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutCoinInput | PriceHistoryCreateOrConnectWithoutCoinInput[]
    createMany?: PriceHistoryCreateManyCoinInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCoinInput = {
    create?: XOR<TransactionCreateWithoutCoinInput, TransactionUncheckedCreateWithoutCoinInput> | TransactionCreateWithoutCoinInput[] | TransactionUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCoinInput | TransactionCreateOrConnectWithoutCoinInput[]
    createMany?: TransactionCreateManyCoinInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProposalCreateNestedManyWithoutCoinInput = {
    create?: XOR<ProposalCreateWithoutCoinInput, ProposalUncheckedCreateWithoutCoinInput> | ProposalCreateWithoutCoinInput[] | ProposalUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCoinInput | ProposalCreateOrConnectWithoutCoinInput[]
    createMany?: ProposalCreateManyCoinInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<ChatMessageCreateWithoutCoinInput, ChatMessageUncheckedCreateWithoutCoinInput> | ChatMessageCreateWithoutCoinInput[] | ChatMessageUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutCoinInput | ChatMessageCreateOrConnectWithoutCoinInput[]
    createMany?: ChatMessageCreateManyCoinInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type CommentsUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<CommentsCreateWithoutCoinInput, CommentsUncheckedCreateWithoutCoinInput> | CommentsCreateWithoutCoinInput[] | CommentsUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutCoinInput | CommentsCreateOrConnectWithoutCoinInput[]
    createMany?: CommentsCreateManyCoinInputEnvelope
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
  }

  export type BondingCurveUncheckedCreateNestedOneWithoutCoinInput = {
    create?: XOR<BondingCurveCreateWithoutCoinInput, BondingCurveUncheckedCreateWithoutCoinInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutCoinInput
    connect?: BondingCurveWhereUniqueInput
  }

  export type VoteUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<VoteCreateWithoutCoinInput, VoteUncheckedCreateWithoutCoinInput> | VoteCreateWithoutCoinInput[] | VoteUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCoinInput | VoteCreateOrConnectWithoutCoinInput[]
    createMany?: VoteCreateManyCoinInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type TokenHoldingUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<TokenHoldingCreateWithoutCoinInput, TokenHoldingUncheckedCreateWithoutCoinInput> | TokenHoldingCreateWithoutCoinInput[] | TokenHoldingUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutCoinInput | TokenHoldingCreateOrConnectWithoutCoinInput[]
    createMany?: TokenHoldingCreateManyCoinInputEnvelope
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<MilestoneCreateWithoutCoinInput, MilestoneUncheckedCreateWithoutCoinInput> | MilestoneCreateWithoutCoinInput[] | MilestoneUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutCoinInput | MilestoneCreateOrConnectWithoutCoinInput[]
    createMany?: MilestoneCreateManyCoinInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type HashtagUncheckedCreateNestedManyWithoutCoinsInput = {
    create?: XOR<HashtagCreateWithoutCoinsInput, HashtagUncheckedCreateWithoutCoinsInput> | HashtagCreateWithoutCoinsInput[] | HashtagUncheckedCreateWithoutCoinsInput[]
    connectOrCreate?: HashtagCreateOrConnectWithoutCoinsInput | HashtagCreateOrConnectWithoutCoinsInput[]
    connect?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
  }

  export type PriceHistoryUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<PriceHistoryCreateWithoutCoinInput, PriceHistoryUncheckedCreateWithoutCoinInput> | PriceHistoryCreateWithoutCoinInput[] | PriceHistoryUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutCoinInput | PriceHistoryCreateOrConnectWithoutCoinInput[]
    createMany?: PriceHistoryCreateManyCoinInputEnvelope
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<TransactionCreateWithoutCoinInput, TransactionUncheckedCreateWithoutCoinInput> | TransactionCreateWithoutCoinInput[] | TransactionUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCoinInput | TransactionCreateOrConnectWithoutCoinInput[]
    createMany?: TransactionCreateManyCoinInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ProposalUncheckedCreateNestedManyWithoutCoinInput = {
    create?: XOR<ProposalCreateWithoutCoinInput, ProposalUncheckedCreateWithoutCoinInput> | ProposalCreateWithoutCoinInput[] | ProposalUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCoinInput | ProposalCreateOrConnectWithoutCoinInput[]
    createMany?: ProposalCreateManyCoinInputEnvelope
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumBlockchainFieldUpdateOperationsInput = {
    set?: $Enums.Blockchain | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCoinStatusFieldUpdateOperationsInput = {
    set?: $Enums.CoinStatus
  }

  export type UserUpdateOneRequiredWithoutCoinsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutCoinsCreatedInput, UserUncheckedCreateWithoutCoinsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoinsCreatedInput
    upsert?: UserUpsertWithoutCoinsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoinsCreatedInput, UserUpdateWithoutCoinsCreatedInput>, UserUncheckedUpdateWithoutCoinsCreatedInput>
  }

  export type ChatMessageUpdateManyWithoutCoinNestedInput = {
    create?: XOR<ChatMessageCreateWithoutCoinInput, ChatMessageUncheckedCreateWithoutCoinInput> | ChatMessageCreateWithoutCoinInput[] | ChatMessageUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutCoinInput | ChatMessageCreateOrConnectWithoutCoinInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutCoinInput | ChatMessageUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: ChatMessageCreateManyCoinInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutCoinInput | ChatMessageUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutCoinInput | ChatMessageUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CommentsUpdateManyWithoutCoinNestedInput = {
    create?: XOR<CommentsCreateWithoutCoinInput, CommentsUncheckedCreateWithoutCoinInput> | CommentsCreateWithoutCoinInput[] | CommentsUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutCoinInput | CommentsCreateOrConnectWithoutCoinInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutCoinInput | CommentsUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: CommentsCreateManyCoinInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutCoinInput | CommentsUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutCoinInput | CommentsUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type BondingCurveUpdateOneWithoutCoinNestedInput = {
    create?: XOR<BondingCurveCreateWithoutCoinInput, BondingCurveUncheckedCreateWithoutCoinInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutCoinInput
    upsert?: BondingCurveUpsertWithoutCoinInput
    disconnect?: BondingCurveWhereInput | boolean
    delete?: BondingCurveWhereInput | boolean
    connect?: BondingCurveWhereUniqueInput
    update?: XOR<XOR<BondingCurveUpdateToOneWithWhereWithoutCoinInput, BondingCurveUpdateWithoutCoinInput>, BondingCurveUncheckedUpdateWithoutCoinInput>
  }

  export type VoteUpdateManyWithoutCoinNestedInput = {
    create?: XOR<VoteCreateWithoutCoinInput, VoteUncheckedCreateWithoutCoinInput> | VoteCreateWithoutCoinInput[] | VoteUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCoinInput | VoteCreateOrConnectWithoutCoinInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutCoinInput | VoteUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: VoteCreateManyCoinInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutCoinInput | VoteUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutCoinInput | VoteUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type TokenHoldingUpdateManyWithoutCoinNestedInput = {
    create?: XOR<TokenHoldingCreateWithoutCoinInput, TokenHoldingUncheckedCreateWithoutCoinInput> | TokenHoldingCreateWithoutCoinInput[] | TokenHoldingUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutCoinInput | TokenHoldingCreateOrConnectWithoutCoinInput[]
    upsert?: TokenHoldingUpsertWithWhereUniqueWithoutCoinInput | TokenHoldingUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: TokenHoldingCreateManyCoinInputEnvelope
    set?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    disconnect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    delete?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    update?: TokenHoldingUpdateWithWhereUniqueWithoutCoinInput | TokenHoldingUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: TokenHoldingUpdateManyWithWhereWithoutCoinInput | TokenHoldingUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: TokenHoldingScalarWhereInput | TokenHoldingScalarWhereInput[]
  }

  export type MilestoneUpdateManyWithoutCoinNestedInput = {
    create?: XOR<MilestoneCreateWithoutCoinInput, MilestoneUncheckedCreateWithoutCoinInput> | MilestoneCreateWithoutCoinInput[] | MilestoneUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutCoinInput | MilestoneCreateOrConnectWithoutCoinInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutCoinInput | MilestoneUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: MilestoneCreateManyCoinInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutCoinInput | MilestoneUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutCoinInput | MilestoneUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type HashtagUpdateManyWithoutCoinsNestedInput = {
    create?: XOR<HashtagCreateWithoutCoinsInput, HashtagUncheckedCreateWithoutCoinsInput> | HashtagCreateWithoutCoinsInput[] | HashtagUncheckedCreateWithoutCoinsInput[]
    connectOrCreate?: HashtagCreateOrConnectWithoutCoinsInput | HashtagCreateOrConnectWithoutCoinsInput[]
    upsert?: HashtagUpsertWithWhereUniqueWithoutCoinsInput | HashtagUpsertWithWhereUniqueWithoutCoinsInput[]
    set?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    disconnect?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    delete?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    connect?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    update?: HashtagUpdateWithWhereUniqueWithoutCoinsInput | HashtagUpdateWithWhereUniqueWithoutCoinsInput[]
    updateMany?: HashtagUpdateManyWithWhereWithoutCoinsInput | HashtagUpdateManyWithWhereWithoutCoinsInput[]
    deleteMany?: HashtagScalarWhereInput | HashtagScalarWhereInput[]
  }

  export type PriceHistoryUpdateManyWithoutCoinNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutCoinInput, PriceHistoryUncheckedCreateWithoutCoinInput> | PriceHistoryCreateWithoutCoinInput[] | PriceHistoryUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutCoinInput | PriceHistoryCreateOrConnectWithoutCoinInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutCoinInput | PriceHistoryUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: PriceHistoryCreateManyCoinInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutCoinInput | PriceHistoryUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutCoinInput | PriceHistoryUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCoinNestedInput = {
    create?: XOR<TransactionCreateWithoutCoinInput, TransactionUncheckedCreateWithoutCoinInput> | TransactionCreateWithoutCoinInput[] | TransactionUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCoinInput | TransactionCreateOrConnectWithoutCoinInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCoinInput | TransactionUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: TransactionCreateManyCoinInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCoinInput | TransactionUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCoinInput | TransactionUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProposalUpdateManyWithoutCoinNestedInput = {
    create?: XOR<ProposalCreateWithoutCoinInput, ProposalUncheckedCreateWithoutCoinInput> | ProposalCreateWithoutCoinInput[] | ProposalUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCoinInput | ProposalCreateOrConnectWithoutCoinInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCoinInput | ProposalUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: ProposalCreateManyCoinInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCoinInput | ProposalUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCoinInput | ProposalUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<ChatMessageCreateWithoutCoinInput, ChatMessageUncheckedCreateWithoutCoinInput> | ChatMessageCreateWithoutCoinInput[] | ChatMessageUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutCoinInput | ChatMessageCreateOrConnectWithoutCoinInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutCoinInput | ChatMessageUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: ChatMessageCreateManyCoinInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutCoinInput | ChatMessageUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutCoinInput | ChatMessageUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type CommentsUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<CommentsCreateWithoutCoinInput, CommentsUncheckedCreateWithoutCoinInput> | CommentsCreateWithoutCoinInput[] | CommentsUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: CommentsCreateOrConnectWithoutCoinInput | CommentsCreateOrConnectWithoutCoinInput[]
    upsert?: CommentsUpsertWithWhereUniqueWithoutCoinInput | CommentsUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: CommentsCreateManyCoinInputEnvelope
    set?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    disconnect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    delete?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    connect?: CommentsWhereUniqueInput | CommentsWhereUniqueInput[]
    update?: CommentsUpdateWithWhereUniqueWithoutCoinInput | CommentsUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: CommentsUpdateManyWithWhereWithoutCoinInput | CommentsUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
  }

  export type BondingCurveUncheckedUpdateOneWithoutCoinNestedInput = {
    create?: XOR<BondingCurveCreateWithoutCoinInput, BondingCurveUncheckedCreateWithoutCoinInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutCoinInput
    upsert?: BondingCurveUpsertWithoutCoinInput
    disconnect?: BondingCurveWhereInput | boolean
    delete?: BondingCurveWhereInput | boolean
    connect?: BondingCurveWhereUniqueInput
    update?: XOR<XOR<BondingCurveUpdateToOneWithWhereWithoutCoinInput, BondingCurveUpdateWithoutCoinInput>, BondingCurveUncheckedUpdateWithoutCoinInput>
  }

  export type VoteUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<VoteCreateWithoutCoinInput, VoteUncheckedCreateWithoutCoinInput> | VoteCreateWithoutCoinInput[] | VoteUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutCoinInput | VoteCreateOrConnectWithoutCoinInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutCoinInput | VoteUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: VoteCreateManyCoinInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutCoinInput | VoteUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutCoinInput | VoteUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<TokenHoldingCreateWithoutCoinInput, TokenHoldingUncheckedCreateWithoutCoinInput> | TokenHoldingCreateWithoutCoinInput[] | TokenHoldingUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TokenHoldingCreateOrConnectWithoutCoinInput | TokenHoldingCreateOrConnectWithoutCoinInput[]
    upsert?: TokenHoldingUpsertWithWhereUniqueWithoutCoinInput | TokenHoldingUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: TokenHoldingCreateManyCoinInputEnvelope
    set?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    disconnect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    delete?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    connect?: TokenHoldingWhereUniqueInput | TokenHoldingWhereUniqueInput[]
    update?: TokenHoldingUpdateWithWhereUniqueWithoutCoinInput | TokenHoldingUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: TokenHoldingUpdateManyWithWhereWithoutCoinInput | TokenHoldingUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: TokenHoldingScalarWhereInput | TokenHoldingScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<MilestoneCreateWithoutCoinInput, MilestoneUncheckedCreateWithoutCoinInput> | MilestoneCreateWithoutCoinInput[] | MilestoneUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutCoinInput | MilestoneCreateOrConnectWithoutCoinInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutCoinInput | MilestoneUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: MilestoneCreateManyCoinInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutCoinInput | MilestoneUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutCoinInput | MilestoneUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type HashtagUncheckedUpdateManyWithoutCoinsNestedInput = {
    create?: XOR<HashtagCreateWithoutCoinsInput, HashtagUncheckedCreateWithoutCoinsInput> | HashtagCreateWithoutCoinsInput[] | HashtagUncheckedCreateWithoutCoinsInput[]
    connectOrCreate?: HashtagCreateOrConnectWithoutCoinsInput | HashtagCreateOrConnectWithoutCoinsInput[]
    upsert?: HashtagUpsertWithWhereUniqueWithoutCoinsInput | HashtagUpsertWithWhereUniqueWithoutCoinsInput[]
    set?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    disconnect?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    delete?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    connect?: HashtagWhereUniqueInput | HashtagWhereUniqueInput[]
    update?: HashtagUpdateWithWhereUniqueWithoutCoinsInput | HashtagUpdateWithWhereUniqueWithoutCoinsInput[]
    updateMany?: HashtagUpdateManyWithWhereWithoutCoinsInput | HashtagUpdateManyWithWhereWithoutCoinsInput[]
    deleteMany?: HashtagScalarWhereInput | HashtagScalarWhereInput[]
  }

  export type PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<PriceHistoryCreateWithoutCoinInput, PriceHistoryUncheckedCreateWithoutCoinInput> | PriceHistoryCreateWithoutCoinInput[] | PriceHistoryUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: PriceHistoryCreateOrConnectWithoutCoinInput | PriceHistoryCreateOrConnectWithoutCoinInput[]
    upsert?: PriceHistoryUpsertWithWhereUniqueWithoutCoinInput | PriceHistoryUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: PriceHistoryCreateManyCoinInputEnvelope
    set?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    disconnect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    delete?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    connect?: PriceHistoryWhereUniqueInput | PriceHistoryWhereUniqueInput[]
    update?: PriceHistoryUpdateWithWhereUniqueWithoutCoinInput | PriceHistoryUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: PriceHistoryUpdateManyWithWhereWithoutCoinInput | PriceHistoryUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<TransactionCreateWithoutCoinInput, TransactionUncheckedCreateWithoutCoinInput> | TransactionCreateWithoutCoinInput[] | TransactionUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCoinInput | TransactionCreateOrConnectWithoutCoinInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCoinInput | TransactionUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: TransactionCreateManyCoinInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCoinInput | TransactionUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCoinInput | TransactionUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ProposalUncheckedUpdateManyWithoutCoinNestedInput = {
    create?: XOR<ProposalCreateWithoutCoinInput, ProposalUncheckedCreateWithoutCoinInput> | ProposalCreateWithoutCoinInput[] | ProposalUncheckedCreateWithoutCoinInput[]
    connectOrCreate?: ProposalCreateOrConnectWithoutCoinInput | ProposalCreateOrConnectWithoutCoinInput[]
    upsert?: ProposalUpsertWithWhereUniqueWithoutCoinInput | ProposalUpsertWithWhereUniqueWithoutCoinInput[]
    createMany?: ProposalCreateManyCoinInputEnvelope
    set?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    disconnect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    delete?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    connect?: ProposalWhereUniqueInput | ProposalWhereUniqueInput[]
    update?: ProposalUpdateWithWhereUniqueWithoutCoinInput | ProposalUpdateWithWhereUniqueWithoutCoinInput[]
    updateMany?: ProposalUpdateManyWithWhereWithoutCoinInput | ProposalUpdateManyWithWhereWithoutCoinInput[]
    deleteMany?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
  }

  export type CoinCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<CoinCreateWithoutMilestonesInput, CoinUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: CoinCreateOrConnectWithoutMilestonesInput
    connect?: CoinWhereUniqueInput
  }

  export type CoinUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<CoinCreateWithoutMilestonesInput, CoinUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: CoinCreateOrConnectWithoutMilestonesInput
    upsert?: CoinUpsertWithoutMilestonesInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutMilestonesInput, CoinUpdateWithoutMilestonesInput>, CoinUncheckedUpdateWithoutMilestonesInput>
  }

  export type CoinCreateNestedManyWithoutHashtagsInput = {
    create?: XOR<CoinCreateWithoutHashtagsInput, CoinUncheckedCreateWithoutHashtagsInput> | CoinCreateWithoutHashtagsInput[] | CoinUncheckedCreateWithoutHashtagsInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutHashtagsInput | CoinCreateOrConnectWithoutHashtagsInput[]
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
  }

  export type CoinUncheckedCreateNestedManyWithoutHashtagsInput = {
    create?: XOR<CoinCreateWithoutHashtagsInput, CoinUncheckedCreateWithoutHashtagsInput> | CoinCreateWithoutHashtagsInput[] | CoinUncheckedCreateWithoutHashtagsInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutHashtagsInput | CoinCreateOrConnectWithoutHashtagsInput[]
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
  }

  export type CoinUpdateManyWithoutHashtagsNestedInput = {
    create?: XOR<CoinCreateWithoutHashtagsInput, CoinUncheckedCreateWithoutHashtagsInput> | CoinCreateWithoutHashtagsInput[] | CoinUncheckedCreateWithoutHashtagsInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutHashtagsInput | CoinCreateOrConnectWithoutHashtagsInput[]
    upsert?: CoinUpsertWithWhereUniqueWithoutHashtagsInput | CoinUpsertWithWhereUniqueWithoutHashtagsInput[]
    set?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    disconnect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    delete?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    update?: CoinUpdateWithWhereUniqueWithoutHashtagsInput | CoinUpdateWithWhereUniqueWithoutHashtagsInput[]
    updateMany?: CoinUpdateManyWithWhereWithoutHashtagsInput | CoinUpdateManyWithWhereWithoutHashtagsInput[]
    deleteMany?: CoinScalarWhereInput | CoinScalarWhereInput[]
  }

  export type CoinUncheckedUpdateManyWithoutHashtagsNestedInput = {
    create?: XOR<CoinCreateWithoutHashtagsInput, CoinUncheckedCreateWithoutHashtagsInput> | CoinCreateWithoutHashtagsInput[] | CoinUncheckedCreateWithoutHashtagsInput[]
    connectOrCreate?: CoinCreateOrConnectWithoutHashtagsInput | CoinCreateOrConnectWithoutHashtagsInput[]
    upsert?: CoinUpsertWithWhereUniqueWithoutHashtagsInput | CoinUpsertWithWhereUniqueWithoutHashtagsInput[]
    set?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    disconnect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    delete?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    connect?: CoinWhereUniqueInput | CoinWhereUniqueInput[]
    update?: CoinUpdateWithWhereUniqueWithoutHashtagsInput | CoinUpdateWithWhereUniqueWithoutHashtagsInput[]
    updateMany?: CoinUpdateManyWithWhereWithoutHashtagsInput | CoinUpdateManyWithWhereWithoutHashtagsInput[]
    deleteMany?: CoinScalarWhereInput | CoinScalarWhereInput[]
  }

  export type FeeStructureCreateNestedOneWithoutBondingCurveInput = {
    create?: XOR<FeeStructureCreateWithoutBondingCurveInput, FeeStructureUncheckedCreateWithoutBondingCurveInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutBondingCurveInput
    connect?: FeeStructureWhereUniqueInput
  }

  export type CoinCreateNestedOneWithoutBondingCurveInput = {
    create?: XOR<CoinCreateWithoutBondingCurveInput, CoinUncheckedCreateWithoutBondingCurveInput>
    connectOrCreate?: CoinCreateOrConnectWithoutBondingCurveInput
    connect?: CoinWhereUniqueInput
  }

  export type FeeStructureUpdateOneWithoutBondingCurveNestedInput = {
    create?: XOR<FeeStructureCreateWithoutBondingCurveInput, FeeStructureUncheckedCreateWithoutBondingCurveInput>
    connectOrCreate?: FeeStructureCreateOrConnectWithoutBondingCurveInput
    upsert?: FeeStructureUpsertWithoutBondingCurveInput
    disconnect?: FeeStructureWhereInput | boolean
    delete?: FeeStructureWhereInput | boolean
    connect?: FeeStructureWhereUniqueInput
    update?: XOR<XOR<FeeStructureUpdateToOneWithWhereWithoutBondingCurveInput, FeeStructureUpdateWithoutBondingCurveInput>, FeeStructureUncheckedUpdateWithoutBondingCurveInput>
  }

  export type CoinUpdateOneRequiredWithoutBondingCurveNestedInput = {
    create?: XOR<CoinCreateWithoutBondingCurveInput, CoinUncheckedCreateWithoutBondingCurveInput>
    connectOrCreate?: CoinCreateOrConnectWithoutBondingCurveInput
    upsert?: CoinUpsertWithoutBondingCurveInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutBondingCurveInput, CoinUpdateWithoutBondingCurveInput>, CoinUncheckedUpdateWithoutBondingCurveInput>
  }

  export type BondingCurveCreateNestedOneWithoutFeeStructureInput = {
    create?: XOR<BondingCurveCreateWithoutFeeStructureInput, BondingCurveUncheckedCreateWithoutFeeStructureInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutFeeStructureInput
    connect?: BondingCurveWhereUniqueInput
  }

  export type BondingCurveUncheckedCreateNestedOneWithoutFeeStructureInput = {
    create?: XOR<BondingCurveCreateWithoutFeeStructureInput, BondingCurveUncheckedCreateWithoutFeeStructureInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutFeeStructureInput
    connect?: BondingCurveWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BondingCurveUpdateOneWithoutFeeStructureNestedInput = {
    create?: XOR<BondingCurveCreateWithoutFeeStructureInput, BondingCurveUncheckedCreateWithoutFeeStructureInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutFeeStructureInput
    upsert?: BondingCurveUpsertWithoutFeeStructureInput
    disconnect?: BondingCurveWhereInput | boolean
    delete?: BondingCurveWhereInput | boolean
    connect?: BondingCurveWhereUniqueInput
    update?: XOR<XOR<BondingCurveUpdateToOneWithWhereWithoutFeeStructureInput, BondingCurveUpdateWithoutFeeStructureInput>, BondingCurveUncheckedUpdateWithoutFeeStructureInput>
  }

  export type BondingCurveUncheckedUpdateOneWithoutFeeStructureNestedInput = {
    create?: XOR<BondingCurveCreateWithoutFeeStructureInput, BondingCurveUncheckedCreateWithoutFeeStructureInput>
    connectOrCreate?: BondingCurveCreateOrConnectWithoutFeeStructureInput
    upsert?: BondingCurveUpsertWithoutFeeStructureInput
    disconnect?: BondingCurveWhereInput | boolean
    delete?: BondingCurveWhereInput | boolean
    connect?: BondingCurveWhereUniqueInput
    update?: XOR<XOR<BondingCurveUpdateToOneWithWhereWithoutFeeStructureInput, BondingCurveUpdateWithoutFeeStructureInput>, BondingCurveUncheckedUpdateWithoutFeeStructureInput>
  }

  export type UserCreateNestedOneWithoutVotesInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    connect?: UserWhereUniqueInput
  }

  export type CoinCreateNestedOneWithoutVotesInput = {
    create?: XOR<CoinCreateWithoutVotesInput, CoinUncheckedCreateWithoutVotesInput>
    connectOrCreate?: CoinCreateOrConnectWithoutVotesInput
    connect?: CoinWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    upsert?: UserUpsertWithoutVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVotesInput, UserUpdateWithoutVotesInput>, UserUncheckedUpdateWithoutVotesInput>
  }

  export type CoinUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<CoinCreateWithoutVotesInput, CoinUncheckedCreateWithoutVotesInput>
    connectOrCreate?: CoinCreateOrConnectWithoutVotesInput
    upsert?: CoinUpsertWithoutVotesInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutVotesInput, CoinUpdateWithoutVotesInput>, CoinUncheckedUpdateWithoutVotesInput>
  }

  export type UserCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type CoinCreateNestedOneWithoutChatMessagesInput = {
    create?: XOR<CoinCreateWithoutChatMessagesInput, CoinUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: CoinCreateOrConnectWithoutChatMessagesInput
    connect?: CoinWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatMessagesInput
    upsert?: UserUpsertWithoutChatMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatMessagesInput, UserUpdateWithoutChatMessagesInput>, UserUncheckedUpdateWithoutChatMessagesInput>
  }

  export type CoinUpdateOneRequiredWithoutChatMessagesNestedInput = {
    create?: XOR<CoinCreateWithoutChatMessagesInput, CoinUncheckedCreateWithoutChatMessagesInput>
    connectOrCreate?: CoinCreateOrConnectWithoutChatMessagesInput
    upsert?: CoinUpsertWithoutChatMessagesInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutChatMessagesInput, CoinUpdateWithoutChatMessagesInput>, CoinUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CoinCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CoinCreateWithoutCommentsInput, CoinUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CoinCreateOrConnectWithoutCommentsInput
    connect?: CoinWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CoinUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<CoinCreateWithoutCommentsInput, CoinUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CoinCreateOrConnectWithoutCommentsInput
    upsert?: CoinUpsertWithoutCommentsInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutCommentsInput, CoinUpdateWithoutCommentsInput>, CoinUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutReputationInput = {
    create?: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
    connectOrCreate?: UserCreateOrConnectWithoutReputationInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReputationNestedInput = {
    create?: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
    connectOrCreate?: UserCreateOrConnectWithoutReputationInput
    upsert?: UserUpsertWithoutReputationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReputationInput, UserUpdateWithoutReputationInput>, UserUncheckedUpdateWithoutReputationInput>
  }

  export type UserCreateNestedOneWithoutWalletAddressesInput = {
    create?: XOR<UserCreateWithoutWalletAddressesInput, UserUncheckedCreateWithoutWalletAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWalletAddressesNestedInput = {
    create?: XOR<UserCreateWithoutWalletAddressesInput, UserUncheckedCreateWithoutWalletAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWalletAddressesInput
    upsert?: UserUpsertWithoutWalletAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWalletAddressesInput, UserUpdateWithoutWalletAddressesInput>, UserUncheckedUpdateWithoutWalletAddressesInput>
  }

  export type UserCreateNestedOneWithoutSocialAccountsInput = {
    create?: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSocialAccountsNestedInput = {
    create?: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialAccountsInput
    upsert?: UserUpsertWithoutSocialAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocialAccountsInput, UserUpdateWithoutSocialAccountsInput>, UserUncheckedUpdateWithoutSocialAccountsInput>
  }

  export type UserCreateNestedOneWithoutTokenHoldingsInput = {
    create?: XOR<UserCreateWithoutTokenHoldingsInput, UserUncheckedCreateWithoutTokenHoldingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenHoldingsInput
    connect?: UserWhereUniqueInput
  }

  export type CoinCreateNestedOneWithoutTokenHoldingsInput = {
    create?: XOR<CoinCreateWithoutTokenHoldingsInput, CoinUncheckedCreateWithoutTokenHoldingsInput>
    connectOrCreate?: CoinCreateOrConnectWithoutTokenHoldingsInput
    connect?: CoinWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTokenHoldingsNestedInput = {
    create?: XOR<UserCreateWithoutTokenHoldingsInput, UserUncheckedCreateWithoutTokenHoldingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenHoldingsInput
    upsert?: UserUpsertWithoutTokenHoldingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokenHoldingsInput, UserUpdateWithoutTokenHoldingsInput>, UserUncheckedUpdateWithoutTokenHoldingsInput>
  }

  export type CoinUpdateOneRequiredWithoutTokenHoldingsNestedInput = {
    create?: XOR<CoinCreateWithoutTokenHoldingsInput, CoinUncheckedCreateWithoutTokenHoldingsInput>
    connectOrCreate?: CoinCreateOrConnectWithoutTokenHoldingsInput
    upsert?: CoinUpsertWithoutTokenHoldingsInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutTokenHoldingsInput, CoinUpdateWithoutTokenHoldingsInput>, CoinUncheckedUpdateWithoutTokenHoldingsInput>
  }

  export type CoinCreateNestedOneWithoutPriceHistoryInput = {
    create?: XOR<CoinCreateWithoutPriceHistoryInput, CoinUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: CoinCreateOrConnectWithoutPriceHistoryInput
    connect?: CoinWhereUniqueInput
  }

  export type CoinUpdateOneRequiredWithoutPriceHistoryNestedInput = {
    create?: XOR<CoinCreateWithoutPriceHistoryInput, CoinUncheckedCreateWithoutPriceHistoryInput>
    connectOrCreate?: CoinCreateOrConnectWithoutPriceHistoryInput
    upsert?: CoinUpsertWithoutPriceHistoryInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutPriceHistoryInput, CoinUpdateWithoutPriceHistoryInput>, CoinUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type CoinCreateNestedOneWithoutTransactionInput = {
    create?: XOR<CoinCreateWithoutTransactionInput, CoinUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CoinCreateOrConnectWithoutTransactionInput
    connect?: CoinWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type CoinUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<CoinCreateWithoutTransactionInput, CoinUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: CoinCreateOrConnectWithoutTransactionInput
    upsert?: CoinUpsertWithoutTransactionInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutTransactionInput, CoinUpdateWithoutTransactionInput>, CoinUncheckedUpdateWithoutTransactionInput>
  }

  export type UserCreateNestedOneWithoutProposalsInput = {
    create?: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProposalsInput
    connect?: UserWhereUniqueInput
  }

  export type CoinCreateNestedOneWithoutProposalsInput = {
    create?: XOR<CoinCreateWithoutProposalsInput, CoinUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CoinCreateOrConnectWithoutProposalsInput
    connect?: CoinWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProposalsInput
    upsert?: UserUpsertWithoutProposalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProposalsInput, UserUpdateWithoutProposalsInput>, UserUncheckedUpdateWithoutProposalsInput>
  }

  export type CoinUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<CoinCreateWithoutProposalsInput, CoinUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CoinCreateOrConnectWithoutProposalsInput
    upsert?: CoinUpsertWithoutProposalsInput
    connect?: CoinWhereUniqueInput
    update?: XOR<XOR<CoinUpdateToOneWithWhereWithoutProposalsInput, CoinUpdateWithoutProposalsInput>, CoinUncheckedUpdateWithoutProposalsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumBlockchainNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Blockchain | EnumBlockchainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBlockchainNullableFilter<$PrismaModel> | $Enums.Blockchain | null
  }

  export type NestedEnumCoinStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinStatus | EnumCoinStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinStatusFilter<$PrismaModel> | $Enums.CoinStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBlockchainNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Blockchain | EnumBlockchainFieldRefInput<$PrismaModel> | null
    in?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Blockchain[] | ListEnumBlockchainFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBlockchainNullableWithAggregatesFilter<$PrismaModel> | $Enums.Blockchain | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBlockchainNullableFilter<$PrismaModel>
    _max?: NestedEnumBlockchainNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCoinStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CoinStatus | EnumCoinStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CoinStatus[] | ListEnumCoinStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCoinStatusWithAggregatesFilter<$PrismaModel> | $Enums.CoinStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCoinStatusFilter<$PrismaModel>
    _max?: NestedEnumCoinStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CoinCreateWithoutCreatorInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutCreatorInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutCreatorInput, CoinUncheckedCreateWithoutCreatorInput>
  }

  export type CoinCreateManyCreatorInputEnvelope = {
    data: CoinCreateManyCreatorInput | CoinCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferrerInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReferrerInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReferrerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserCreateManyReferrerInputEnvelope = {
    data: UserCreateManyReferrerInput | UserCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type WalletAddressCreateWithoutUserInput = {
    id?: string
    address: string
    network: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletAddressUncheckedCreateWithoutUserInput = {
    id?: string
    address: string
    network: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WalletAddressCreateOrConnectWithoutUserInput = {
    where: WalletAddressWhereUniqueInput
    create: XOR<WalletAddressCreateWithoutUserInput, WalletAddressUncheckedCreateWithoutUserInput>
  }

  export type WalletAddressCreateManyUserInputEnvelope = {
    data: WalletAddressCreateManyUserInput | WalletAddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SocialAccountCreateWithoutUserInput = {
    id?: string
    platform: string
    handle: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAccountUncheckedCreateWithoutUserInput = {
    id?: string
    platform: string
    handle: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAccountCreateOrConnectWithoutUserInput = {
    where: SocialAccountWhereUniqueInput
    create: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>
  }

  export type SocialAccountCreateManyUserInputEnvelope = {
    data: SocialAccountCreateManyUserInput | SocialAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenHoldingCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    coin: CoinCreateNestedOneWithoutTokenHoldingsInput
  }

  export type TokenHoldingUncheckedCreateWithoutUserInput = {
    id?: string
    coinId: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenHoldingCreateOrConnectWithoutUserInput = {
    where: TokenHoldingWhereUniqueInput
    create: XOR<TokenHoldingCreateWithoutUserInput, TokenHoldingUncheckedCreateWithoutUserInput>
  }

  export type TokenHoldingCreateManyUserInputEnvelope = {
    data: TokenHoldingCreateManyUserInput | TokenHoldingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoteCreateWithoutUserInput = {
    id?: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
    coin: CoinCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutUserInput = {
    id?: string
    coinId: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutUserInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
  }

  export type VoteCreateManyUserInputEnvelope = {
    data: VoteCreateManyUserInput | VoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatMessageCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
    coin: CoinCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutUserInput = {
    id?: string
    coinId: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
  }

  export type ChatMessageCreateOrConnectWithoutUserInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput>
  }

  export type ChatMessageCreateManyUserInputEnvelope = {
    data: ChatMessageCreateManyUserInput | ChatMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutUserInput = {
    id?: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
    coin: CoinCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateWithoutUserInput = {
    id?: string
    coinId: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
  }

  export type CommentsCreateOrConnectWithoutUserInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput>
  }

  export type CommentsCreateManyUserInputEnvelope = {
    data: CommentsCreateManyUserInput | CommentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReputationCreateWithoutUserInput = {
    id?: string
    score?: number
  }

  export type ReputationUncheckedCreateWithoutUserInput = {
    id?: string
    score?: number
  }

  export type ReputationCreateOrConnectWithoutUserInput = {
    where: ReputationWhereUniqueInput
    create: XOR<ReputationCreateWithoutUserInput, ReputationUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    coin: CoinCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    coinId: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    coin: CoinCreateNestedOneWithoutProposalsInput
  }

  export type ProposalUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    coinId: string
  }

  export type ProposalCreateOrConnectWithoutCreatedByInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput>
  }

  export type ProposalCreateManyCreatedByInputEnvelope = {
    data: ProposalCreateManyCreatedByInput | ProposalCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CoinUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CoinWhereUniqueInput
    update: XOR<CoinUpdateWithoutCreatorInput, CoinUncheckedUpdateWithoutCreatorInput>
    create: XOR<CoinCreateWithoutCreatorInput, CoinUncheckedCreateWithoutCreatorInput>
  }

  export type CoinUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CoinWhereUniqueInput
    data: XOR<CoinUpdateWithoutCreatorInput, CoinUncheckedUpdateWithoutCreatorInput>
  }

  export type CoinUpdateManyWithWhereWithoutCreatorInput = {
    where: CoinScalarWhereInput
    data: XOR<CoinUpdateManyMutationInput, CoinUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CoinScalarWhereInput = {
    AND?: CoinScalarWhereInput | CoinScalarWhereInput[]
    OR?: CoinScalarWhereInput[]
    NOT?: CoinScalarWhereInput | CoinScalarWhereInput[]
    id?: StringFilter<"Coin"> | string
    name?: StringFilter<"Coin"> | string
    ticker?: StringFilter<"Coin"> | string
    description?: StringNullableFilter<"Coin"> | string | null
    pictureUrl?: StringFilter<"Coin"> | string
    telegramLink?: StringFilter<"Coin"> | string
    discordLink?: StringFilter<"Coin"> | string
    socialLinks?: JsonNullableFilter<"Coin">
    totalSupply?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
    blockchain?: EnumBlockchainNullableFilter<"Coin"> | $Enums.Blockchain | null
    createdAt?: DateTimeFilter<"Coin"> | Date | string
    updatedAt?: DateTimeFilter<"Coin"> | Date | string
    creatorId?: StringFilter<"Coin"> | string
    reputationScore?: IntFilter<"Coin"> | number
    status?: EnumCoinStatusFilter<"Coin"> | $Enums.CoinStatus
    marketCap?: DecimalFilter<"Coin"> | Decimal | DecimalJsLike | number | string
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
    create: XOR<UserCreateWithoutReferrerInput, UserUncheckedCreateWithoutReferrerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReferrerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReferrerInput, UserUncheckedUpdateWithoutReferrerInput>
  }

  export type UserUpdateManyWithWhereWithoutReferrerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReferrerInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    confirmedEmail?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    isVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    verificationTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    pictureUrl?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    referralCode?: StringNullableFilter<"User"> | string | null
    referrerId?: StringNullableFilter<"User"> | string | null
  }

  export type WalletAddressUpsertWithWhereUniqueWithoutUserInput = {
    where: WalletAddressWhereUniqueInput
    update: XOR<WalletAddressUpdateWithoutUserInput, WalletAddressUncheckedUpdateWithoutUserInput>
    create: XOR<WalletAddressCreateWithoutUserInput, WalletAddressUncheckedCreateWithoutUserInput>
  }

  export type WalletAddressUpdateWithWhereUniqueWithoutUserInput = {
    where: WalletAddressWhereUniqueInput
    data: XOR<WalletAddressUpdateWithoutUserInput, WalletAddressUncheckedUpdateWithoutUserInput>
  }

  export type WalletAddressUpdateManyWithWhereWithoutUserInput = {
    where: WalletAddressScalarWhereInput
    data: XOR<WalletAddressUpdateManyMutationInput, WalletAddressUncheckedUpdateManyWithoutUserInput>
  }

  export type WalletAddressScalarWhereInput = {
    AND?: WalletAddressScalarWhereInput | WalletAddressScalarWhereInput[]
    OR?: WalletAddressScalarWhereInput[]
    NOT?: WalletAddressScalarWhereInput | WalletAddressScalarWhereInput[]
    id?: StringFilter<"WalletAddress"> | string
    userId?: StringFilter<"WalletAddress"> | string
    address?: StringFilter<"WalletAddress"> | string
    network?: StringFilter<"WalletAddress"> | string
    createdAt?: DateTimeFilter<"WalletAddress"> | Date | string
    updatedAt?: DateTimeFilter<"WalletAddress"> | Date | string
  }

  export type SocialAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: SocialAccountWhereUniqueInput
    update: XOR<SocialAccountUpdateWithoutUserInput, SocialAccountUncheckedUpdateWithoutUserInput>
    create: XOR<SocialAccountCreateWithoutUserInput, SocialAccountUncheckedCreateWithoutUserInput>
  }

  export type SocialAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: SocialAccountWhereUniqueInput
    data: XOR<SocialAccountUpdateWithoutUserInput, SocialAccountUncheckedUpdateWithoutUserInput>
  }

  export type SocialAccountUpdateManyWithWhereWithoutUserInput = {
    where: SocialAccountScalarWhereInput
    data: XOR<SocialAccountUpdateManyMutationInput, SocialAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type SocialAccountScalarWhereInput = {
    AND?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[]
    OR?: SocialAccountScalarWhereInput[]
    NOT?: SocialAccountScalarWhereInput | SocialAccountScalarWhereInput[]
    id?: StringFilter<"SocialAccount"> | string
    userId?: StringFilter<"SocialAccount"> | string
    platform?: StringFilter<"SocialAccount"> | string
    handle?: StringFilter<"SocialAccount"> | string
    createdAt?: DateTimeFilter<"SocialAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SocialAccount"> | Date | string
  }

  export type TokenHoldingUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenHoldingWhereUniqueInput
    update: XOR<TokenHoldingUpdateWithoutUserInput, TokenHoldingUncheckedUpdateWithoutUserInput>
    create: XOR<TokenHoldingCreateWithoutUserInput, TokenHoldingUncheckedCreateWithoutUserInput>
  }

  export type TokenHoldingUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenHoldingWhereUniqueInput
    data: XOR<TokenHoldingUpdateWithoutUserInput, TokenHoldingUncheckedUpdateWithoutUserInput>
  }

  export type TokenHoldingUpdateManyWithWhereWithoutUserInput = {
    where: TokenHoldingScalarWhereInput
    data: XOR<TokenHoldingUpdateManyMutationInput, TokenHoldingUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenHoldingScalarWhereInput = {
    AND?: TokenHoldingScalarWhereInput | TokenHoldingScalarWhereInput[]
    OR?: TokenHoldingScalarWhereInput[]
    NOT?: TokenHoldingScalarWhereInput | TokenHoldingScalarWhereInput[]
    id?: StringFilter<"TokenHolding"> | string
    userId?: StringFilter<"TokenHolding"> | string
    coinId?: StringFilter<"TokenHolding"> | string
    amount?: DecimalFilter<"TokenHolding"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"TokenHolding"> | Date | string
    updatedAt?: DateTimeFilter<"TokenHolding"> | Date | string
  }

  export type VoteUpsertWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutUserInput, VoteUncheckedUpdateWithoutUserInput>
    create: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutUserInput, VoteUncheckedUpdateWithoutUserInput>
  }

  export type VoteUpdateManyWithWhereWithoutUserInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutUserInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    coinId?: StringFilter<"Vote"> | string
    proposalId?: StringNullableFilter<"Vote"> | string | null
    value?: IntFilter<"Vote"> | number
    createdAt?: DateTimeFilter<"Vote"> | Date | string
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutUserInput, ChatMessageUncheckedUpdateWithoutUserInput>
    create: XOR<ChatMessageCreateWithoutUserInput, ChatMessageUncheckedCreateWithoutUserInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutUserInput, ChatMessageUncheckedUpdateWithoutUserInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutUserInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    userId?: StringFilter<"ChatMessage"> | string
    coinId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    media?: StringNullableFilter<"ChatMessage"> | string | null
    upvotes?: IntFilter<"ChatMessage"> | number
    downvotes?: IntFilter<"ChatMessage"> | number
  }

  export type CommentsUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutUserInput, CommentsUncheckedUpdateWithoutUserInput>
    create: XOR<CommentsCreateWithoutUserInput, CommentsUncheckedCreateWithoutUserInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutUserInput, CommentsUncheckedUpdateWithoutUserInput>
  }

  export type CommentsUpdateManyWithWhereWithoutUserInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentsScalarWhereInput = {
    AND?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    OR?: CommentsScalarWhereInput[]
    NOT?: CommentsScalarWhereInput | CommentsScalarWhereInput[]
    id?: StringFilter<"Comments"> | string
    userId?: StringFilter<"Comments"> | string
    coinId?: StringFilter<"Comments"> | string
    message?: StringFilter<"Comments"> | string
    createdAt?: DateTimeFilter<"Comments"> | Date | string
    upvotes?: IntFilter<"Comments"> | number
    downvotes?: IntFilter<"Comments"> | number
  }

  export type ReputationUpsertWithoutUserInput = {
    update: XOR<ReputationUpdateWithoutUserInput, ReputationUncheckedUpdateWithoutUserInput>
    create: XOR<ReputationCreateWithoutUserInput, ReputationUncheckedCreateWithoutUserInput>
    where?: ReputationWhereInput
  }

  export type ReputationUpdateToOneWithWhereWithoutUserInput = {
    where?: ReputationWhereInput
    data: XOR<ReputationUpdateWithoutUserInput, ReputationUncheckedUpdateWithoutUserInput>
  }

  export type ReputationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
  }

  export type ReputationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    coinId?: StringFilter<"Transaction"> | string
    type?: StringFilter<"Transaction"> | string
    proposalId?: StringNullableFilter<"Transaction"> | string | null
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    price?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type ProposalUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutCreatedByInput, ProposalUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProposalCreateWithoutCreatedByInput, ProposalUncheckedCreateWithoutCreatedByInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutCreatedByInput, ProposalUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProposalUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ProposalScalarWhereInput = {
    AND?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    OR?: ProposalScalarWhereInput[]
    NOT?: ProposalScalarWhereInput | ProposalScalarWhereInput[]
    id?: StringFilter<"Proposal"> | string
    title?: StringFilter<"Proposal"> | string
    description?: StringFilter<"Proposal"> | string
    votesFor?: IntFilter<"Proposal"> | number
    votesAgainst?: IntFilter<"Proposal"> | number
    status?: StringFilter<"Proposal"> | string
    createdAt?: DateTimeFilter<"Proposal"> | Date | string
    votingEnds?: DateTimeFilter<"Proposal"> | Date | string
    createdById?: StringFilter<"Proposal"> | string
    coinId?: StringFilter<"Proposal"> | string
  }

  export type UserCreateWithoutCoinsCreatedInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCoinsCreatedInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCoinsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoinsCreatedInput, UserUncheckedCreateWithoutCoinsCreatedInput>
  }

  export type ChatMessageCreateWithoutCoinInput = {
    id?: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
    user: UserCreateNestedOneWithoutChatMessagesInput
  }

  export type ChatMessageUncheckedCreateWithoutCoinInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
  }

  export type ChatMessageCreateOrConnectWithoutCoinInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutCoinInput, ChatMessageUncheckedCreateWithoutCoinInput>
  }

  export type ChatMessageCreateManyCoinInputEnvelope = {
    data: ChatMessageCreateManyCoinInput | ChatMessageCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type CommentsCreateWithoutCoinInput = {
    id?: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
    user: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentsUncheckedCreateWithoutCoinInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
  }

  export type CommentsCreateOrConnectWithoutCoinInput = {
    where: CommentsWhereUniqueInput
    create: XOR<CommentsCreateWithoutCoinInput, CommentsUncheckedCreateWithoutCoinInput>
  }

  export type CommentsCreateManyCoinInputEnvelope = {
    data: CommentsCreateManyCoinInput | CommentsCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type BondingCurveCreateWithoutCoinInput = {
    id?: string
    curveDetail: JsonNullValueInput | InputJsonValue
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    feeStructure?: FeeStructureCreateNestedOneWithoutBondingCurveInput
  }

  export type BondingCurveUncheckedCreateWithoutCoinInput = {
    id?: string
    curveDetail: JsonNullValueInput | InputJsonValue
    feeStructureId?: string | null
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BondingCurveCreateOrConnectWithoutCoinInput = {
    where: BondingCurveWhereUniqueInput
    create: XOR<BondingCurveCreateWithoutCoinInput, BondingCurveUncheckedCreateWithoutCoinInput>
  }

  export type VoteCreateWithoutCoinInput = {
    id?: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutCoinInput = {
    id?: string
    userId: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
  }

  export type VoteCreateOrConnectWithoutCoinInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutCoinInput, VoteUncheckedCreateWithoutCoinInput>
  }

  export type VoteCreateManyCoinInputEnvelope = {
    data: VoteCreateManyCoinInput | VoteCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type TokenHoldingCreateWithoutCoinInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTokenHoldingsInput
  }

  export type TokenHoldingUncheckedCreateWithoutCoinInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenHoldingCreateOrConnectWithoutCoinInput = {
    where: TokenHoldingWhereUniqueInput
    create: XOR<TokenHoldingCreateWithoutCoinInput, TokenHoldingUncheckedCreateWithoutCoinInput>
  }

  export type TokenHoldingCreateManyCoinInputEnvelope = {
    data: TokenHoldingCreateManyCoinInput | TokenHoldingCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneCreateWithoutCoinInput = {
    id?: string
    date: Date | string
    description: string
  }

  export type MilestoneUncheckedCreateWithoutCoinInput = {
    id?: string
    date: Date | string
    description: string
  }

  export type MilestoneCreateOrConnectWithoutCoinInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutCoinInput, MilestoneUncheckedCreateWithoutCoinInput>
  }

  export type MilestoneCreateManyCoinInputEnvelope = {
    data: MilestoneCreateManyCoinInput | MilestoneCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type HashtagCreateWithoutCoinsInput = {
    id?: string
    tag: string
    usageCount?: number
  }

  export type HashtagUncheckedCreateWithoutCoinsInput = {
    id?: string
    tag: string
    usageCount?: number
  }

  export type HashtagCreateOrConnectWithoutCoinsInput = {
    where: HashtagWhereUniqueInput
    create: XOR<HashtagCreateWithoutCoinsInput, HashtagUncheckedCreateWithoutCoinsInput>
  }

  export type PriceHistoryCreateWithoutCoinInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
  }

  export type PriceHistoryUncheckedCreateWithoutCoinInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
  }

  export type PriceHistoryCreateOrConnectWithoutCoinInput = {
    where: PriceHistoryWhereUniqueInput
    create: XOR<PriceHistoryCreateWithoutCoinInput, PriceHistoryUncheckedCreateWithoutCoinInput>
  }

  export type PriceHistoryCreateManyCoinInputEnvelope = {
    data: PriceHistoryCreateManyCoinInput | PriceHistoryCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCoinInput = {
    id?: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutCoinInput = {
    id?: string
    userId: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCoinInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCoinInput, TransactionUncheckedCreateWithoutCoinInput>
  }

  export type TransactionCreateManyCoinInputEnvelope = {
    data: TransactionCreateManyCoinInput | TransactionCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type ProposalCreateWithoutCoinInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    createdBy: UserCreateNestedOneWithoutProposalsInput
  }

  export type ProposalUncheckedCreateWithoutCoinInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    createdById: string
  }

  export type ProposalCreateOrConnectWithoutCoinInput = {
    where: ProposalWhereUniqueInput
    create: XOR<ProposalCreateWithoutCoinInput, ProposalUncheckedCreateWithoutCoinInput>
  }

  export type ProposalCreateManyCoinInputEnvelope = {
    data: ProposalCreateManyCoinInput | ProposalCreateManyCoinInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoinsCreatedInput = {
    update: XOR<UserUpdateWithoutCoinsCreatedInput, UserUncheckedUpdateWithoutCoinsCreatedInput>
    create: XOR<UserCreateWithoutCoinsCreatedInput, UserUncheckedCreateWithoutCoinsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoinsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoinsCreatedInput, UserUncheckedUpdateWithoutCoinsCreatedInput>
  }

  export type UserUpdateWithoutCoinsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCoinsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutCoinInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutCoinInput, ChatMessageUncheckedUpdateWithoutCoinInput>
    create: XOR<ChatMessageCreateWithoutCoinInput, ChatMessageUncheckedCreateWithoutCoinInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutCoinInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutCoinInput, ChatMessageUncheckedUpdateWithoutCoinInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutCoinInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutCoinInput>
  }

  export type CommentsUpsertWithWhereUniqueWithoutCoinInput = {
    where: CommentsWhereUniqueInput
    update: XOR<CommentsUpdateWithoutCoinInput, CommentsUncheckedUpdateWithoutCoinInput>
    create: XOR<CommentsCreateWithoutCoinInput, CommentsUncheckedCreateWithoutCoinInput>
  }

  export type CommentsUpdateWithWhereUniqueWithoutCoinInput = {
    where: CommentsWhereUniqueInput
    data: XOR<CommentsUpdateWithoutCoinInput, CommentsUncheckedUpdateWithoutCoinInput>
  }

  export type CommentsUpdateManyWithWhereWithoutCoinInput = {
    where: CommentsScalarWhereInput
    data: XOR<CommentsUpdateManyMutationInput, CommentsUncheckedUpdateManyWithoutCoinInput>
  }

  export type BondingCurveUpsertWithoutCoinInput = {
    update: XOR<BondingCurveUpdateWithoutCoinInput, BondingCurveUncheckedUpdateWithoutCoinInput>
    create: XOR<BondingCurveCreateWithoutCoinInput, BondingCurveUncheckedCreateWithoutCoinInput>
    where?: BondingCurveWhereInput
  }

  export type BondingCurveUpdateToOneWithWhereWithoutCoinInput = {
    where?: BondingCurveWhereInput
    data: XOR<BondingCurveUpdateWithoutCoinInput, BondingCurveUncheckedUpdateWithoutCoinInput>
  }

  export type BondingCurveUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeStructure?: FeeStructureUpdateOneWithoutBondingCurveNestedInput
  }

  export type BondingCurveUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    feeStructureId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpsertWithWhereUniqueWithoutCoinInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutCoinInput, VoteUncheckedUpdateWithoutCoinInput>
    create: XOR<VoteCreateWithoutCoinInput, VoteUncheckedCreateWithoutCoinInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutCoinInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutCoinInput, VoteUncheckedUpdateWithoutCoinInput>
  }

  export type VoteUpdateManyWithWhereWithoutCoinInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutCoinInput>
  }

  export type TokenHoldingUpsertWithWhereUniqueWithoutCoinInput = {
    where: TokenHoldingWhereUniqueInput
    update: XOR<TokenHoldingUpdateWithoutCoinInput, TokenHoldingUncheckedUpdateWithoutCoinInput>
    create: XOR<TokenHoldingCreateWithoutCoinInput, TokenHoldingUncheckedCreateWithoutCoinInput>
  }

  export type TokenHoldingUpdateWithWhereUniqueWithoutCoinInput = {
    where: TokenHoldingWhereUniqueInput
    data: XOR<TokenHoldingUpdateWithoutCoinInput, TokenHoldingUncheckedUpdateWithoutCoinInput>
  }

  export type TokenHoldingUpdateManyWithWhereWithoutCoinInput = {
    where: TokenHoldingScalarWhereInput
    data: XOR<TokenHoldingUpdateManyMutationInput, TokenHoldingUncheckedUpdateManyWithoutCoinInput>
  }

  export type MilestoneUpsertWithWhereUniqueWithoutCoinInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutCoinInput, MilestoneUncheckedUpdateWithoutCoinInput>
    create: XOR<MilestoneCreateWithoutCoinInput, MilestoneUncheckedCreateWithoutCoinInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutCoinInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutCoinInput, MilestoneUncheckedUpdateWithoutCoinInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutCoinInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutCoinInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    date?: DateTimeFilter<"Milestone"> | Date | string
    description?: StringFilter<"Milestone"> | string
    coinId?: StringFilter<"Milestone"> | string
  }

  export type HashtagUpsertWithWhereUniqueWithoutCoinsInput = {
    where: HashtagWhereUniqueInput
    update: XOR<HashtagUpdateWithoutCoinsInput, HashtagUncheckedUpdateWithoutCoinsInput>
    create: XOR<HashtagCreateWithoutCoinsInput, HashtagUncheckedCreateWithoutCoinsInput>
  }

  export type HashtagUpdateWithWhereUniqueWithoutCoinsInput = {
    where: HashtagWhereUniqueInput
    data: XOR<HashtagUpdateWithoutCoinsInput, HashtagUncheckedUpdateWithoutCoinsInput>
  }

  export type HashtagUpdateManyWithWhereWithoutCoinsInput = {
    where: HashtagScalarWhereInput
    data: XOR<HashtagUpdateManyMutationInput, HashtagUncheckedUpdateManyWithoutCoinsInput>
  }

  export type HashtagScalarWhereInput = {
    AND?: HashtagScalarWhereInput | HashtagScalarWhereInput[]
    OR?: HashtagScalarWhereInput[]
    NOT?: HashtagScalarWhereInput | HashtagScalarWhereInput[]
    id?: StringFilter<"Hashtag"> | string
    tag?: StringFilter<"Hashtag"> | string
    usageCount?: IntFilter<"Hashtag"> | number
  }

  export type PriceHistoryUpsertWithWhereUniqueWithoutCoinInput = {
    where: PriceHistoryWhereUniqueInput
    update: XOR<PriceHistoryUpdateWithoutCoinInput, PriceHistoryUncheckedUpdateWithoutCoinInput>
    create: XOR<PriceHistoryCreateWithoutCoinInput, PriceHistoryUncheckedCreateWithoutCoinInput>
  }

  export type PriceHistoryUpdateWithWhereUniqueWithoutCoinInput = {
    where: PriceHistoryWhereUniqueInput
    data: XOR<PriceHistoryUpdateWithoutCoinInput, PriceHistoryUncheckedUpdateWithoutCoinInput>
  }

  export type PriceHistoryUpdateManyWithWhereWithoutCoinInput = {
    where: PriceHistoryScalarWhereInput
    data: XOR<PriceHistoryUpdateManyMutationInput, PriceHistoryUncheckedUpdateManyWithoutCoinInput>
  }

  export type PriceHistoryScalarWhereInput = {
    AND?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    OR?: PriceHistoryScalarWhereInput[]
    NOT?: PriceHistoryScalarWhereInput | PriceHistoryScalarWhereInput[]
    id?: StringFilter<"PriceHistory"> | string
    coinId?: StringFilter<"PriceHistory"> | string
    price?: DecimalFilter<"PriceHistory"> | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFilter<"PriceHistory"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutCoinInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCoinInput, TransactionUncheckedUpdateWithoutCoinInput>
    create: XOR<TransactionCreateWithoutCoinInput, TransactionUncheckedCreateWithoutCoinInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCoinInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCoinInput, TransactionUncheckedUpdateWithoutCoinInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCoinInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCoinInput>
  }

  export type ProposalUpsertWithWhereUniqueWithoutCoinInput = {
    where: ProposalWhereUniqueInput
    update: XOR<ProposalUpdateWithoutCoinInput, ProposalUncheckedUpdateWithoutCoinInput>
    create: XOR<ProposalCreateWithoutCoinInput, ProposalUncheckedCreateWithoutCoinInput>
  }

  export type ProposalUpdateWithWhereUniqueWithoutCoinInput = {
    where: ProposalWhereUniqueInput
    data: XOR<ProposalUpdateWithoutCoinInput, ProposalUncheckedUpdateWithoutCoinInput>
  }

  export type ProposalUpdateManyWithWhereWithoutCoinInput = {
    where: ProposalScalarWhereInput
    data: XOR<ProposalUpdateManyMutationInput, ProposalUncheckedUpdateManyWithoutCoinInput>
  }

  export type CoinCreateWithoutMilestonesInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutMilestonesInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutMilestonesInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutMilestonesInput, CoinUncheckedCreateWithoutMilestonesInput>
  }

  export type CoinUpsertWithoutMilestonesInput = {
    update: XOR<CoinUpdateWithoutMilestonesInput, CoinUncheckedUpdateWithoutMilestonesInput>
    create: XOR<CoinCreateWithoutMilestonesInput, CoinUncheckedCreateWithoutMilestonesInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutMilestonesInput, CoinUncheckedUpdateWithoutMilestonesInput>
  }

  export type CoinUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type CoinCreateWithoutHashtagsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutHashtagsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutHashtagsInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutHashtagsInput, CoinUncheckedCreateWithoutHashtagsInput>
  }

  export type CoinUpsertWithWhereUniqueWithoutHashtagsInput = {
    where: CoinWhereUniqueInput
    update: XOR<CoinUpdateWithoutHashtagsInput, CoinUncheckedUpdateWithoutHashtagsInput>
    create: XOR<CoinCreateWithoutHashtagsInput, CoinUncheckedCreateWithoutHashtagsInput>
  }

  export type CoinUpdateWithWhereUniqueWithoutHashtagsInput = {
    where: CoinWhereUniqueInput
    data: XOR<CoinUpdateWithoutHashtagsInput, CoinUncheckedUpdateWithoutHashtagsInput>
  }

  export type CoinUpdateManyWithWhereWithoutHashtagsInput = {
    where: CoinScalarWhereInput
    data: XOR<CoinUpdateManyMutationInput, CoinUncheckedUpdateManyWithoutHashtagsInput>
  }

  export type FeeStructureCreateWithoutBondingCurveInput = {
    id?: string
    tradeFee: number
    memecoinFee: number
    feeDescription: string
  }

  export type FeeStructureUncheckedCreateWithoutBondingCurveInput = {
    id?: string
    tradeFee: number
    memecoinFee: number
    feeDescription: string
  }

  export type FeeStructureCreateOrConnectWithoutBondingCurveInput = {
    where: FeeStructureWhereUniqueInput
    create: XOR<FeeStructureCreateWithoutBondingCurveInput, FeeStructureUncheckedCreateWithoutBondingCurveInput>
  }

  export type CoinCreateWithoutBondingCurveInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutBondingCurveInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutBondingCurveInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutBondingCurveInput, CoinUncheckedCreateWithoutBondingCurveInput>
  }

  export type FeeStructureUpsertWithoutBondingCurveInput = {
    update: XOR<FeeStructureUpdateWithoutBondingCurveInput, FeeStructureUncheckedUpdateWithoutBondingCurveInput>
    create: XOR<FeeStructureCreateWithoutBondingCurveInput, FeeStructureUncheckedCreateWithoutBondingCurveInput>
    where?: FeeStructureWhereInput
  }

  export type FeeStructureUpdateToOneWithWhereWithoutBondingCurveInput = {
    where?: FeeStructureWhereInput
    data: XOR<FeeStructureUpdateWithoutBondingCurveInput, FeeStructureUncheckedUpdateWithoutBondingCurveInput>
  }

  export type FeeStructureUpdateWithoutBondingCurveInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeFee?: FloatFieldUpdateOperationsInput | number
    memecoinFee?: FloatFieldUpdateOperationsInput | number
    feeDescription?: StringFieldUpdateOperationsInput | string
  }

  export type FeeStructureUncheckedUpdateWithoutBondingCurveInput = {
    id?: StringFieldUpdateOperationsInput | string
    tradeFee?: FloatFieldUpdateOperationsInput | number
    memecoinFee?: FloatFieldUpdateOperationsInput | number
    feeDescription?: StringFieldUpdateOperationsInput | string
  }

  export type CoinUpsertWithoutBondingCurveInput = {
    update: XOR<CoinUpdateWithoutBondingCurveInput, CoinUncheckedUpdateWithoutBondingCurveInput>
    create: XOR<CoinCreateWithoutBondingCurveInput, CoinUncheckedCreateWithoutBondingCurveInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutBondingCurveInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutBondingCurveInput, CoinUncheckedUpdateWithoutBondingCurveInput>
  }

  export type CoinUpdateWithoutBondingCurveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutBondingCurveInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type BondingCurveCreateWithoutFeeStructureInput = {
    id?: string
    curveDetail: JsonNullValueInput | InputJsonValue
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    coin: CoinCreateNestedOneWithoutBondingCurveInput
  }

  export type BondingCurveUncheckedCreateWithoutFeeStructureInput = {
    id?: string
    coinId: string
    curveDetail: JsonNullValueInput | InputJsonValue
    isCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BondingCurveCreateOrConnectWithoutFeeStructureInput = {
    where: BondingCurveWhereUniqueInput
    create: XOR<BondingCurveCreateWithoutFeeStructureInput, BondingCurveUncheckedCreateWithoutFeeStructureInput>
  }

  export type BondingCurveUpsertWithoutFeeStructureInput = {
    update: XOR<BondingCurveUpdateWithoutFeeStructureInput, BondingCurveUncheckedUpdateWithoutFeeStructureInput>
    create: XOR<BondingCurveCreateWithoutFeeStructureInput, BondingCurveUncheckedCreateWithoutFeeStructureInput>
    where?: BondingCurveWhereInput
  }

  export type BondingCurveUpdateToOneWithWhereWithoutFeeStructureInput = {
    where?: BondingCurveWhereInput
    data: XOR<BondingCurveUpdateWithoutFeeStructureInput, BondingCurveUncheckedUpdateWithoutFeeStructureInput>
  }

  export type BondingCurveUpdateWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coin?: CoinUpdateOneRequiredWithoutBondingCurveNestedInput
  }

  export type BondingCurveUncheckedUpdateWithoutFeeStructureInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    curveDetail?: JsonNullValueInput | InputJsonValue
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutVotesInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutVotesInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
  }

  export type CoinCreateWithoutVotesInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutVotesInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutVotesInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutVotesInput, CoinUncheckedCreateWithoutVotesInput>
  }

  export type UserUpsertWithoutVotesInput = {
    update: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CoinUpsertWithoutVotesInput = {
    update: XOR<CoinUpdateWithoutVotesInput, CoinUncheckedUpdateWithoutVotesInput>
    create: XOR<CoinCreateWithoutVotesInput, CoinUncheckedCreateWithoutVotesInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutVotesInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutVotesInput, CoinUncheckedUpdateWithoutVotesInput>
  }

  export type CoinUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type UserCreateWithoutChatMessagesInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutChatMessagesInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutChatMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
  }

  export type CoinCreateWithoutChatMessagesInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutChatMessagesInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutChatMessagesInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutChatMessagesInput, CoinUncheckedCreateWithoutChatMessagesInput>
  }

  export type UserUpsertWithoutChatMessagesInput = {
    update: XOR<UserUpdateWithoutChatMessagesInput, UserUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<UserCreateWithoutChatMessagesInput, UserUncheckedCreateWithoutChatMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatMessagesInput, UserUncheckedUpdateWithoutChatMessagesInput>
  }

  export type UserUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CoinUpsertWithoutChatMessagesInput = {
    update: XOR<CoinUpdateWithoutChatMessagesInput, CoinUncheckedUpdateWithoutChatMessagesInput>
    create: XOR<CoinCreateWithoutChatMessagesInput, CoinUncheckedCreateWithoutChatMessagesInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutChatMessagesInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutChatMessagesInput, CoinUncheckedUpdateWithoutChatMessagesInput>
  }

  export type CoinUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutChatMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CoinCreateWithoutCommentsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutCommentsInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutCommentsInput, CoinUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CoinUpsertWithoutCommentsInput = {
    update: XOR<CoinUpdateWithoutCommentsInput, CoinUncheckedUpdateWithoutCommentsInput>
    create: XOR<CoinCreateWithoutCommentsInput, CoinUncheckedCreateWithoutCommentsInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutCommentsInput, CoinUncheckedUpdateWithoutCommentsInput>
  }

  export type CoinUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type UserCreateWithoutReputationInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutReputationInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutReputationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
  }

  export type UserUpsertWithoutReputationInput = {
    update: XOR<UserUpdateWithoutReputationInput, UserUncheckedUpdateWithoutReputationInput>
    create: XOR<UserCreateWithoutReputationInput, UserUncheckedCreateWithoutReputationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReputationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReputationInput, UserUncheckedUpdateWithoutReputationInput>
  }

  export type UserUpdateWithoutReputationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReputationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutWalletAddressesInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutWalletAddressesInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutWalletAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWalletAddressesInput, UserUncheckedCreateWithoutWalletAddressesInput>
  }

  export type UserUpsertWithoutWalletAddressesInput = {
    update: XOR<UserUpdateWithoutWalletAddressesInput, UserUncheckedUpdateWithoutWalletAddressesInput>
    create: XOR<UserCreateWithoutWalletAddressesInput, UserUncheckedCreateWithoutWalletAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWalletAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWalletAddressesInput, UserUncheckedUpdateWithoutWalletAddressesInput>
  }

  export type UserUpdateWithoutWalletAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutWalletAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutSocialAccountsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSocialAccountsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSocialAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
  }

  export type UserUpsertWithoutSocialAccountsInput = {
    update: XOR<UserUpdateWithoutSocialAccountsInput, UserUncheckedUpdateWithoutSocialAccountsInput>
    create: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocialAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocialAccountsInput, UserUncheckedUpdateWithoutSocialAccountsInput>
  }

  export type UserUpdateWithoutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutTokenHoldingsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTokenHoldingsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTokenHoldingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokenHoldingsInput, UserUncheckedCreateWithoutTokenHoldingsInput>
  }

  export type CoinCreateWithoutTokenHoldingsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutTokenHoldingsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutTokenHoldingsInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutTokenHoldingsInput, CoinUncheckedCreateWithoutTokenHoldingsInput>
  }

  export type UserUpsertWithoutTokenHoldingsInput = {
    update: XOR<UserUpdateWithoutTokenHoldingsInput, UserUncheckedUpdateWithoutTokenHoldingsInput>
    create: XOR<UserCreateWithoutTokenHoldingsInput, UserUncheckedCreateWithoutTokenHoldingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokenHoldingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokenHoldingsInput, UserUncheckedUpdateWithoutTokenHoldingsInput>
  }

  export type UserUpdateWithoutTokenHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTokenHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CoinUpsertWithoutTokenHoldingsInput = {
    update: XOR<CoinUpdateWithoutTokenHoldingsInput, CoinUncheckedUpdateWithoutTokenHoldingsInput>
    create: XOR<CoinCreateWithoutTokenHoldingsInput, CoinUncheckedCreateWithoutTokenHoldingsInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutTokenHoldingsInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutTokenHoldingsInput, CoinUncheckedUpdateWithoutTokenHoldingsInput>
  }

  export type CoinUpdateWithoutTokenHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutTokenHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type CoinCreateWithoutPriceHistoryInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutPriceHistoryInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutPriceHistoryInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutPriceHistoryInput, CoinUncheckedCreateWithoutPriceHistoryInput>
  }

  export type CoinUpsertWithoutPriceHistoryInput = {
    update: XOR<CoinUpdateWithoutPriceHistoryInput, CoinUncheckedUpdateWithoutPriceHistoryInput>
    create: XOR<CoinCreateWithoutPriceHistoryInput, CoinUncheckedCreateWithoutPriceHistoryInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutPriceHistoryInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutPriceHistoryInput, CoinUncheckedUpdateWithoutPriceHistoryInput>
  }

  export type CoinUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutPriceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    proposals?: ProposalCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type CoinCreateWithoutTransactionInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    proposals?: ProposalCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutTransactionInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    proposals?: ProposalUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutTransactionInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutTransactionInput, CoinUncheckedCreateWithoutTransactionInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CoinUpsertWithoutTransactionInput = {
    update: XOR<CoinUpdateWithoutTransactionInput, CoinUncheckedUpdateWithoutTransactionInput>
    create: XOR<CoinCreateWithoutTransactionInput, CoinUncheckedCreateWithoutTransactionInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutTransactionInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutTransactionInput, CoinUncheckedUpdateWithoutTransactionInput>
  }

  export type CoinUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type UserCreateWithoutProposalsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    coinsCreated?: CoinCreateNestedManyWithoutCreatorInput
    referrer?: UserCreateNestedOneWithoutReferralsInput
    referrals?: UserCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageCreateNestedManyWithoutUserInput
    comments?: CommentsCreateNestedManyWithoutUserInput
    reputation?: ReputationCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProposalsInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
    referrerId?: string | null
    coinsCreated?: CoinUncheckedCreateNestedManyWithoutCreatorInput
    referrals?: UserUncheckedCreateNestedManyWithoutReferrerInput
    walletAddresses?: WalletAddressUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialAccountUncheckedCreateNestedManyWithoutUserInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentsUncheckedCreateNestedManyWithoutUserInput
    reputation?: ReputationUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProposalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
  }

  export type CoinCreateWithoutProposalsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    creator: UserCreateNestedOneWithoutCoinsCreatedInput
    chatMessages?: ChatMessageCreateNestedManyWithoutCoinInput
    comments?: CommentsCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveCreateNestedOneWithoutCoinInput
    votes?: VoteCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingCreateNestedManyWithoutCoinInput
    milestones?: MilestoneCreateNestedManyWithoutCoinInput
    hashtags?: HashtagCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryCreateNestedManyWithoutCoinInput
    transaction?: TransactionCreateNestedManyWithoutCoinInput
  }

  export type CoinUncheckedCreateWithoutProposalsInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creatorId: string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedCreateNestedManyWithoutCoinInput
    comments?: CommentsUncheckedCreateNestedManyWithoutCoinInput
    bondingCurve?: BondingCurveUncheckedCreateNestedOneWithoutCoinInput
    votes?: VoteUncheckedCreateNestedManyWithoutCoinInput
    tokenHoldings?: TokenHoldingUncheckedCreateNestedManyWithoutCoinInput
    milestones?: MilestoneUncheckedCreateNestedManyWithoutCoinInput
    hashtags?: HashtagUncheckedCreateNestedManyWithoutCoinsInput
    priceHistory?: PriceHistoryUncheckedCreateNestedManyWithoutCoinInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutCoinInput
  }

  export type CoinCreateOrConnectWithoutProposalsInput = {
    where: CoinWhereUniqueInput
    create: XOR<CoinCreateWithoutProposalsInput, CoinUncheckedCreateWithoutProposalsInput>
  }

  export type UserUpsertWithoutProposalsInput = {
    update: XOR<UserUpdateWithoutProposalsInput, UserUncheckedUpdateWithoutProposalsInput>
    create: XOR<UserCreateWithoutProposalsInput, UserUncheckedCreateWithoutProposalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProposalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProposalsInput, UserUncheckedUpdateWithoutProposalsInput>
  }

  export type UserUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrer?: UserUpdateOneWithoutReferralsNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    referrerId?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CoinUpsertWithoutProposalsInput = {
    update: XOR<CoinUpdateWithoutProposalsInput, CoinUncheckedUpdateWithoutProposalsInput>
    create: XOR<CoinCreateWithoutProposalsInput, CoinUncheckedCreateWithoutProposalsInput>
    where?: CoinWhereInput
  }

  export type CoinUpdateToOneWithWhereWithoutProposalsInput = {
    where?: CoinWhereInput
    data: XOR<CoinUpdateWithoutProposalsInput, CoinUncheckedUpdateWithoutProposalsInput>
  }

  export type CoinUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type CoinCreateManyCreatorInput = {
    id?: string
    name: string
    ticker: string
    description?: string | null
    pictureUrl: string
    telegramLink: string
    discordLink: string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: Decimal | DecimalJsLike | number | string
    airdropAmount?: Decimal | DecimalJsLike | number | string
    blockchain?: $Enums.Blockchain | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reputationScore?: number
    status?: $Enums.CoinStatus
    marketCap?: Decimal | DecimalJsLike | number | string
  }

  export type UserCreateManyReferrerInput = {
    id?: string
    username?: string | null
    email?: string | null
    confirmedEmail?: string | null
    emailVerified?: Date | string | null
    passwordHash: string
    role?: string
    isVerified?: boolean
    verificationToken?: string | null
    verificationTokenExpiresAt?: Date | string | null
    resetToken?: string | null
    resetTokenExpiresAt?: Date | string | null
    pictureUrl?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    referralCode?: string | null
  }

  export type WalletAddressCreateManyUserInput = {
    id?: string
    address: string
    network: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialAccountCreateManyUserInput = {
    id?: string
    platform: string
    handle: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenHoldingCreateManyUserInput = {
    id?: string
    coinId: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoteCreateManyUserInput = {
    id?: string
    coinId: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
  }

  export type ChatMessageCreateManyUserInput = {
    id?: string
    coinId: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
  }

  export type CommentsCreateManyUserInput = {
    id?: string
    coinId: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    coinId: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ProposalCreateManyCreatedByInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    coinId: string
  }

  export type CoinUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    hashtags?: HashtagUncheckedUpdateManyWithoutCoinsNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUpdateManyWithoutCreatorNestedInput
    referrals?: UserUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutUserNestedInput
    comments?: CommentsUpdateManyWithoutUserNestedInput
    reputation?: ReputationUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    proposals?: ProposalUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
    coinsCreated?: CoinUncheckedUpdateManyWithoutCreatorNestedInput
    referrals?: UserUncheckedUpdateManyWithoutReferrerNestedInput
    walletAddresses?: WalletAddressUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialAccountUncheckedUpdateManyWithoutUserNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutUserNestedInput
    reputation?: ReputationUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    verificationTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    referralCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WalletAddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletAddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletAddressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    network?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    handle?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenHoldingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coin?: CoinUpdateOneRequiredWithoutTokenHoldingsNestedInput
  }

  export type TokenHoldingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenHoldingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coin?: CoinUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    coin?: CoinUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type ChatMessageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    coin?: CoinUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    coin?: CoinUpdateOneRequiredWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    coinId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    coin?: CoinUpdateOneRequiredWithoutProposalsNestedInput
  }

  export type ProposalUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    coinId?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    coinId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateManyCoinInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
    media?: string | null
    upvotes?: number
    downvotes?: number
  }

  export type CommentsCreateManyCoinInput = {
    id?: string
    userId: string
    message: string
    createdAt?: Date | string
    upvotes?: number
    downvotes?: number
  }

  export type VoteCreateManyCoinInput = {
    id?: string
    userId: string
    proposalId?: string | null
    value: number
    createdAt?: Date | string
  }

  export type TokenHoldingCreateManyCoinInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateManyCoinInput = {
    id?: string
    date: Date | string
    description: string
  }

  export type PriceHistoryCreateManyCoinInput = {
    id?: string
    price: Decimal | DecimalJsLike | number | string
    timestamp?: Date | string
  }

  export type TransactionCreateManyCoinInput = {
    id?: string
    userId: string
    type: string
    proposalId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    price: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ProposalCreateManyCoinInput = {
    id?: string
    title: string
    description: string
    votesFor?: number
    votesAgainst?: number
    status?: string
    createdAt?: Date | string
    votingEnds: Date | string
    createdById: string
  }

  export type ChatMessageUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutChatMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type ChatMessageUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentsUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentsUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentsUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
  }

  export type VoteUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenHoldingUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTokenHoldingsNestedInput
  }

  export type TokenHoldingUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenHoldingUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type MilestoneUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type HashtagUpdateWithoutCoinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type HashtagUncheckedUpdateWithoutCoinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type HashtagUncheckedUpdateManyWithoutCoinsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
  }

  export type PriceHistoryUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceHistoryUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    proposalId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutProposalsNestedInput
  }

  export type ProposalUncheckedUpdateWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type ProposalUncheckedUpdateManyWithoutCoinInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    votesFor?: IntFieldUpdateOperationsInput | number
    votesAgainst?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votingEnds?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type CoinUpdateWithoutHashtagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    creator?: UserUpdateOneRequiredWithoutCoinsCreatedNestedInput
    chatMessages?: ChatMessageUpdateManyWithoutCoinNestedInput
    comments?: CommentsUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUpdateOneWithoutCoinNestedInput
    votes?: VoteUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUpdateManyWithoutCoinNestedInput
    priceHistory?: PriceHistoryUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateWithoutHashtagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    chatMessages?: ChatMessageUncheckedUpdateManyWithoutCoinNestedInput
    comments?: CommentsUncheckedUpdateManyWithoutCoinNestedInput
    bondingCurve?: BondingCurveUncheckedUpdateOneWithoutCoinNestedInput
    votes?: VoteUncheckedUpdateManyWithoutCoinNestedInput
    tokenHoldings?: TokenHoldingUncheckedUpdateManyWithoutCoinNestedInput
    milestones?: MilestoneUncheckedUpdateManyWithoutCoinNestedInput
    priceHistory?: PriceHistoryUncheckedUpdateManyWithoutCoinNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutCoinNestedInput
    proposals?: ProposalUncheckedUpdateManyWithoutCoinNestedInput
  }

  export type CoinUncheckedUpdateManyWithoutHashtagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ticker?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    pictureUrl?: StringFieldUpdateOperationsInput | string
    telegramLink?: StringFieldUpdateOperationsInput | string
    discordLink?: StringFieldUpdateOperationsInput | string
    socialLinks?: NullableJsonNullValueInput | InputJsonValue
    totalSupply?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    airdropAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    blockchain?: NullableEnumBlockchainFieldUpdateOperationsInput | $Enums.Blockchain | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creatorId?: StringFieldUpdateOperationsInput | string
    reputationScore?: IntFieldUpdateOperationsInput | number
    status?: EnumCoinStatusFieldUpdateOperationsInput | $Enums.CoinStatus
    marketCap?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}